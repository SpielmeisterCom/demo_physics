/**
 * need.js - A requiresque require.js replacement for usage in browsers.
 */

( function( document ) {
	var modules  = {}

	var arrayContains = function( array, value ) {
		return array.indexOf( value ) !== -1
	}

	var createUrlWithCacheBreaker = function( url ) {
		return url + '?t=' + Date.now()
	}

	var createModuleSource = function( scriptName, source ) {
		return source + '\n//# sourceURL=' + scriptName
	}

	var createRequest = function( url ) {
		var request = new XMLHttpRequest()

		request.open(
			'GET',
			createUrlWithCacheBreaker( url ),
			false
		)

		request.send()

		return request
	}

	var loadModule = function( name, libraryUrl, libraryManager ) {
		var scriptName = name + '.js',
			cachedEntry,
			source

		if( libraryManager ) {
			cachedEntry = libraryManager.get( scriptName )
		}

		if( cachedEntry ) {
			source = cachedEntry

		} else {
			var moduleUrl = libraryUrl ? libraryUrl + '/' + scriptName : scriptName,
				request   = createRequest( moduleUrl )

			if( request.status !== 200 &&
				request.status !== 0 ) {

				throw 'Error: Loading \'' + moduleUrl + '\' failed.'
			}

			source = request.responseText
		}

		eval( createModuleSource( scriptName, source ) )

		return modules[ name ]
	}

	var createModule = function( name, config ) {
		var module = loadModule( name, config.libraryUrl, config.libraryManager )

		if( !module ) throw 'Error: Could not load module \'' + name + '\'.'

		modules[ name ] = module

		return module
	}

	var createModuleInstance = function( dependencies, body, args, config ) {
		var moduleInstanceArgs = []

		if( dependencies ) {
			for( var i = 0; i < dependencies.length; i++ ) {
				var dependencyName   = dependencies[ i ],
					dependencyModule = modules[ dependencyName ]

				if( !dependencyModule && config.hashModuleId ) {
					dependencyModule = modules[ config.hashModuleId( dependencyName ) ]
				}

				if( !dependencyModule ) {
					dependencyModule = createModule( dependencyName, config )
				}

				if( !dependencyModule.instance ) {
					dependencyModule.instance = createModuleInstance( dependencyModule.dependencies, dependencyModule.body, undefined, config )
				}

				moduleInstanceArgs.push( dependencyModule.instance )
			}
		}

		if( args ) moduleInstanceArgs.push( args )

		return body.apply( null, moduleInstanceArgs )
	}

	var createDependentModulesR = function( dependencyName, result ) {
		for( var dependentName in modules ) {
			var dependentModule = modules[ dependentName ]

			if( !dependentModule ) {
				throw 'Error: Module id "' + dependentName + '" could not be resolved.'
			}

			if( arrayContains( dependentModule.dependencies, dependencyName ) &&
				!arrayContains( result, dependentName ) ) {

				result.push( dependentName )

				createDependentModulesR( dependentName, result )
			}
		}

		return result
	}

	var createDependentModules = function( name ) {
		return createDependentModulesR( name, [] )
	}

	var define = function( name ) {
		var numArguments = arguments.length,
			arg1         = arguments[ 1 ]

		if( numArguments < 2 ||
			numArguments > 3 ) {

			throw 'Error: Module definition is invalid.'
		}

		// call this function again through eval
		if( typeof( arg1 ) === 'string' ) {
			eval( createModuleSource( name + '.js', arg1 ) )

			return
		}

		// "redefine" the module
		if( modules[ name ] ) {
			modules[ name ].instance = undefined

			// reset instances of all dependent modules so that consecutive calls to require need to rebuild their dependencies with updated module instances
			var dependentModules = createDependentModules( name )

			for( var i = 0, n = dependentModules.length; i < n; i++ ) {
				modules[ dependentModules[ i ] ].instance = undefined
			}
		}

		// create the module
		modules[ name ] = {
			body         : numArguments === 2 ? arg1 : arguments[ 2 ],
			dependencies : numArguments === 2 ? [] : arg1,
			instance     : undefined
		}
	}

	var require = function( name, args, config ) {
		if( !name ) throw 'Error: No module name provided.'

		var module = modules[ name ]

		if( !module && config.hashModuleId ) {
			module = modules[ config.hashModuleId( name ) ]
		}

		if( !module ) {
			if( config.loadingAllowed === false ) {
				throw 'Error: Missing module \'' + name + '\'. External loading is disabled. Please make sure that all required modules are shipped.'
			}

			module = createModule( name, config )
		}

		if( !module.instance ) {
			module.instance = createModuleInstance( module.dependencies, module.body, args, config )
		}

		return module.instance
	}

	window.define = define
	window.require = require
	window.createDependentModules = createDependentModules
} )( document )
define(
	'spell/shared/util/platform/initDebugEnvironment',
	[
		'spell/shared/util/platform/private/initDebugEnvironment'
	],
	function(
		initDebugEnvironment
	) {
		'use strict'


		return initDebugEnvironment
	}
)

define(
	'spell/shared/util/physics/createBox2dWorld',
	[
		'spell/shared/util/platform/PlatformKit',

		'spell/functions'
	],
	function(
		PlatformKit,

		_
	) {
		'use strict'


		var Box2D              = PlatformKit.Box2D,
			createB2Vec2       = Box2D.Common.Math.createB2Vec2,
			createB2World      = Box2D.Dynamics.createB2World,
			b2Body             = Box2D.Dynamics.b2Body,
			createB2BodyDef    = Box2D.Dynamics.createB2BodyDef,
			createB2FilterData = Box2D.Dynamics.createB2FilterData,
			idToBody           = {}

		var getBodyById = function( entityId ) {
			return idToBody[ entityId ]
		}

		var applyForce = function( entityId, force, point ) {
			var body = this.getBodyById( entityId )
			if( !body ) return

			var scale  = this.scale,
				forceX = force[ 0 ] * scale,
				forceY = force[ 1 ] * scale

			if( forceX || forceY ) {
				body.ApplyForce(
					createB2Vec2( forceX, forceY ),
					point ?
						createB2Vec2( point[ 0 ] * scale, point[ 1 ] * scale ) :
						body.GetWorldCenter()
				)
			}
		}

		var applyTorque = function( entityId, torque ) {
			var body = this.getBodyById( entityId )
			if( !body ) return

			if( torque ) {
				body.ApplyTorque( torque * this.scale )
			}
		}

		var applyImpulse = function( entityId, impulse, point ) {
			var body = this.getBodyById( entityId )
			if( !body ) return

			var scale    = this.scale,
				impulseX = impulse[ 0 ] * scale,
				impulseY = impulse[ 1 ] * scale

			if( impulseX || impulseY ) {
				body.ApplyImpulse(
					createB2Vec2( impulseX, impulseY ),
					point ?
						createB2Vec2( point[ 0 ] * scale, point[ 1 ] * scale ) :
						body.GetWorldCenter()
				)
			}
		}

		var setVelocity = function( entityId, velocity ) {
			var body = this.getBodyById( entityId )
			if( !body ) return

			var scale = this.scale

			body.SetLinearVelocity(
				createB2Vec2( velocity[ 0 ] * scale, velocity[ 1 ] * scale )
			)
		}

		var setFilterData = function( entityId, categoryBits, maskBits ) {
			var body = this.getBodyById( entityId )
			if( !body ) return

			for( var fixture = body.GetFixtureList(); fixture; fixture = fixture.GetNext() ) {
				var filterData    = fixture.GetFilterData(),
					newFilterData = createB2FilterData()

				newFilterData.categoryBits = categoryBits === undefined ?
					filterData.categoryBits :
					categoryBits

				newFilterData.maskBits = maskBits === undefined ?
					filterData.maskBits :
					maskBits

				fixture.SetFilterData( newFilterData )
			}
		}

		var setAwake = function( entityId, state ) {
			var body = this.getBodyById( entityId )
			if( !body ) return

			body.SetAwake( state )
		}

		var setPosition = function( entityId, position ) {
			var body = this.getBodyById( entityId )
			if( !body ) return

			var scale = this.scale

			body.SetPosition(
				createB2Vec2( position[ 0 ] * scale, position[ 1 ] * scale )
			)
		}

		var getBodyType = function( type ) {
			return type === 'static' ? b2Body.b2_staticBody :
				type === 'dynamic' ? b2Body.b2_dynamicBody :
					type === 'kinematic' ? b2Body.b2_kinematicBody :
						undefined
		}

		var isBodyTypeStatic = function( type ) {
			return type === 'static'
		}

		var createBodyDef = function( entityId, body, transform ) {
			var translation = transform.translation,
				bodyDef     = createB2BodyDef(),
				type        = getBodyType( body.type ),
				scale       = this.scale

			if( type === undefined ) return

			bodyDef.awake         = !isBodyTypeStatic( body.type )
			bodyDef.fixedRotation = body.fixedRotation
			bodyDef.type          = type
			bodyDef.position.x    = translation[ 0 ] * scale
			bodyDef.position.y    = translation[ 1 ] * scale
			bodyDef.angle         = transform.rotation
			bodyDef.userData      = entityId

			var body = this.rawWorld.CreateBody( bodyDef )

			idToBody[ entityId ] = body

			return body
		}

		var destroyBody = function( entityId ) {
			var body = this.getBodyById( entityId )
			if( !body ) return

			delete idToBody[ entityId ]

			this.rawWorld.DestroyBody( body )
		}

		var getRawWorld = function() {
			return this.rawWorld
		}

		var Box2dWorld = function( doSleep, gravity, scale ) {
			if( doSleep === undefined ) doSleep = true
			if( !gravity ) gravity = [ 0, 0 ]
			if( !scale ) scale = 1

			this.rawWorld = createB2World(
				createB2Vec2( gravity[ 0 ], gravity[ 1 ] ),
				doSleep
			)

			this.scale = scale
		}

		Box2dWorld.prototype = {
			applyForce    : applyForce,
			applyImpulse  : applyImpulse,
			applyTorque   : applyTorque,
			createBodyDef : createBodyDef,
			destroyBody   : destroyBody,
			getBodyById   : getBodyById,
			getRawWorld   : getRawWorld,
			setAwake      : setAwake,
			setFilterData : setFilterData,
			setPosition   : setPosition,
			setVelocity   : setVelocity
		}

		return function( doSleep, gravity, scale ) {
			return new Box2dWorld( doSleep, gravity, scale )
		}
	}
)

define(
	'spell/shared/util/physics/createBox2dContext',
	[
		'spell/shared/util/physics/createBox2dWorld'
	],
	function(
		createBox2dWorld
	) {
		'use strict'


		return function() {
			return {
				createWorld : createBox2dWorld
			}
		}
	}
)

define(
	'spell/shared/util/platform/log',
	[
		'spell/shared/util/platform/private/log'
	],
	function(
		log
	) {
		'use strict'


		return log
	}
)

/**
 * The Console enables logging of messages. Messages logged to this console are shown in the SpellEd console.
 *
 * The following log levels are available: LOG_LEVEL_DEBUG (0), LOG_LEVEL_INFO (1), LOG_LEVEL_WARN (2), LOG_LEVEL_ERROR (3), LOG_LEVEL_SILENT (4). The
 * log level is used for filtering the logged messages. For example setting the log level to *LOG_LEVEL_WARN* (2) causes all messages with a lower level
 * to be discarded without being logged. The default log level is LOG_LEVEL_INFO (1). If you want to disable all logging set the log level to
 * *LOG_LEVEL_SILENT* (4).
 *
 * Example:
 *
 *     spell.console.debug( "collected gold : " + numGold )
 *
 * @class spell.console
 * @singleton
 */
define(
	'spell/Console',
	[
		'spell/shared/util/platform/log'
	],
	function(
		platformLog
	) {
		'use strict'


		var LOG_LEVEL_DEBUG  = 0,
			LOG_LEVEL_INFO   = 1,
			LOG_LEVEL_WARN   = 2,
			LOG_LEVEL_ERROR  = 3,
			LOG_LEVEL_SILENT = 4

		var logLevels = [
			'DEBUG',
			'INFO',
			'WARN',
			'ERROR',
			'SILENT'
		]

		var validate = function( logLevel ) {
			if( logLevel < 0 ||
				logLevel > 4 ) {

				throw 'Log level ' + logLevel + ' is not supported.'
			}
		}

		var createMessage = function( level, text ) {
			return logLevels[ level ] + ' - ' + text
		}


		var Console = function( level ) {
			validate( level )

			this.currentLogLevel     = level || LOG_LEVEL_INFO
			this.sendMessageToEditor = undefined
		}

		Console.prototype = {
			LOG_LEVEL_DEBUG : LOG_LEVEL_DEBUG,

			LOG_LEVEL_INFO : LOG_LEVEL_INFO,

			LOG_LEVEL_WARN : LOG_LEVEL_WARN,

			LOG_LEVEL_ERROR : LOG_LEVEL_ERROR,

			LOG_LEVEL_SILENT : LOG_LEVEL_SILENT,

			/**
			 * Sets the callback that establishes forwarding of log messages to the editor.
			 *
			 * @param {Function} fn
			 */
			setSendMessageToEditor : function( fn ) {
				this.sendMessageToEditor = fn
			},

			/**
			 * Sets the current log level.
			 *
			 * @param {Number} level
			 */
			setLogLevel : function( level ) {
				validate( level )

				this.currentLogLevel = level
			},

			/**
			 * Logs the supplied text with the supplied level.
			 *
			 * @param {Number} level
			 * @param {String} text
			 */
			log : function( level, text ) {
				if( arguments.length === 1 ) {
					text = level
					level = LOG_LEVEL_DEBUG
				}

				if( level < this.currentLogLevel ) return

				if( this.sendMessageToEditor ) {
					this.sendMessageToEditor(
						'spelled.debug.consoleMessage',
						{
							level : logLevels[ level ],
							text : text
						}
					)
				}

				platformLog( createMessage( level, text ) )
			},

			/**
			 * Logs the supplied message with log level LOG_LEVEL_DEBUG.
			 *
			 * @param {String} message
			 */
			debug : function( message ) {
				this.log( LOG_LEVEL_DEBUG, message )
			},

			/**
			 * Logs the supplied message with log level LOG_LEVEL_INFO.
			 *
			 * @param {String} message
			 */
			info : function( message ) {
				this.log( LOG_LEVEL_INFO, message )
			},

			/**
			 * Logs the supplied message with log level LOG_LEVEL_WARN.
			 *
			 * @param {String} message
			 */
			warn : function( message ) {
				this.log( LOG_LEVEL_WARN, message )
			},

			/**
			 * Logs the supplied message with log level LOG_LEVEL_ERROR.
			 *
			 * @param {String} message
			 */
			error : function( message ) {
				this.log( LOG_LEVEL_ERROR, message )
			}
		}

		return Console
	}
)

define(
	'spell/StatisticsManager',
	[
		'spell/data/Tree'
	],
	function(
		Tree
	) {
		'use strict'


		var NUM_VALUES   = 63,
			FLOAT_DIGITS = 1

		var addNode = Tree.addNode,
			getNode = Tree.getNode,
			eachNode = Tree.eachNode

		var createBuffer = function( bufferSize ) {
			var buffer = []

			while( bufferSize > 0 ) {
				buffer.push( 0 )
				bufferSize--
			}

			return buffer
		}

		/**
		 * Computes the "standard deviation of the sample".
		 * See http://en.wikipedia.org/wiki/Standard_deviation#Standard_deviation_of_the_sample
		 *
		 * @param expected
		 * @param values
		 */
		var createStandardDeviation = function( expected, values ) {
			var numValues = values.length,
				sum = 0

			for( var i = 0; i < numValues; i++ ) {
				sum += Math.pow( values[ i ] - expected, 2 )
			}

			return Math.sqrt( sum / numValues )
		}

		var createNode = function( id ) {
			return {
				children : [],
				id : id,
				metrics : [ 0, 0, 0, 0 ],
				values : createBuffer( NUM_VALUES )
			}
		}

		var updateNodeMetrics = function( node ) {
			var values = node.values,
				mean = 0,
				min = Number.MAX_VALUE,
				max = 0,
				sum = 0

			for( var i = 0, numValues = values.length; i < numValues; i++ ) {
				var value = values[ i ]

				if( value === 0 ) continue

				if( value < min ) min = value
				if( value > max ) max = value

				sum += value
			}

			if( sum !== 0 ) {
				mean = sum / NUM_VALUES

			} else {
				min = 0
			}

			var metrics = node.metrics

			metrics[ 0 ] = mean.toFixed( FLOAT_DIGITS )
			metrics[ 1 ] = min.toFixed( FLOAT_DIGITS )
			metrics[ 2 ] = max.toFixed( FLOAT_DIGITS )
			metrics[ 3 ] = createStandardDeviation( mean, values ).toFixed( 2 )
		}

		var incrementNode = function( node ) {
			var values = node.values

			values.shift()
			values.push( 0 )
		}

		var resetNode = function( node ) {
			var values = node.values

			for( var i = 0, n = values.length; i < n; i++ ) {
				values[ i ] = 0
			}
		}


		var StatisticsManager = function() {
			this.tree = null
			this.timestamps = createBuffer( NUM_VALUES )

			this.totalTickTimeInMs = 0
			this.numTicks = 0
		}

		StatisticsManager.prototype = {
			init : function() {
				this.tree = createNode( 'total' )

				addNode( this.tree, 'total', createNode( 'render' ) )
				addNode( this.tree, 'total', createNode( 'update' ) )
			},
			addNode : function( id, parentId ) {
				var success = addNode( this.tree, parentId, createNode( id ) )

				if( !success ) {
					throw 'Could not add node "' + id + '" to parent node "' + parentId + '".'
				}
			},
			/*
			 * call this method to signal the beginning of a new measurement period
			 */
			startTick : function( timestamp, elapsedTimeInMs ) {
				this.totalTickTimeInMs += elapsedTimeInMs
				this.numTicks++

				var timestamps = this.timestamps

				timestamps.shift()
				timestamps.push( timestamp )

				eachNode( this.tree, incrementNode )
			},
			updateNode : function( id, value ) {
				var node = getNode( this.tree, id )
				if( !node ) return

				node.values[ node.values.length - 1 ] += value
			},
			getMetrics : function( periodInMs ) {
				eachNode( this.tree, updateNodeMetrics )

				return this.tree
			},
			getAverageTickTime : function() {
				return Math.round( this.totalTickTimeInMs / this.numTicks )
			},
			reset : function() {
				this.totalTickTimeInMs = 0
				this.numTicks = 0

				eachNode( this.tree, resetNode )
			}
		}

		return StatisticsManager
	}
)

/**
 * @class spell.pluginManager
 * @singleton
 */
define(
	'spell/PluginManager',
	[
		'spell/shared/util/platform/PlatformKit'
	],
	function(
		PlatformKit
	) {
		'use strict'


		var PluginManager = function() {
			this.plugins = PlatformKit.getPlugins()
		}

		PluginManager.prototype = {
			getById : function( pluginId ) {
				return this.plugins[ pluginId ]
			}
		}

		return PluginManager
	}
)

define(
	"spell/math/hash/SHA256",
	function() {
		/* A JavaScript implementation of the SHA family of hashes, as defined in FIPS
		 * PUB 180-2 as well as the corresponding HMAC implementation as defined in
		 * FIPS PUB 198a
		 *
		 * Version 1.31 Copyright Brian Turek 2008-2012
		 * Distributed under the BSD License
		 * See http://caligatio.github.com/jsSHA/ for more information
		 *
		 * Several functions taken from Paul Johnson
		 */

		var charSize = 8,
		b64pad = "=",
		hexCase = 0,

		str2binb = function (str)
		{
			var bin = [], mask = (1 << charSize) - 1,
					length = str.length * charSize, i;

			for (i = 0; i < length; i += charSize)
			{
				bin[i >> 5] |= (str.charCodeAt(i / charSize) & mask) <<
						(32 - charSize - (i % 32));
			}

			return bin;
		},

		hex2binb = function (str)
		{
			var bin = [], length = str.length, i, num;

			for (i = 0; i < length; i += 2)
			{
				num = parseInt(str.substr(i, 2), 16);
				if (!isNaN(num))
				{
					bin[i >> 3] |= num << (24 - (4 * (i % 8)));
				}
				else
				{
					return "INVALID HEX STRING";
				}
			}

			return bin;
		},

		binb2hex = function (binarray)
		{
			var hex_tab = (hexCase) ? "0123456789ABCDEF" : "0123456789abcdef",
					str = "", length = binarray.length * 4, i, srcByte;

			for (i = 0; i < length; i += 1)
			{
				srcByte = binarray[i >> 2] >> ((3 - (i % 4)) * 8);
				str += hex_tab.charAt((srcByte >> 4) & 0xF) +
						hex_tab.charAt(srcByte & 0xF);
			}

			return str;
		},

		binb2b64 = function (binarray)
		{
			var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz" +
							"0123456789+/", str = "", length = binarray.length * 4, i, j,
					triplet;

			for (i = 0; i < length; i += 3)
			{
				triplet = (((binarray[i >> 2] >> 8 * (3 - i % 4)) & 0xFF) << 16) |
						(((binarray[i + 1 >> 2] >> 8 * (3 - (i + 1) % 4)) & 0xFF) << 8) |
						((binarray[i + 2 >> 2] >> 8 * (3 - (i + 2) % 4)) & 0xFF);
				for (j = 0; j < 4; j += 1)
				{
					if (i * 8 + j * 6 <= binarray.length * 32)
					{
						str += tab.charAt((triplet >> 6 * (3 - j)) & 0x3F);
					}
					else
					{
						str += b64pad;
					}
				}
			}
			return str;
		},

		rotr = function (x, n)
		{
			return (x >>> n) | (x << (32 - n));
		},

		shr = function (x, n)
		{
			return x >>> n;
		},

		ch = function (x, y, z)
		{
			return (x & y) ^ (~x & z);
		},

		maj = function (x, y, z)
		{
			return (x & y) ^ (x & z) ^ (y & z);
		},

		sigma0 = function (x)
		{
			return rotr(x, 2) ^ rotr(x, 13) ^ rotr(x, 22);
		},

		sigma1 = function (x)
		{
			return rotr(x, 6) ^ rotr(x, 11) ^ rotr(x, 25);
		},

		gamma0 = function (x)
		{
			return rotr(x, 7) ^ rotr(x, 18) ^ shr(x, 3);
		},

		gamma1 = function (x)
		{
			return rotr(x, 17) ^ rotr(x, 19) ^ shr(x, 10);
		},

		safeAdd_2 = function (x, y)
		{
			var lsw = (x & 0xFFFF) + (y & 0xFFFF),
					msw = (x >>> 16) + (y >>> 16) + (lsw >>> 16);

			return ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);
		},

		safeAdd_4 = function (a, b, c, d)
		{
			var lsw = (a & 0xFFFF) + (b & 0xFFFF) + (c & 0xFFFF) + (d & 0xFFFF),
					msw = (a >>> 16) + (b >>> 16) + (c >>> 16) + (d >>> 16) +
							(lsw >>> 16);

			return ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);
		},

		safeAdd_5 = function (a, b, c, d, e)
		{
			var lsw = (a & 0xFFFF) + (b & 0xFFFF) + (c & 0xFFFF) + (d & 0xFFFF) +
							(e & 0xFFFF),
					msw = (a >>> 16) + (b >>> 16) + (c >>> 16) + (d >>> 16) +
							(e >>> 16) + (lsw >>> 16);

			return ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);
		},

		coreSHA2 = function (message, messageLen, variant)
		{
			var a, b, c, d, e, f, g, h, T1, T2, H, lengthPosition, i, t, K, W = [],
					appendedMessageLength;

			if (variant === "SHA-224" || variant === "SHA-256")
			{
				lengthPosition = (((messageLen + 65) >> 9) << 4) + 15;
				K = [
					0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
					0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
					0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
					0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
					0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
					0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
					0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
					0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
					0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
					0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
					0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
					0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
					0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
					0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
					0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
					0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
				];

				if (variant === "SHA-224")
				{
					H = [
						0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
						0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4
					];
				}
				else
				{
					H = [
						0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A,
						0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19
					];
				}
			}

			message[messageLen >> 5] |= 0x80 << (24 - messageLen % 32);
			message[lengthPosition] = messageLen;

			appendedMessageLength = message.length;

			for (i = 0; i < appendedMessageLength; i += 16)
			{
				a = H[0];
				b = H[1];
				c = H[2];
				d = H[3];
				e = H[4];
				f = H[5];
				g = H[6];
				h = H[7];

				for (t = 0; t < 64; t += 1)
				{
					if (t < 16)
					{
						W[t] = message[t + i];
					}
					else
					{
						W[t] = safeAdd_4(
								gamma1(W[t - 2]), W[t - 7],
								gamma0(W[t - 15]), W[t - 16]
						);
					}

					T1 = safeAdd_5(h, sigma1(e), ch(e, f, g), K[t], W[t]);
					T2 = safeAdd_2(sigma0(a), maj(a, b, c));
					h = g;
					g = f;
					f = e;
					e = safeAdd_2(d, T1);
					d = c;
					c = b;
					b = a;
					a = safeAdd_2(T1, T2);
				}

				H[0] = safeAdd_2(a, H[0]);
				H[1] = safeAdd_2(b, H[1]);
				H[2] = safeAdd_2(c, H[2]);
				H[3] = safeAdd_2(d, H[3]);
				H[4] = safeAdd_2(e, H[4]);
				H[5] = safeAdd_2(f, H[5]);
				H[6] = safeAdd_2(g, H[6]);
				H[7] = safeAdd_2(h, H[7]);
			}

			switch (variant)
			{
				case "SHA-224":
					return [
						H[0], H[1], H[2], H[3],
						H[4], H[5], H[6]
					];
				case "SHA-256":
					return H;
				default:
					return [];
			}
		},

		jsSHA = function (srcString, inputFormat)
		{

			this.sha224 = null;
			this.sha256 = null;

			this.strBinLen = null;
			this.strToHash = null;

			if ("HEX" === inputFormat)
			{
				if (0 !== (srcString.length % 2))
				{
					return "TEXT MUST BE IN BYTE INCREMENTS";
				}
				this.strBinLen = srcString.length * 4;
				this.strToHash = hex2binb(srcString);
			}
			else if (("ASCII" === inputFormat) ||
					('undefined' === typeof(inputFormat)))
			{
				this.strBinLen = srcString.length * charSize;
				this.strToHash = str2binb(srcString);
			}
			else
			{
				return "UNKNOWN TEXT INPUT TYPE";
			}
		};

		jsSHA.prototype = {
			getHash : function (variant, format)
			{
				var formatFunc = null, message = this.strToHash.slice();

				switch (format)
				{
					case "HEX":
						formatFunc = binb2hex;
						break;
					case "B64":
						formatFunc = binb2b64;
						break;
					default:
						return "FORMAT NOT RECOGNIZED";
				}

				switch (variant)
				{
					case "SHA-224":
						if (null === this.sha224)
						{
							this.sha224 = coreSHA2(message, this.strBinLen, variant);
						}
						return formatFunc(this.sha224);
					case "SHA-256":
						if (null === this.sha256)
						{
							this.sha256 = coreSHA2(message, this.strBinLen, variant);
						}
						return formatFunc(this.sha256);
					default:
						return "HASH NOT RECOGNIZED";
				}
			},

			getHMAC : function (key, inputFormat, variant, outputFormat)
			{
				var formatFunc, keyToUse, i, retVal, keyBinLen, hashBitSize,
						keyWithIPad = [], keyWithOPad = [];

				switch (outputFormat)
				{
					case "HEX":
						formatFunc = binb2hex;
						break;
					case "B64":
						formatFunc = binb2b64;
						break;
					default:
						return "FORMAT NOT RECOGNIZED";
				}

				switch (variant)
				{
					case "SHA-224":
						hashBitSize = 224;
						break;
					case "SHA-256":
						hashBitSize = 256;
						break;
					default:
						return "HASH NOT RECOGNIZED";
				}

				if ("HEX" === inputFormat)
				{
					if (0 !== (key.length % 2))
					{
						return "KEY MUST BE IN BYTE INCREMENTS";
					}
					keyToUse = hex2binb(key);
					keyBinLen = key.length * 4;
				}
				else if ("ASCII" === inputFormat)
				{
					keyToUse = str2binb(key);
					keyBinLen = key.length * charSize;
				}
				else
				{
					return "UNKNOWN KEY INPUT TYPE";
				}

				if (64 < (keyBinLen / 8))
				{
					keyToUse = coreSHA2(keyToUse, keyBinLen, variant);
					keyToUse[15] &= 0xFFFFFF00;
				}
				else if (64 > (keyBinLen / 8))
				{
					keyToUse[15] &= 0xFFFFFF00;
				}

				for (i = 0; i <= 15; i += 1)
				{
					keyWithIPad[i] = keyToUse[i] ^ 0x36363636;
					keyWithOPad[i] = keyToUse[i] ^ 0x5C5C5C5C;
				}

				retVal = coreSHA2(
						keyWithIPad.concat(this.strToHash),
						512 + this.strBinLen, variant);
				retVal = coreSHA2(
						keyWithOPad.concat(retVal),
						512 + hashBitSize, variant);

				return (formatFunc(retVal));
			}
		};

		return jsSHA
	}
)



define(
	'spell/shared/util/hashModuleId',
	[
		'spell/math/hash/SHA256'
	],
	function(
		SHA256
	) {
		'use strict'


		return function( text ) {
			var shaObj = new SHA256( text, 'ASCII' )

			return shaObj.getHash( 'SHA-256', 'B64' )
		}
	}
)

define(
	'spell/shared/util/createModuleLoader',
	[
		'spell/shared/util/hashModuleId',
		'spell/shared/util/platform/PlatformKit'
	],
	function(
		hashModuleId,
		PlatformKit
	) {
		'use strict'


		var instance

		return function( libraryManager, isModeDevelopment, libraryUrl ) {
			if( !instance ) {
				instance = {
					require : function( moduleId ) {
						var config = {
							libraryManager : isModeDevelopment ? libraryManager : undefined,
							hashModuleId   : hashModuleId,
							loadingAllowed : isModeDevelopment,
							libraryUrl     : libraryUrl
						}

						return PlatformKit.ModuleLoader.require( moduleId, null, config )
					}
				}
			}

			return instance
		}
	}
)

define(
	'spell/shared/util/createUrlWithCacheBreaker',
	[
		'spell/shared/util/platform/Types'
	],
	function(
		Types
	) {
		'use strict'


		return function( url ) {
			return url + '?t=' + Types.Time.getCurrentInMs()
		}
	}
)

define(
	'spell/shared/util/createIdFromLibraryFilePath',
	function() {
		'use strict'


		return function( libraryFilePath, asArray ) {
			// strip the file extension
			var tmp = libraryFilePath.substr( 0, libraryFilePath.lastIndexOf( '.' ) )

			return asArray ?
				tmp.split( '/' ) :
				tmp.replace( /\//g, '.' )
		}
	}
)

define(
	'spell/LibraryManager',
	[
		'spell/client/loading/addNamespaceAndName',
		'spell/shared/util/createIdFromLibraryFilePath',
		'spell/shared/util/createLibraryFilePath',
		'spell/shared/util/createLibraryFilePathFromId',
		'spell/shared/util/createUrlWithCacheBreaker',
		'spell/shared/util/platform/PlatformKit',

		'spell/functions'
	],
	function(
		addNamespaceAndName,
		createIdFromLibraryFilePath,
		createLibraryFilePath,
		createLibraryFilePathFromId,
		createUrlWithCacheBreaker,
		PlatformKit,

		_
	) {
		'use strict'


		var nextLoadingProcessId = 0

		var createLoadingProcessId = function() {
			return nextLoadingProcessId++
		}

		var resourceJsonDecoder = function( resource ) {
			return PlatformKit.jsonCoder.decode( resource )
		}

		var createResourceTypeToLoaderFactory = function( renderingContext, soundContext ) {
			var createTexture = _.bind( PlatformKit.createImageLoader, null, renderingContext ),
				createSound   = _.bind( PlatformKit.createSoundLoader, null, soundContext ),
				createText    = _.bind( PlatformKit.createTextLoader, null, resourceJsonDecoder )

			return {
				jpeg : createTexture,
				png  : createTexture,
				mp3  : createSound,
				wav  : createSound,
				ogg  : createSound,
				json : createText
			}
		}

		var getLoaderFactory = function( resourceTypeToLoaderFactory, type, libraryFilePath ) {
			var actualType = 'auto' ?
				_.last( libraryFilePath.split( '.' ) ) :
				type

			return resourceTypeToLoaderFactory[ actualType ]
		}

		var createLoadingProcess = function( id, libraryIdsToLibraryFilePaths, libraryUrl, invalidateCache, config, next ) {
			return {
				assetManager       : config.assetManager,
				id                 : id,
				libraryFilePaths   : libraryIdsToLibraryFilePaths,
				invalidateCache    : invalidateCache,
				numCompleted       : 0,
				name               : config.name,
				next               : next,
				type               : config.type ? config.type : 'auto',
				libraryUrl         : libraryUrl,
				omitCache          : !!config.omitCache,
				onLoadingCompleted : config.onLoadingCompleted,
				isMetaDataLoad     : config.isMetaDataLoad !== undefined ? config.isMetaDataLoad : true
			}
		}

		var updateProgress = function( eventManager, cache, loadingProcesses, loadingProcess ) {
			loadingProcess.numCompleted++

			var libraryFilePaths = loadingProcess.libraryFilePaths,
				numLibraryPaths  = _.size( libraryFilePaths ),
				progress         = loadingProcess.numCompleted / numLibraryPaths,
				name             = loadingProcess.name

			eventManager.publish(
				[ eventManager.EVENT.RESOURCE_PROGRESS, name ],
				[ progress, loadingProcess.numCompleted, numLibraryPaths ]
			)

			if( loadingProcess.numCompleted === numLibraryPaths ) {
				var loadedLibraryRecords = _.pick( cache, _.keys( libraryFilePaths ) )

				if( loadingProcess.isMetaDataLoad ) {
					addNamespaceAndName( loadedLibraryRecords )
				}

				if( loadingProcess.onLoadingCompleted ) {
					loadingProcess.onLoadingCompleted( loadedLibraryRecords )
				}

				delete loadingProcesses[ loadingProcess.id ]

				if( name ) {
					eventManager.publish(
						[ eventManager.EVENT.RESOURCE_LOADING_COMPLETED, name ],
						[ loadedLibraryRecords ]
					)
				}

				if( loadingProcess.next ) {
					loadingProcess.next()
				}
			}
		}

		var onLoadCallback = function( eventManager, cache, loadingProcesses, loadingProcess, libraryId, libraryFilePath, loadedResource ) {
			if( !loadedResource ) {
				throw 'Error: Loading library file "' + libraryFilePath + '" from loading process "' + loadingProcess.id + '" returned a false value.'
			}

			cache[ libraryId ] = loadedResource

			updateProgress( eventManager, cache, loadingProcesses, loadingProcess )
		}

		var onErrorCallback = function( eventManager, cache, loadingProcesses, loadingProcess, libraryId, libraryFilePath ) {
			throw 'Error: Loading library file "' + libraryFilePath + '" failed.'
		}

		var onTimedOutCallback = function( eventManager, cache, loadingProcesses, loadingProcess, libraryId, libraryFilePath ) {
			throw 'Error: Loading library file "' + libraryFilePath + '" timed out.'
		}

		var startLoadingProcess = function( cache, eventManager, resourceTypeToLoaderFactory, loadingProcesses, loadingProcess ) {
			var omitCache        = loadingProcess.omitCache,
				libraryFilePaths = loadingProcess.libraryFilePaths

			for( var libraryId in libraryFilePaths ) {
				var libraryFilePath = libraryFilePaths[ libraryId ]

				if( !omitCache ) {
					var cachedEntry = cache[ libraryId ]

					if( cachedEntry ) {
						onLoadCallback( eventManager, cache, loadingProcesses, loadingProcess, libraryId, libraryFilePath, cachedEntry )

						continue
					}
				}

				var loaderFactory = getLoaderFactory( resourceTypeToLoaderFactory, loadingProcess.type, libraryFilePath )

				if( !loaderFactory ) {
					throw 'Error: Unable to load resource of type "' + loadingProcess.type + '".'
				}

				var url = loadingProcess.libraryUrl ?
					loadingProcess.libraryUrl + '/' + libraryFilePath :
					libraryFilePath

				var loader = loaderFactory(
					loadingProcess.assetManager,
					libraryId,
					loadingProcess.invalidateCache ? createUrlWithCacheBreaker( url ) : url,
					_.bind( onLoadCallback, null, eventManager, cache, loadingProcesses, loadingProcess, libraryId, libraryFilePath ),
					_.bind( onErrorCallback, null, eventManager, cache, loadingProcesses, loadingProcess, libraryId, libraryFilePath ),
					_.bind( onTimedOutCallback, null, eventManager, cache, loadingProcesses, loadingProcess, libraryId, libraryFilePath )
				)

				if( !loader ) {
					throw 'Could not create a loader for resource "' + libraryFilePath + '".'
				}

				loader.start()
			}
		}


		var LibraryManager = function( eventManager, libraryUrl, isModeDeployed ) {
			this.eventManager                = eventManager
			this.loadingProcesses            = {}
			this.libraryUrl                  = libraryUrl
			this.invalidateCache             = !isModeDeployed
			this.resourceTypeToLoaderFactory

			this.cache = {
				metaData : {},
				resource : {}
			}
		}

		LibraryManager.prototype = {
			get : function( libraryId ) {
				var cache = this.cache

				return cache.metaData[ libraryId ] || cache.resource[ libraryId ]
			},

			getMetaData : function( libraryId ) {
				return this.cache.metaData[ libraryId ]
			},

			getResource : function( libraryId ) {
				return this.cache.resource[ libraryId ]
			},

			getMetaDataRecordsByType : function( type ) {
				return _.reduce(
					this.cache.metaData,
					function( memo, metaDataRecord, libraryId ) {
						if( metaDataRecord.type === type ) {
							memo[ libraryId ] = metaDataRecord
						}

						return memo
					},
					{}
				)
			},

			addToCache : function( content ) {
				var tmp = _.reduce(
					content,
					function( memo, key, value ) {
						var extension = value.substr( value.lastIndexOf( '.' ) + 1, value.length ),
							isScript  = extension === 'js'

						memo[ isScript ? value : createIdFromLibraryFilePath( value ) ] = key

						return memo
					},
					{}
				)

				_.extend( this.cache.metaData, tmp )
				addNamespaceAndName( this.cache.metaData )
			},

			isAvailable : function( libraryIds ) {
				var cache = this.cache

				for( var i = 0, entry, libraryId, n = libraryIds.length; i < n; i++ ) {
					libraryId = libraryIds[ i ]
					entry = cache.metaData[ libraryId ]

					if( !entry ||
						( entry.file && !cache.resource[ libraryId ] ) ) {

						return false
					}
				}

				return true
			},

			free : function() {
				this.cache.resource = {}
			},

			load : function( libraryIdsToLibraryFilePaths, config, next ) {
				if( !this.resourceTypeToLoaderFactory ) {
					throw 'Error: Library manager is not properly initialized.'
				}

				if( _.size( libraryIdsToLibraryFilePaths ) === 0 ) {
					throw 'Error: No library file paths provided.'
				}

				var id = createLoadingProcessId()

				var loadingProcess = createLoadingProcess(
					id,
					libraryIdsToLibraryFilePaths,
					this.libraryUrl,
					this.invalidateCache,
					config || {},
					next
				)

				this.loadingProcesses[ id ] = loadingProcess

				startLoadingProcess(
					loadingProcess.isMetaDataLoad ? this.cache.metaData : this.cache.resource,
					this.eventManager,
					this.resourceTypeToLoaderFactory,
					this.loadingProcesses,
					loadingProcess
				)

				return id
			},

			init : function( audioContext, renderingContext ) {
				this.resourceTypeToLoaderFactory = createResourceTypeToLoaderFactory( renderingContext, audioContext )
			}
		}

		return LibraryManager
	}
)

/**
 * The InputManager provides handling of user input.
 *
 * @class spell.inputManager
 * @singleton
 */
define(
	'spell/InputManager',
	[
		'spell/shared/util/platform/PlatformKit',
		'spell/shared/util/input/keyCodes',

		'spell/functions'
	],
	function(
		PlatformKit,
		keyCodes,

		_
	) {
		'use strict'


		var Command = function( id, isStart ) {
			this.id = id
			this.isStart = isStart
		}

		Command.prototype = {
			getEventName : function() {
				return this.getType() + this.id
			},
			getType : function() {
				return this.isStart ? 'start' : 'stop'
			}
		}

		var inputEvents               = [],
			commands                  = [],
			isKeyCodePressed          = {},
			inputEventTypeToListeners = {},
			inputContexts             = {}

		var processEvent = function( event ) {
			var type      = event.type,
				isKeyDown = type === 'keyDown',
				isKeyUp   = type === 'keyUp',
				isClick   = type === 'click'

			if( !isClick ) {
				//the click event can be only processed via addListener
				inputEvents.push( event )
			}

			if( isKeyDown || isKeyUp ) {
				var keyCode = event.keyCode,
					repeat  = isKeyCodePressed[ keyCode ] === isKeyDown

				if( repeat ) return

				isKeyCodePressed[ keyCode ] = isKeyDown

				// create command if it is mapped by an input context
				var command = createCommand( inputContexts, keyCode, isKeyDown )

				if( command ) {
					commands.push( command )
				}
			}

			// process registered input event listeners
			var registeredListeners = inputEventTypeToListeners[ type ]

			if( registeredListeners ) {
				for( var i = 0, n = registeredListeners.length; i < n; i++ ) {
					registeredListeners[ i ].call( null, event )
				}
			}
		}

		var createCommand = function( inputContexts, keyCode, isStart ) {
			for( var id in inputContexts ) {
				var inputContext = inputContexts[ id ]

				for( var mappedKeyCode in inputContext ) {
					if( mappedKeyCode == keyCode ) {
						var command = inputContext[ mappedKeyCode ]

						return new Command(
							command.substr( 0, 1 ).toUpperCase() + command.substr( 1, command.length ),
							isStart
						)
					}
				}
			}
		}

		var createKeyEvent = function( type, keyCode ) {
			return {
				type : type,
				keyCode : keyCode
			}
		}


		var InputManager = function( configurationManager, renderingContext ) {
			this.nativeInput = PlatformKit.createInput( configurationManager, renderingContext )
		}

		InputManager.prototype = {
			/**
			 * Initialize the InputManager and register all input binding.
			 * This function is being called by spellCore, don't call it yourself!
			 *
			 * @private
			 */
			init : function() {
				this.nativeInput.setInputEventListener( processEvent )
			},

			/**
			 * Destroys the InputManager and unregister all input bindings.
			 * This function is being called by spellCore, don't call it yourself!
			 *
			 * @private
			 */
			destroy : function() {
				this.nativeInput.removeInputEventListener()
			},

			/**
			 * Get the InputEvents queue
			 *
			 * @return {Array}
			 */
			getInputEvents : function() {
				return inputEvents
			},

			/**
			 * Clear the current input event queue.
			 */
			clearInputEvents : function() {
				inputEvents.length = 0
			},

			/**
			 * Returns true if the key with the given key code is currently pressed, false otherwise.
			 *
			 * Example:
			 *
			 *     var inputManager = spell.inputManager
			 *
			 *     if( inputManager.isKeyPressed( inputManager.KEY.SPACE ) ) {
			 *         // do stuff
			 *     }
			 *
			 * @param {String} keyCode
			 * @return {Boolean}
			 */
			isKeyPressed : function( keyCode ) {
				return isKeyCodePressed[ keyCode ]
			},

			/**
			 * Injects a key event into the input manager processing pipeline.
			 *
			 * @param {String} type the key event type (keyDown, keyUp)
			 * @param {String} keyCode the key code
			 */
			injectKeyEvent : function( type, keyCode ) {
				processEvent( createKeyEvent( type, keyCode ) )
			},

			/**
			 * Adds a listener for events of the type specified by eventType.
			 *
			 * Example:
			 *
			 *     var processSpaceDown = function( event ) {
			 *         if( event.keyCode === spell.inputManager.KEY.SPACE ) {
			 *             // do something clever
			 *         }
			 *     }
			 *
			 *     spell.inputManager.addListener( 'keyDown', processSpaceDown )
			 *
			 * @param {String} eventType can be any of the following values: keyDown, keyUp, pointerDown, pointerMove, pointerUp, pointerCancel
			 * @param {Function} listener
			 */
			addListener : function( eventType, listener ) {
				var registeredListeners = inputEventTypeToListeners[ eventType ] || ( inputEventTypeToListeners[ eventType ] = [] )

				registeredListeners.push( listener )
			},

			/**
			 * Removes a listener for events of the type specified by eventType
			 *
			 * Example:
			 *
			 *     var processSpaceDown = function( event ) {
			 *         if( event.keyCode === spell.inputManager.KEY.SPACE ) {
			 *             // do something clever
			 *         }
			 *     }
			 *
			 *     spell.inputManager.removeListener( 'keyDown', processSpaceDown )
			 *
			 * @param {String} eventType can be any of the following values: keyDown, keyUp, pointerDown, pointerMove, pointerUp, pointerCancel
			 * @param {Function} listener
			 */
			removeListener : function( eventType, listener ) {
				var registeredListeners = inputEventTypeToListeners[ eventType ]

				if( !registeredListeners ) return

				inputEventTypeToListeners[ eventType ] = _.filter(
					registeredListeners,
					function( registeredListener ) {
						return registeredListener !== listener
					}
				)
			},

			/**
			 * Adds an input context.
			 *
			 * Example:
			 *
			 *     spell.inputManager.addInputContext(
			 *         'myInputContext',
			 *         spell.assetManager.get( 'myGame.myInputMapAsset' )
			 *     )
			 *
			 * @param {String} id a unique string that identifies the input context
			 * @param {Object} inputMap the inputMap asset maps input to commands
			 */
			addInputContext : function( id, inputMap ) {
				inputContexts[ id ] = inputMap
			},

			/**
			 * Removes an input context.
			 *
			 * Example:
			 *
			 *     spell.inputManager.removeInputContext( 'myInputContext' )
			 *
			 * @param {String} id a unique string that identifies the input context
			 */
			removeInputContext : function( id ) {
				delete inputContexts[ id ]
			},

			/**
			 * Returns the list of queued commands.
			 *
			 * @return {Array}
			 */
			getCommands : function() {
				return commands
			},

			/**
			 * Clears the list of queued commands.
			 */
			clearCommands : function() {
				commands.length = 0
			},

			/**
			 * Map of supported keys.
			 */
			KEY : keyCodes
		}

		return InputManager
	}
)

define(
	'spell/data/forestMultiMap',
	[
		'spell/functions'
	],
	function(
		_
	) {
		'use strict'


		function createNode() {
			return {
				subNodes: {},
				elements: []
			}
		}

		function getElements( node ) {
			if( !node ) {
				return []

			} else {
				return _.reduce(
					node.subNodes,
					function( elements, subNode ) {
						return elements.concat( getElements( subNode ) )
					},
					node.elements
				)
			}
		}

		function getNode( node, key, eachNode ) {
			return _.reduce(
				key,
				function( node, keyComponent ) {
					if( node === undefined ) return undefined

					if( eachNode !== undefined ) eachNode( node, keyComponent )

					return node.subNodes[ keyComponent ]
				},
				node
			)
		}


		return {
			create: function() {
				return createNode()
			},

			add: function(
				data,
				key,
				element
			) {
				var node = getNode(
					data,
					key,
					function( node, keyComponent ) {
						if ( !node.subNodes.hasOwnProperty( keyComponent ) ) {
							node.subNodes[ keyComponent ] = createNode()
						}
					}
				)

				node.elements.push( element )
			},

			remove: function(
				data,
				key,
				elementToRemove
			) {
				var node = getNode( data, key )

				if( elementToRemove === undefined ) {
					node.elements.length = 0

				} else {
					node.elements = _.filter( node.elements, function( element ) {
						return element !== elementToRemove
					} )
				}
			},

			get: function(
				data,
				key
			) {
				return getElements( getNode( data, key ) )
			}
		}
	}
)

/**
 * The EventManager offers access to the engine internal message bus. It can be used to implement observer behavior.
 *
 * @class spell.eventManager
 * @singleton
 */
define(
	'spell/EventManager',
	[
		'spell/data/forestMultiMap',

		'spell/functions'
	],
	function(
		forestMultiMap,

		_
	) {
		'use strict'


		var wrapArray = function( x ) {
			return _.isArray( x ) ? x : [ x ]
		}

		var waitForChainConfig = false

		var registerWaitForChain = function( eventManager, config ) {
			var callback = config.callback

			// the lock is released after the n-th call ( n := config.events.length )
			var lock = _.after(
				config.events.length,
				function() {
					callback()
				}
			)

			// wire up all events to probe the lock
			_.each(
				config.events,
				function( event ) {
					var handler = function( eventArgs ) {
						if( event.subscriber ) event.subscriber( eventArgs )

						eventManager.unsubscribe( event.scope, handler )

						lock()
					}

					eventManager.subscribe( event.scope, handler )
				}
			)
		}


		function EventManager() {
			this.subscribers = forestMultiMap.create()
		}

		EventManager.prototype = {
			/**
			 * Subscribes a subscriber to the specified event scope.
			 *
			 * Example:
			 *
			 *     var processTransformCreated = function( component, entityId ) {
			 *         ...
			 *     }
			 *
			 *     spell.eventManager.subscribe(
			 *         [ spell.eventManager.EVENT.COMPONENT_CREATED, 'spell.component.2d.transform' ],
			 *         processTransformCreated
			 *     )
			 *
			 * @param {String|String[]} scope can either be a string or an array of strings specifying the event scope
			 * @param {Function} subscriber the callback function
			 */
			subscribe : function( scope, subscriber ) {
				var wrappedScope = wrapArray( scope )

				forestMultiMap.add(
					this.subscribers,
					wrappedScope,
					subscriber
				)

				this.publish( this.EVENT.SUBSCRIBE, [ wrappedScope, subscriber ] )
			},

			/**
			 * Unsubscribes a subscriber from the specified event scope.
			 *
			 * Example:
			 *
			 *     var processTransformCreated = function( component, entityId ) {
			 *         ...
			 *     }
			 *
			 *     spell.eventManager.unsubscribe(
			 *         [ spell.eventManager.EVENT.COMPONENT_CREATED, 'spell.component.2d.transform' ],
			 *         processTransformCreated
			 *     )
			 *
			 * @param {String|String[]} scope can either be a string or an array of strings specifying the event scope
			 * @param {Function} subscriber the callback function
			 */
			unsubscribe : function( scope, subscriber ) {
				var wrappedScope = wrapArray( scope )

				forestMultiMap.remove( this.subscribers, wrappedScope, subscriber )

				this.publish( this.EVENT.UNSUBSCRIBE, [ wrappedScope, subscriber ] )
			},

			/**
			 * Unsubscribes all subscribers from the specified event scope.
			 *
			 * Example:
			 *
			 *     spell.eventManager.unsubscribeAll(
			 *         [ spell.eventManager.EVENT.COMPONENT_CREATED, 'spell.component.2d.transform' ]
			 *     )
			 *
			 * @param {String|String[]} scope can either be a string or an array of strings specifying the event scope
			 */
			unsubscribeAll : function( scope ) {
				var wrappedScope = wrapArray( scope )

				forestMultiMap.remove( this.subscribers, wrappedScope )

				this.publish( this.EVENT.UNSUBSCRIBE, [ wrappedScope ] )
			},

			/**
			 * Publishes the event to all subscribers which are subscribed to the specified event scope.
			 *
			 * Example:
			 *
			 *     spell.eventManager.publish( spell.eventManager.EVENT.SERVER_CONNECTION_ESTABLISHED, [ response.status ] )
			 *
			 * @param {String|String[]} scope can either be a string or an array of strings specifying the event scope
			 * @param {Array} eventArgs an array of event arguments
			 */
			publish : function( scope, eventArgs ) {
				var subscribersInScope = forestMultiMap.get( this.subscribers, wrapArray( scope ) ),
					wrappedEventArgs   = wrapArray( eventArgs )

				_.each( subscribersInScope, function( subscriber ) {
					subscriber.apply( undefined, wrappedEventArgs )
				} )

				return true
			},

			waitFor : function( scope, subscriber ) {
				waitForChainConfig = {
					events : [ {
						scope      : wrapArray( scope ),
						subscriber : subscriber
					} ]
				}

				return this
			},

			and : function( scope, subscriber ) {
				// check if pending chain call exists
				if( !waitForChainConfig ) throw 'A call to the method "and" must be chained to a previous call to "waitFor".'

				waitForChainConfig.events.push( {
					scope      : wrapArray( scope ),
					subscriber : subscriber
				} )

				return this
			},

			resume : function( callback ) {
				// check if pending chain call exists, return otherwise
				if( !waitForChainConfig ) throw 'A call to the method "resume" must be chained to a previous call to "waitFor" or "and".'

				waitForChainConfig.callback = callback

				registerWaitForChain( this, waitForChainConfig )

				waitForChainConfig = false
			},

			/**
			 * Map of supported events.
			 */
			EVENT : {
				SERVER_CONNECTION_ESTABLISHED : 0,
				MESSAGE_RECEIVED : 1,
				CLOCK_SYNC_ESTABLISHED : 2,
				COMPONENT_CREATED : 3,
				COMPONENT_REMOVED : 4,
				COMPONENT_UPDATED : 5,
				ENTITY_CREATED : 6,
				ENTITY_DESTROYED : 7, // skip sending all the component removal events and just destroy the entity
				ENTITY_REMOVED : 8, // perform an ordered removal of the entity, that is send component removal events
				ASSET_UPDATED : 9,
				SUBSCRIBE : 10,
				UNSUBSCRIBE : 11,
				RESOURCE_PROGRESS : 12,
				RESOURCE_LOADING_COMPLETED : 13,
				AVAILABLE_SCREEN_SIZE_CHANGED : 14,
				SCREEN_RESIZE : 15,
				DEVICE_ORIENTATION_CHANGED : 16,
				VISIBILITY_CHANGED : 17
			}
		}

		return EventManager
	}
)

/**
 * The ConfigurationManager offers access to various engine internal configuration options.
 *
 * Example:
 *     var screenSize = spell.configurationManager.getValue( 'currentScreenSize' )
 *
 *     spell.logger.debug( screenSize )
 *
 * @class spell.configurationManager
 * @singleton
 */
define(
	'spell/ConfigurationManager',
	[
		'spell/client/util/createIncludedRectangle',
		'spell/math/util',
		'spell/math/vec2',
		'spell/shared/util/platform/PlatformKit',

		'spell/functions'
	],
	function(
		createIncludedRectangle,
		mathUtil,
		vec2,
		PlatformKit,

		_
	) {
		'use strict'


		var createScreenSize = function( availableScreenSize, aspectRatio ) {
			return aspectRatio ?
				createIncludedRectangle( availableScreenSize, aspectRatio, true ) :
				availableScreenSize
		}

		var extractDefault = function( validValues, value ) {
			return _.contains( validValues, value ) ? value : false
		}

		var extractVec2 =  function( validValues, v ) {
			var parts = _.isArray( v ) ?
				v :
				v.split( ',' )

			if( parts.length !== 2 ) {
				throw 'Could not create vec2 from string "' + v + '".'
			}

			var x = parseInt( parts[ 0 ], 10 ),
				y = parseInt( parts[ 1 ], 10 )

			if( _.isNaN( x ) || _.isNaN( y ) ) {
				throw 'Could not create vec2 from string "' + v + '".'
			}

			return [ x, y ]
		}

		// These are the platform agnostic options.
		//
		// The property "configurable" controls if the option can be overridden by the environment configuration set up by the stage-0-loader.
		var validOptions = _.extend(
			{
				// The screen mode which the user requested. Can be either "fit" or "fixed". If set to "fit" the maximum available screen area is used and the
				// option "screenSize" is ignored. If set to "fixed" the option "screenSize" is used to determine the used screen size. The default is "fit".
				screenMode : {
					validValues : [ 'fill', 'fit', 'fixed' ],
					configurable : true,
					extractor : extractDefault
				},
				// The screen size which the user requested.
				screenSize : {
					configurable : true,
					extractor : extractVec2
				},
				// The screen size which is currently used.
				currentScreenSize : {
					configurable : false
				},
				id : {
					configurable : true
				},
				mode : {
					validValues : [ 'deployed', 'development_embedded', 'development_standalone' ],
					configurable : true
				},
				quadTreeSize : {
					configurable : true
				},
				projectId : {
					configurable : true
				},
				supportedLanguages : {
					configurable : true
				},
				defaultLanguage : {
					configurable : true
				},
				currentLanguage : {
					configurable : true
				},
				loadingScene : {
					configurable : true
				},
				quality : {
					configurable : true
				},
				qualityLevels : {
					configurable : true
				},
				currentQualityLevel : {
					configurable : true
				}
			},
			PlatformKit.configurationOptions.validOptions
		)

		// These options are used when they are not overridden by the environment configuration set up by the stage-0-loader.
		var defaultOptions = _.extend(
			{
				screenMode              : 'fixed',
				screenSize              : [ 300, 200 ],
				currentScreenSize       : [ 300, 200 ],
				quadTreeSize            : 1048576, // 2^20
				projectId               : '',
				id                      : 'spell', // dom node id
				'platform.id'           : PlatformKit.platformDetails.getPlatform(),
				'platform.hasPlentyRAM' : PlatformKit.platformDetails.hasPlentyRAM()
			},
			PlatformKit.configurationOptions.defaultOptions
		)

		var update = function( config, defaultOptions, validOptions, name, value ) {
			var option = validOptions[ name ]

			if( option ) {
				if( !option.configurable ) {
					return config
				}

				var result = option.extractor ?
					option.extractor( option.validValues, value ) :
					value

				config[ name ] = result === undefined ?
					( option.extractor ?
						option.extractor( option.validValues, defaultOptions[ name ] ) :
						result ) :
					result

			} else {
				config[ name ] = value
			}
		}


		var ConfigurationManager = function( eventManager ) {
			this.config       = defaultOptions
			this.eventManager = eventManager

			eventManager.subscribe(
				[ eventManager.EVENT.AVAILABLE_SCREEN_SIZE_CHANGED ],
				_.bind(
					function( availableScreenSize ) {
						var config               = this.config,
							screenMode           = config.screenMode || 'fixed',
							aspectRatioOverwrite = config.screenAspectRatio > 0 ,
							screenSize           = config.screenSize

						if( aspectRatioOverwrite ) {
							config.currentScreenSize = createScreenSize( availableScreenSize, config.screenAspectRatio )

						} else if( screenMode === 'fit' ) {
							// set the screen size up to the limits provided by the "screenSize" configuration option
							var clampedAvailableScreenSize = [
								mathUtil.clamp( availableScreenSize[ 0 ], 1, screenSize[ 0 ] ),
								mathUtil.clamp( availableScreenSize[ 1 ], 1, screenSize[ 1 ] )
							]

							config.currentScreenSize = createScreenSize(
								clampedAvailableScreenSize,
								screenSize[ 0 ] / screenSize[ 1 ]
							)

						} else if( screenMode === 'fixed' ) {
							config.currentScreenSize = screenSize

						} else if( screenMode === 'fill' ) {
							config.currentScreenSize = [ availableScreenSize[ 0 ], availableScreenSize[ 1 ] ]

						} else {
							throw 'Error: Screen mode \'' + screenMode + '\' is not supported.'
						}

						eventManager.publish( eventManager.EVENT.SCREEN_RESIZE, [ config.currentScreenSize ] )
					},
					this
				)
			)
		}

		ConfigurationManager.prototype = {
			/**
			 * Sets the configuration option key to value.
			 *
			 * @private
			 * @param {String} key
			 * @param {String} value
			 */
			setValue : function( key, value ) {
				var config = this.config

				if( key === 'defaultLanguage' ) {
					config.currentLanguage = value

				} else if( key === 'currentLanguage' ) {
					if( _.contains( config.supportedLanguages, value ) ) {
						config.currentLanguage = value
					}

					return

				} else if( key === 'quality' &&
					config.qualityLevels ) {

					var qualityLevel = config.qualityLevels[ value ]

					if( qualityLevel ) {
						config.currentQualityLevel = qualityLevel
					}

					return
				}

				update( config, defaultOptions, validOptions, key, value )

				if( key === 'screenAspectRatio' ||
					key === 'screenMode' ) {

					this.eventManager.publish(
						this.eventManager.EVENT.AVAILABLE_SCREEN_SIZE_CHANGED,
						[ PlatformKit.getAvailableScreenSize( this.getValue( 'id' ) ) ]
					)

				} else if( key === 'screenSize' ) {
					vec2.copy( config.currentScreenSize, config.screenSize )
				}
			},

			/**
			 * Returns the configuration option specified by key.
			 *
			 * @param {String} key
			 * @return {String}
			 */
			getValue : function( key ) {
				return this.config[ key ]
			},

			/**
			 * Sets mutliple configuration options at once.
			 *
			 * @private
			 * @param {Object} x the configuration
			 */
			setConfig : function( x ) {
				for( var key in x ) {
					if( key === 'supportedLanguages' ||
						key === 'defaultLanguage' ||
						key === 'currentLanguage' ||
						key === 'quality' ||
						key === 'qualityLevels' ||
						key === 'currentQualityLevel' ||
						key === 'screenSize' ||
						key === 'screenAspectRatio' ||
						key === 'screenMode' ) {

						continue
					}

					this.setValue( key, x[ key ] )
				}

				// HACK: these configuration options have dependencies amongst each other and must therefore be processed in the right order
				if( x.supportedLanguages ) this.setValue( 'supportedLanguages', x.supportedLanguages )
				if( x.defaultLanguage ) this.setValue( 'defaultLanguage', x.defaultLanguage )
				if( x.currentLanguage ) this.setValue( 'currentLanguage', x.currentLanguage )

				if( x.qualityLevels ) this.setValue( 'qualityLevels', x.qualityLevels )
				if( x.quality ) this.setValue( 'quality', x.quality )

				if( x.screenSize ) this.setValue( 'screenSize', x.screenSize )
				if( x.screenAspectRatio ) this.setValue( 'screenAspectRatio', x.screenAspectRatio )
				if( x.screenMode ) this.setValue( 'screenMode', x.screenMode )

				if( !this.config.currentQualityLevel ) {
					this.setValue( 'currentQualityLevel', 1 )
				}
			}
		}

		return ConfigurationManager
	}
)

/**
 * The AssetManager provides access to asset instances.
 *
 * Example:
 *
 *     spell.audioContext.play(
 *         spell.assetManager.get( 'sound:myGame.creakyNoise' ).resource,
 *         'creakyNoise',
 *         0.7,
 *         false
 *     )
 *
 * @class spell.assetManager
 * @singleton
 */
define(
	'spell/AssetManager',
	function() {
		'use strict'


		var AssetManager = function( libraryManager ) {
			this.assets         = {},
			this.libraryManager = libraryManager
		}

		AssetManager.prototype = {
			/**
			 * Adds an asset.
			 *
			 * @param {String} id
			 * @param {String} asset
			 */
			add : function( id, asset ) {
				this.assets[ id ] = asset
			},

			/**
			 * Gets an asset by id.
			 *
			 * @param {String} id
			 * @return {Object}
			 */
			get : function( id ) {
				return this.assets[ id ]
			},

			/**
			 * Returns true if an asset with the specified id exists.
			 *
			 * @param {String} id
			 * @return {Boolean}
			 */
			has : function( id ) {
				return !!this.assets[ id ]
			},

			/**
			 * Returns the library ids of all assets which reference a specific resource id.
			 *
			 * @private
			 * @param {String} resourceId
			 * @return {Array}
			 */
			getLibraryIdByResourceId : function( resourceId ) {
				var assets = this.assets,
					ids = []

				for( var id in assets ) {
					var asset = assets[ id ]

					if( asset.resourceId &&
						asset.resourceId === resourceId ) {

						ids.push( id.slice( id.indexOf( ':' ) + 1 ) )
					}
				}

				return ids
			},

			/**
			 * Inject the provided resources into asset instances where applicable.
			 *
			 * @private
			 * @param {Object} resources
			 */
			injectResources : function( resources ) {
				if( !resources ) return

				var assets         = this.assets,
					libraryManager = this.libraryManager

				for( var id in assets ) {
					var asset     = assets[ id ],
						libraryId = asset.resourceId || id.substr( id.indexOf( ':' ) + 1, id.length )

					if( !resources[ libraryId ] ) {
						continue
					}

					var resource = libraryManager.getResource( libraryId ) || libraryManager.getMetaData( libraryId )

					if( resource ) {
						asset.resource = resource
					}
				}
			},

			/**
			 * Frees all asset instances.
			 *
			 * @private
			 */
			free : function() {
				this.assets = {}
			}
		}

		return AssetManager
	}
)

define(
	'spell/data/SortedMap',
	[
		'spell/shared/util/arrayRemove'
	],
	function(
		arrayRemove
	) {
		'use strict'


		var SortedMap = function() {
		    this.keys = []
		    this.values = []
		}

		SortedMap.prototype = {
		    add : function( key, value ) {
				var keys   = this.keys,
					values = this.values,
					index  = keys.indexOf( key )

				if( index === -1 ) {
					keys.push( key )
					values.push( value )

				} else {
					values[ index ] = value
				}

				return this
		    },
		    insert : function( key, value, index ) {
				var foundIndex = this.keys.indexOf( key )

				if( foundIndex !== -1 ) {
					this.removeByIndex( foundIndex )
				}

		        this.keys.splice( index, 0, key )
		        this.values.splice( index, 0, value )

				return this
		    },
			getByIndex : function( index ) {
				return this.values[ index ]
			},
			getByKey : function( key ) {
				return this.getByIndex( this.keys.indexOf( key ) )
			},
			hasKey : function( key ) {
				return this.keys.indexOf( key ) !== -1
			},
		    removeByIndex : function( index ) {
		        arrayRemove( this.keys, index )
				arrayRemove( this.values, index )

				return this
		    },
		    removeByKey : function( key ) {
		        this.removeByIndex( this.keys.indexOf( key ) )

				return this
		    },
		    each : function( iter ) {
		        var keys   = this.keys,
		            values = this.values

		        for( var i = 0, numKeys = keys.length; i < numKeys; i++ ) {
		            var key   = keys[ i ],
						value = values[ i ]

		            iter( value, key )
		        }

				return this
		    },
			clear : function() {
				this.keys.length = 0
				this.values.length = 0

				return this
			},
		    size : function() {
		        return this.keys.length
		    }
		}

		return SortedMap
	}
)

define(
	'spell/data/entity/flatten',
	[
		'spell/functions'
	],
	function(
		_
	) {
		'use strict'


		var flattenEntityConfig = function( entityConfigs ) {
			return _.reduce(
				entityConfigs,
				function( memo, entityConfig ) {
					memo.push( entityConfig )

					return _.has( entityConfig, 'children' ) ?
						memo.concat( flattenEntityConfig( entityConfig.children ) ) :
						memo
				},
				[]
			)
		}

		return function( arg0 ) {
			var entityConfigs = _.isArray( arg0 ) ? arg0 : [ arg0 ]

			return flattenEntityConfig( entityConfigs )
		}
	}
)

define(
	'spell/shared/util/scene/Scene',
	[
		'spell/Defines',
		'spell/data/entity/flatten',
		'spell/data/SortedMap',
		'spell/shared/util/create',
		'spell/shared/util/createId',
		'spell/shared/util/createLibraryFilePathFromId',
		'spell/shared/util/createLibraryFilePathsFromIds',
		'spell/shared/util/createModuleId',
		'spell/shared/util/deepClone',
		'spell/shared/util/StopWatch',
		'spell/shared/util/platform/PlatformKit',
		'spell/shared/util/platform/Types',

		'spell/functions'
	],
	function(
		Defines,
		flattenEntityConfig,
		SortedMap,
		create,
		createId,
		createLibraryFilePathFromId,
		createLibraryFilePathsFromIds,
		createModuleId,
		deepClone,
		StopWatch,
		PlatformKit,
		Types,

		_
	) {
		'use strict'


		var CAMERA_COMPONENT_ID = Defines.CAMERA_COMPONENT_ID

		var stopWatch = new StopWatch()

		/*
		 * TODO: Remove this custom invoke that knows how to handle the borked instances produced by the "create" constructor wrapper function.
		 * Instances created by "create" for some unknown reason do not support prototype chain method look-up. See "Fix create"
		 */
		var invoke = function( sortedMap, functionName, statisticsManager, activeSystemsOnly, args ) {
			var systems = sortedMap.values

			for( var i = 0, numSystems = systems.length; i < numSystems; i++ ) {
				stopWatch.start()

				var system = systems[ i ]

				if( !activeSystemsOnly || system.config.active ) {
					system.prototype[ functionName ].apply( system, args )
				}

				statisticsManager.updateNode( sortedMap.keys[ i ], stopWatch.stop() )
			}
		}

		var createSystem = function( spell, entityManager, systemId, system, isModeDevelopment, systemConfig ) {
			var attributes = _.reduce(
				system.input,
				function( memo, inputDefinition ) {
					var componentMap = entityManager.getComponentMapById( inputDefinition.componentId )

					if( !componentMap ) {
						throw 'Error: No component list for component template id \'' + inputDefinition.componentId +  '\' available.'
					}

					if( inputDefinition.name === 'config' ) {
						throw 'Error: The system \'' + systemId + '\' uses the reserved keyword \'config\' as a local alias for its input.'
					}

					memo[ inputDefinition.name ] = componentMap

					return memo
				},
				{
					config : systemConfig
				}
			)

			var constructor = spell.moduleLoader.require( createModuleId( systemId ) )

			// TODO: Fix create. Returned instances do not support prototype chain method look-up. O_o
			return create( constructor, [ spell ], attributes )
		}

		var createConfigFromSystemTemplateConfig = function( config ) {
			return _.reduce(
				config,
				function( memo, record ) {
					memo[ record[ 'name' ] ] = deepClone( record[ 'default' ] )

					return memo
				},
				{}
			)
		}

		var createSystems = function( spell, entityManager, libraryManager, systems, isModeDevelopment ) {
			return _.reduce(
				systems,
				function( memo, system ) {
					var systemId       = system.id,
						systemTemplate = libraryManager.get( systemId )

					if( !systemTemplate ) {
						throw 'Error: Could not get template for id \'' + systemId + '\'.'
					}

					return memo.add(
						systemId,
						createSystem(
							spell,
							entityManager,
							systemId,
							systemTemplate,
							isModeDevelopment,
							_.defaults(
								deepClone( system.config ),
								createConfigFromSystemTemplateConfig( systemTemplate.config )
							)
						)
					)
				},
				new SortedMap()
			)
		}

		var hasActiveCamera = function( sceneConfig ) {
			return true

			return _.any(
				flattenEntityConfig( sceneConfig.entities ),
				function( entityConfig ) {
					if( !entityConfig.config ) {

						return false
					}

					var cameraComponent = entityConfig.config[ CAMERA_COMPONENT_ID ]

					if( !cameraComponent ) return false

					return cameraComponent.active
				}
			)
		}

		var getExecutionGroupIdBySystemId = function( executionGroups, systemId ) {
			for( var executionGroupId in executionGroups ) {
				var executionGroup = executionGroups[ executionGroupId ]

				if( executionGroup.hasKey( systemId ) ) {
					return executionGroupId
				}
			}
		}

		var addStatisticsSeries = function( statisticsManager, systems, parentNodeId ) {
			for( var i = 0, numSystems = systems.length; i < numSystems; i++ ) {
				var system = systems[ i ]

				statisticsManager.addNode( system.id, parentNodeId )
			}
		}


		var Scene = function( spell, entityManager, libraryManager, statisticsManager, isModeDevelopment, sceneConfig, initialConfig ) {
			this.spell             = spell
			this.entityManager     = entityManager
			this.libraryManager    = libraryManager
			this.statisticsManager = statisticsManager
			this.isModeDevelopment = isModeDevelopment
			this.executionGroups   = { render : null, update : null }
			this.sceneConfig       = sceneConfig
			this.initialConfig     = initialConfig
			this.script            = null
		}

		Scene.prototype = {
			render: function( timeInMs, deltaTimeInMs ) {
				invoke( this.executionGroups.render, 'process', this.statisticsManager, true, [ this.spell, timeInMs, deltaTimeInMs ] )
			},
			update: function( timeInMs, deltaTimeInMs ) {
				invoke( this.executionGroups.update, 'process', this.statisticsManager, true, [ this.spell, timeInMs, deltaTimeInMs ] )
			},
			init: function() {
				var spell         = this.spell,
					sceneConfig   = this.sceneConfig,
					initialConfig = this.initialConfig

				this.statisticsManager.init()

				if( !hasActiveCamera( sceneConfig ) ) {
					spell.console.error( 'Could not start scene "' + sceneConfig.name + '" because no camera entity was found. A scene must have at least one active camera entity.' )

					return
				}

				var entityManager   = this.entityManager,
					libraryManager  = this.libraryManager,
					executionGroups = this.executionGroups

				entityManager.init()

				executionGroups.render = createSystems(
					spell,
					entityManager,
					libraryManager,
					sceneConfig.systems.render,
					this.isModeDevelopment
				)

				executionGroups.update = createSystems(
					spell,
					entityManager,
					libraryManager,
					sceneConfig.systems.update,
					this.isModeDevelopment
				)


				addStatisticsSeries( this.statisticsManager, sceneConfig.systems.render, 'render' )
				addStatisticsSeries( this.statisticsManager, sceneConfig.systems.update, 'update' )


				// initializing systems
				invoke( executionGroups.render, 'init', this.statisticsManager, false, [ spell, sceneConfig, initialConfig ] )
				invoke( executionGroups.update, 'init', this.statisticsManager, false, [ spell, sceneConfig, initialConfig ] )

				// creating entities from scene config
				entityManager.createEntities( sceneConfig.entities )

				// initializing scene
				var moduleId = createModuleId( createId( sceneConfig.namespace, sceneConfig.name ) )

				this.script = spell.moduleLoader.require( moduleId )
				this.script.init( spell, sceneConfig, initialConfig )

				// activating systems
				invoke( executionGroups.render, 'activate', this.statisticsManager, true, [ spell, sceneConfig, initialConfig ] )
				invoke( executionGroups.update, 'activate', this.statisticsManager, true, [ spell, sceneConfig, initialConfig ] )
			},
			destroy: function() {
				var executionGroups = this.executionGroups,
					spell           = this.spell,
					sceneConfig     = this.sceneConfig

				// deactivating systems
				invoke( executionGroups.render, 'deactivate', this.statisticsManager, true, [ spell, sceneConfig ] )
				invoke( executionGroups.update, 'deactivate', this.statisticsManager, true, [ spell, sceneConfig ] )

				// destroying scene
				this.script.destroy( this.spell, sceneConfig )

				// removing all entities
				this.entityManager.destroy()

				// destroying systems
				invoke( executionGroups.render, 'destroy', this.statisticsManager, false, [ spell, sceneConfig ] )
				invoke( executionGroups.update, 'destroy', this.statisticsManager, false, [ spell, sceneConfig ] )
			},
			restartSystem: function( systemId, executionGroupId, systemConfig ) {
				var executionGroups = this.executionGroups

				if( !executionGroupId ) {
					// figure out in which execution group the system is contained
					executionGroupId = getExecutionGroupIdBySystemId( executionGroups, systemId )
				}

				var executionGroup = executionGroups[ executionGroupId ]
				if( !executionGroup ) return

				var system = executionGroup.getByKey( systemId )
				if( !system ) return

				if( !systemConfig ) {
					// reusing the existing system config if none was provided
					systemConfig = system.config
				}

				// deactivating, destroying ye olde system
				var spell = this.spell

				if( system.config.active ) {
					system.prototype.deactivate.call( system, spell )
				}

				system.prototype.destroy.call( system, spell )

				// initializing and activating the new system instance
				var newSystem = createSystem(
					spell,
					this.entityManager,
					systemId,
					this.libraryManager.get( systemId ),
					this.isModeDevelopment,
					systemConfig
				)

				newSystem.prototype.init.call( newSystem, spell, this.sceneConfig, this.initialConfig )

				if( newSystem.config.active ) {
					newSystem.prototype.activate.call( newSystem, spell, this.sceneConfig, this.initialConfig )
				}

				executionGroup.add( systemId, newSystem )
			},
			addSystem: function( systemId, executionGroupId, index, systemConfig ) {
				var executionGroup = this.executionGroups[ executionGroupId ]
				if( !executionGroup ) return

				var spell             = this.spell,
					isModeDevelopment = this.isModeDevelopment,
					libraryManager    = this.libraryManager

				libraryManager.load(
					createLibraryFilePathsFromIds( [ systemId ] ),
					{
						assetManager : spell.assetManager
					},
					function() {
						var system = createSystem(
							spell,
							spell.entityManager,
							systemId,
							libraryManager.get( systemId ),
							isModeDevelopment,
							systemConfig
						)

						system.prototype.init.call( system, spell )

						if( system.config.active ) {
							system.prototype.activate.call( system, spell )
						}

						executionGroup.insert( systemId, system, index )
					}
				)
			},
			removeSystem: function( systemId, executionGroupId ) {
				var executionGroup = this.executionGroups[ executionGroupId ]
				if( !executionGroup ) return

				var spell  = this.spell,
					system = executionGroup.getByKey( systemId )

				if( system.config.active ) {
					system.prototype.deactivate.call( system, spell )
				}
				system.prototype.destroy.call( system, spell )

				executionGroup.removeByKey( systemId )
			},
			moveSystem: function( systemId, srcExecutionGroupId, dstExecutionGroupId, dstIndex ) {
				var srcExecutionGroup = this.executionGroups[ srcExecutionGroupId ],
					dstExecutionGroup = this.executionGroups[ dstExecutionGroupId ]

				if( !srcExecutionGroup || !dstExecutionGroup ) return

				var system = srcExecutionGroup.getByKey( systemId )
				if( !system ) return

				srcExecutionGroup.removeByKey( systemId )
				dstExecutionGroup.insert( systemId, system, dstIndex )
			},
			updateSystem: function( systemId, executionGroupId, systemConfig ) {
				if( !systemConfig ) return

				var executionGroups = this.executionGroups

				if( !executionGroupId ) {
					// figure out in which execution group the system is contained
					executionGroupId = getExecutionGroupIdBySystemId( executionGroups, systemId )
				}

				var executionGroup = executionGroups[ executionGroupId ]
				if( !executionGroup ) return

				var system = executionGroup.getByKey( systemId )
				if( !system ) return

				var changedActive = systemConfig.active !== undefined &&
					system.config !== systemConfig.active

				_.extend(
					system.config,
					deepClone( systemConfig )
				)

				if( changedActive ) {
					if( systemConfig.active ) {
						system.prototype.activate.call( system, this.spell, this.sceneConfig, this.initialConfig )

					} else {
						system.prototype.deactivate.call( system, this.spell, this.sceneConfig )
					}
				}
			}
		}

		return Scene
	}
)

define(
	'spell/shared/util/createLibraryFilePathsFromIds',
	[
		'spell/shared/util/createLibraryFilePathFromId',

		'spell/functions'
	],
	function(
		createLibraryFilePathFromId,

		_
	) {
		'use strict'


		return function( libraryIds ) {
			return _.reduce(
				libraryIds,
				function( memo, libraryId ) {
					memo[ libraryId ] = createLibraryFilePathFromId( libraryId )

					return memo
				},
				{}
			)
		}
	}
)

define(
	'spell/client/loading/loadSceneResources',
	[
		'spell/client/util/updateAssets',
		'spell/client/loading/addNamespaceAndName',
		'spell/client/loading/createFilesToLoad',
		'spell/shared/util/createLibraryFilePathsFromIds',
		'spell/math/util',
		'spell/shared/util/createId',
		'spell/shared/util/platform/PlatformKit',

		'spell/functions'
	],
	function(
		updateAssets,
		addNamespaceAndName,
		createFilesToLoad,
		createLibraryFilePathsFromIds,
		mathUtil,
		createId,
		PlatformKit,

		_
	) {
		'use strict'


		var groupByType = function( libraryRecords ) {
			return _.reduce(
				libraryRecords,
				function( memo, value, libraryId ) {
					var type = value.type

					if( !memo[ type ] ) {
						memo[ type ] = {}
					}

					memo[ type ][ libraryId ] = value

					return memo
				},
				{}
			)
		}

		var addIdAsKey = function( result, libraryRecords ) {
			for( var id in libraryRecords ) {
				var libraryRecord = libraryRecords[ id ]

				result[ createId( libraryRecord.namespace, libraryRecord.name ) ] = libraryRecord
			}
		}

		var createLoadingProgress = function( eventManager, progressCallback ) {
			if( !progressCallback ) progressCallback = function() {}

			var LoadingProgress = function( eventManager, progressCallback ) {
				this.bundles          = {}
				this.eventManager     = eventManager
				this.progressCallback = progressCallback
				this.progress         = 0
				this.lastSendProgress = 0
				this.progressHandler  = function( portion, progress, numCompleted, numTotal ) {
					this.progress += portion / numTotal

					var currentProgress = mathUtil.roundToResolution( this.progress, 0.01 )

					if( currentProgress <= this.lastSendProgress ) return

					this.lastSendProgress = currentProgress
					this.progressCallback( currentProgress )
				}
			}

			LoadingProgress.prototype = {
				addBundle : function( name, portion ) {
					var eventManager = this.eventManager

					// the loading interval is [ 0, 0.99 ], call "complete" to signal progress of 1
					var handler = _.bind( this.progressHandler, this, portion * 0.99 )

					this.bundles[ name ] = handler

					eventManager.subscribe( [ eventManager.EVENT.RESOURCE_PROGRESS, name ], handler )
				},
				complete : function() {
					this.progressCallback( 1 )
				},
				destroy : function() {
					var bundles      = this.bundles,
						eventManager = this.eventManager

					for( var name in bundles ) {
						var handler = bundles[ name ]

						eventManager.unsubscribe( [ eventManager.EVENT.RESOURCE_PROGRESS, name ], handler )
					}
				}
			}

			return new LoadingProgress( eventManager, progressCallback )
		}


		return function( spell, sceneId, next, progressCallback ) {
			var assetManager         = spell.assetManager,
				configurationManager = spell.configurationManager,
				eventManager         = spell.eventManager,
				EVENT                = eventManager.EVENT,
				libraryManager       = spell.libraryManager,
				resources            = spell.resources,
				entityManager        = spell.entityManager

			var libraryBundleName  = sceneId + '-library',
				resourceBundleName = sceneId + '-resources'

			var loadingProgress = createLoadingProgress( eventManager, progressCallback )

			loadingProgress.addBundle( sceneId, 0.1 )
			loadingProgress.addBundle( libraryBundleName, 0.1 )
			loadingProgress.addBundle( resourceBundleName, 0.8 )


			eventManager.waitFor(
				[ EVENT.RESOURCE_LOADING_COMPLETED, sceneId ],
				function( loadedRecords ) {
					addIdAsKey( spell.scenes, loadedRecords )
				}

			).resume( function() {
				eventManager.waitFor(
					[ EVENT.RESOURCE_LOADING_COMPLETED, libraryBundleName ],
					function( loadedRecords ) {
						var library = groupByType( loadedRecords )

						updateAssets( assetManager, library.asset )

						libraryManager.load(
							createFilesToLoad( configurationManager, library.asset ),
							{
								assetManager : spell.assetManager,
								name : resourceBundleName,
								isMetaDataLoad : false
							}
						)

						_.each(
							library.component,
							_.bind( entityManager.registerComponent, entityManager )
						)

						addIdAsKey( spell.scenes, library.scene )
					}

				).and(
					[ EVENT.RESOURCE_LOADING_COMPLETED, resourceBundleName ],
					_.bind( assetManager.injectResources, assetManager )

				).resume( function() {
					loadingProgress.complete()
					loadingProgress.destroy()

					eventManager.unsubscribeAll( [ EVENT.RESOURCE_LOADING_COMPLETED, sceneId ] )
					eventManager.unsubscribeAll( [ EVENT.RESOURCE_LOADING_COMPLETED, libraryBundleName ] )
					eventManager.unsubscribeAll( [ EVENT.RESOURCE_LOADING_COMPLETED, resourceBundleName ] )

					next()
				} )

				// start loading the required library records
				var scene = spell.scenes[ sceneId ]

				libraryManager.load(
					createLibraryFilePathsFromIds( scene.libraryIds ),
					{
						assetManager : spell.assetManager,
						name : libraryBundleName
					}
				)
			} )

			// load scene library record
			libraryManager.load(
				createLibraryFilePathsFromIds( [ sceneId ] ),
				{
					assetManager : spell.assetManager,
					name : sceneId
				}
			)
		}
	}
)

/**
 * The SceneManager enables controlling of the currently executed scene.
 *
 * @class spell.sceneManager
 * @singleton
 */
define(
	'spell/SceneManager',
	[
		'spell/client/loading/loadSceneResources',
		'spell/shared/util/scene/Scene',

		'spell/functions'
	],
	function(
		loadSceneResources,
		Scene,

		_
	) {
		'use strict'


		var update = function( entityManager, scene, timeInMs, deltaTimeInMs ) {
			entityManager.updateDeferredEvents( deltaTimeInMs )
			scene.update( timeInMs, deltaTimeInMs )
		}

		var postLoadedResources = function( spell, entityManager, libraryManager, statisticsManager, isModeDevelopment, sceneId, initialConfig ) {
			var sceneConfig = spell.scenes[ sceneId ]

			if( !sceneConfig ) {
				throw 'Error: Could not find scene configuration for scene "' + sceneId + '".'
			}

			var scene = new Scene( spell, entityManager, libraryManager, statisticsManager, isModeDevelopment, sceneConfig, initialConfig )

			scene.init()

			this.mainLoop.setRenderCallback( _.bind( scene.render, scene ) )
			this.mainLoop.setUpdateCallback( _.bind( update, null, entityManager, scene ) )

			this.activeScene = scene

			this.loadingPending = false
			this.processCmdQueue()

			if( this.sendMessageToEditor ) {
				this.sendMessageToEditor( 'spelled.debug.application.sceneStarted', sceneId )
			}
		}

		var startScene = function( targetSceneId, initialConfig, showLoadingScene ) {
			var freeMemory = showLoadingScene

			var preNextFrameCallback = function() {
				var spell = this.spell

				if( this.activeScene ) {
					this.mainLoop.setRenderCallback()
					this.mainLoop.setUpdateCallback()
					this.activeScene.destroy()
					this.activeScene = undefined

					if( freeMemory &&
						!spell.configurationManager.getValue( 'platform.hasPlentyRAM' ) ) {

						spell.assetManager.free()
						spell.libraryManager.free()
					}

					spell.statisticsManager.reset()
				}

				var onProgress = this.sendMessageToEditor ?
					_.bind( this.sendMessageToEditor, null, 'spelled.loadingProgress' ) :
					undefined

				this.cmdQueue = []
				this.loadingPending = true


				// check if library dependencies of next scene are already available
				var nextScene = spell.scenes[ targetSceneId ]

				if( nextScene &&
					spell.libraryManager.isAvailable( nextScene.libraryIds ) ) {

					// perform direct transition
					postLoadedResources.call(
						this,
						spell,
						this.entityManager,
						this.libraryManager,
						this.statisticsManager,
						this.isModeDevelopment,
						targetSceneId,
						initialConfig
					)

				} else {
					var loadingSceneId = spell.configurationManager.getValue( 'loadingScene' )

					if( showLoadingScene &&
						loadingSceneId ) {

						loadSceneResources(
							spell,
							loadingSceneId,
							_.bind(
								postLoadedResources,
								this,
								spell,
								this.entityManager,
								this.libraryManager,
								this.statisticsManager,
								this.isModeDevelopment,
								loadingSceneId,
								{
									targetSceneId : targetSceneId,
									initialConfig : initialConfig
								}
							),
							onProgress
						)

					} else {
						// load library dependencies first
						loadSceneResources(
							spell,
							targetSceneId,
							_.bind(
								postLoadedResources,
								this,
								spell,
								this.entityManager,
								this.libraryManager,
								this.statisticsManager,
								this.isModeDevelopment,
								targetSceneId,
								initialConfig
							),
							onProgress
						)
					}
				}
			}

			this.mainLoop.setPreNextFrame( _.bind( preNextFrameCallback, this ) )
		}

		var SceneManager = function( spell, entityManager, statisticsManager, libraryManager, mainLoop, sendMessageToEditor, isModeDevelopment ) {
			this.activeScene
			this.entityManager       = entityManager
			this.mainLoop            = mainLoop
			this.sendMessageToEditor = sendMessageToEditor
			this.spell               = spell
			this.statisticsManager   = statisticsManager
			this.libraryManager      = libraryManager
			this.isModeDevelopment   = isModeDevelopment
			this.cmdQueue            = []
			this.loadingPending      = false
		}

		SceneManager.prototype = {
			/**
			 * Changes the currently executed scene to the scene specified by targetSceneId.
			 *
			 * @param {String} targetSceneId the library id of the scene to which to change
			 * @param {Object} initialConfig configuration passed to the target scene
			 * @param {Boolean} showLoadingScene if true the loading scene is displayed
			 */
			changeScene : function( targetSceneId, initialConfig, showLoadingScene ) {
				showLoadingScene = showLoadingScene || false

				if( !this.isModeDevelopment ) {
					startScene.call( this, targetSceneId, initialConfig, showLoadingScene )

				} else {
					this.spell.sendMessageToEditor(
						'spelled.debug.application.startScene',
						{
							targetSceneId : targetSceneId,
							initialConfig : initialConfig,
							showLoadingScene : showLoadingScene
						}
					)
				}
			},

			startScene : startScene,

			processCmdQueue : function() {
				if( this.loadingPending ) {
					return
				}

				var cmdQueue = this.cmdQueue

				for( var i = 0; i < cmdQueue.length; i++ ) {
					var cmd = cmdQueue[ i ]

					this.activeScene[ cmd.fn ].apply( this.activeScene, cmd.args )
				}

				cmdQueue.length = 0
			},

			addSystem : function( systemId, executionGroupId, index, systemConfig ) {
				this.cmdQueue.push( {
					fn   : 'addSystem',
					args : [ systemId, executionGroupId, index, systemConfig ]
				} )

				this.processCmdQueue()
			},

			moveSystem : function( systemId, srcExecutionGroupId, dstExecutionGroupId, dstIndex ) {
				this.cmdQueue.push( {
					fn   : 'moveSystem',
					args : [ systemId, srcExecutionGroupId, dstExecutionGroupId, dstIndex ]
				} )

				this.processCmdQueue()
			},

			removeSystem : function( systemId, executionGroupId ) {
				this.cmdQueue.push( {
					fn   : 'removeSystem',
					args : [ systemId, executionGroupId ]
				} )

				this.processCmdQueue()
			},

			restartSystem : function( systemId, executionGroupId, systemConfig ) {
				this.cmdQueue.push( {
					fn   : 'restartSystem',
					args : [ systemId, executionGroupId, systemConfig ]
				} )

				this.processCmdQueue()
			},

			updateSystem : function( systemId, executionGroupId, systemConfig ) {
				this.cmdQueue.push( {
					fn   : 'updateSystem',
					args : [ systemId, executionGroupId, systemConfig ]
				} )

				this.processCmdQueue()
			}
		}

		return SceneManager
	}
)

define(
	'spell/data/component/init',
	[
		'spell/functions'
	],
	function(
		_
	) {
		'use strict'


		return function( componentInstance, componentDefinition ) {
			var attributes = componentDefinition.attributes

			for( var i = 0, n = attributes.length, attributeConfig; i < n; i++ ) {
				attributeConfig = attributes[ i ]

				componentInstance[ attributeConfig.name ] = _.clone( attributeConfig[ 'default' ] )
			}

			return componentInstance
		}
	}
)

define(
	'spell/data/entity/applyEntityConfig',
	[
		'spell/shared/util/deepClone',

		'spell/functions'
	],
	function(
		deepClone,

		_
	) {
		'use strict'


		/**
		 * Applies a an entity configuration to an entity and returns the updated entity. Attribute instances are copied by reference.
		 *
		 * @param entity
		 * @param entityConfig
		 * @return {*}
		 */
		var applyEntityConfig = function( entity, entityConfig ) {
			for( var componentId in entityConfig ) {
				entity[ componentId ] = _.extend(
					entity[ componentId ] || {},
					deepClone( entityConfig[ componentId ] )
				)
			}

			return entity
		}

		return applyEntityConfig
	}
)

define(
	'spell/shared/util/deepClone',
	[
		'spell/functions'
	],
	function(
		_
	) {
		'use strict'


		return function deepClone( o ) {
			var isArray = _.isArray( o )

			if( isArray ||
				_.isObject( o ) ) {

				var clone = isArray ? [] : {}

				_.each( o, function( value, key ) {
					clone[ key ] = deepClone( value )
				} )

				return clone

			} else {
				return o
			}
		}
	}
)

define(
	'spell/shared/util/create',
	[
		'spell/functions'
	],
	function(
		_
	) {
		'use strict'


		var NO_CONSTRUCTOR_ERROR = 'The first argument for create must be a constructor. You passed in '


		/*
		 * public
		 */

		// TODO: Fix the issue that instances which where created with "create" do not support method look-up along the prototype chain.
		return function( constructor, constructorArguments, propertiesToInject ) {
			if ( constructor.prototype === undefined ) {
				throw NO_CONSTRUCTOR_ERROR + constructor
			}

			var object = {}

			if( !!propertiesToInject && _.isObject( propertiesToInject ) ) {
				_.extend( object, propertiesToInject )
			}

			object.prototype = constructor.prototype
			var returnedObject = constructor.apply( object, constructorArguments )
			return returnedObject || object
		}
	}
)

define(
	'spell/shared/util/arrayRemove',
	function() {
		'use strict'


		// Array Remove - By John Resig (MIT Licensed)
		return function( array, from, to ) {
			var rest = array.slice( ( to || from ) + 1 || array.length )

			array.length = from < 0 ? array.length + from : from

			return array.push.apply( array, rest )
		}
	}
)

define(
	'spell/Defines',
	function() {
		'use strict'


		return {
			INVALID_ENTITY_ID                         : '',
			ROOT_ENTITY_ID                            : '0',
			COMPOSITE_COMPONENT_ID                    : 'spell.component.composite',
			METADATA_COMPONENT_ID                     : 'spell.component.metaData',
			EVENT_HANDLERS_COMPONENT_ID               : 'spell.component.eventHandlers',
			TRANSFORM_COMPONENT_ID                    : 'spell.component.2d.transform',
			TEXTURE_MATRIX_COMPONENT_ID               : 'spell.component.2d.graphics.textureMatrix',
			CAMERA_COMPONENT_ID                       : 'spell.component.2d.graphics.camera',
			CAMERA_MOVEMENT_COMPONENT_ID              : 'spell.component.2d.graphics.cameraMovement',
			STATIC_APPEARANCE_COMPONENT_ID            : 'spell.component.2d.graphics.appearance',
			TEXT_APPEARANCE_COMPONENT_ID              : 'spell.component.2d.graphics.textAppearance',
			ANIMATED_APPEARANCE_COMPONENT_ID          : 'spell.component.2d.graphics.animatedAppearance',
			QUAD_GEOMETRY_COMPONENT_ID                : 'spell.component.2d.graphics.geometry.quad',
			TILEMAP_COMPONENT_ID                      : 'spell.component.2d.graphics.tilemap',
			PARALLAX_COMPONENT_ID                     : 'spell.component.2d.graphics.parallax',
			PHYSICS_BODY_COMPONENT_ID                 : 'spell.component.physics.body',
			PHYSICS_FIXTURE_COMPONENT_ID              : 'spell.component.physics.fixture',
			PHYSICS_BOX_SHAPE_COMPONENT_ID            : 'spell.component.physics.shape.box',
			PHYSICS_CIRCLE_SHAPE_COMPONENT_ID         : 'spell.component.physics.shape.circle',
			PHYSICS_CONVEX_POLYGON_SHAPE_COMPONENT_ID : 'spell.component.physics.shape.convexPolygon',
			PHYSICS_JNRPLAYER_SHAPE_COMPONENT_ID      : 'spell.component.physics.shape.jumpAndRunPlayer',
			KEY_FRAME_ANIMATION_COMPONENT_ID          : 'spell.component.animation.keyFrameAnimation',
			SOUND_EMITTER_COMPONENT_ID                : 'spell.component.audio.soundEmitter',
			VISUAL_OBJECT_COMPONENT_ID                : 'spell.component.visualObject',
			CONTROLLABLE_COMPONENT_ID                 : 'spell.component.controllable'
		}
	}
)

define(
	'spell/data/entity/recursiveFind',
	[
		'spell/functions'
	],
	function(
		_
	) {
		'use strict'


		var find = function( entityConfigs, iterator ) {
			var numEntityConfigs = entityConfigs.length,
				result

			for( var i = 0; i < numEntityConfigs; i++ ) {
				var entityConfig = entityConfigs[ i ]

				result = iterator( entityConfig )

				if( result ) {
					return result
				}

				var children = entityConfig.children

				if( children &&
					children.length > 0 ) {

					return find( children, iterator )
				}
			}
		}

		return function( arg0, iterator ) {
			var entityConfigs = _.isArray( arg0 ) ? arg0 : [ arg0 ]

			return find( entityConfigs, iterator )
		}
	}
)

define(
	'spell/data/entity/createAmbiguousSiblingName',
	function() {
		'use strict'


		return function( entityConfig ) {
			var children = entityConfig.children
			if( !children ) return false

			var names = {}

			for( var i = 0, n = children.length; i < n; i++ ) {
				var name = children[ i ].name

				if( name ) {
					if( !names[ name ] ) {
						names[ name ] = true

					} else {
						return name
					}
				}
			}

			return false
		}
	}
)

define(
	'spell/data/LinkedList',
	function() {
		'use strict'


		var Node = function() {
			this.data = undefined
			this.previous = undefined
			this.next = undefined
		}

		var Iterator = function( linkedList ) {
			this.linkedList = linkedList
			this.currentNode = linkedList.firstNode
		}

		Iterator.prototype = {
			next : function() {
				var node = this.currentNode
				if( !node ) return

				this.currentNode = node.next

				return node
			},
			remove : function() {
				var linkedList  = this.linkedList,
					currentNode = this.currentNode,
					removeNode  = currentNode ? currentNode.previous : linkedList.lastNode

				if( !removeNode ) return

				var previousNode = removeNode.previous,
					nextNode     = removeNode.next

				if( previousNode ) {
					previousNode.next = nextNode

				} else {
					linkedList.firstNode = nextNode
				}

				if( nextNode ) {
					nextNode.previous = previousNode

				} else {
					linkedList.lastNode = previousNode
				}

				this.currentNode = currentNode ?
					previousNode || nextNode :
					undefined

				linkedList.size--
			}
		}

		var LinkedList = function() {
			this.firstNode = undefined
			this.lastNode = undefined
			this.size = 0
		}

		LinkedList.prototype = {
			append : function( x ) {
				var node = new Node()

				node.data = x

				if( !this.firstNode ) {
					this.firstNode = node

				} else {
					this.lastNode.next = node
					node.previous = this.lastNode
				}

				this.lastNode = node
				this.size++
			},
			clear : function() {
				this.firstNode = undefined
				this.lastNode = undefined
				this.size = 0
			},
			createIterator : function() {
				return new Iterator( this )
			}
		}

		return LinkedList
	}
)

/**
 * The EntityManager offers methods for creating, updating and destroying entities as well as for querying and updating components and component attributes.
 *
 * @class spell.entityManager
 * @singleton
 */
define(
	'spell/EntityManager',
	[
		'spell/data/LinkedList',
		'spell/data/entity/createAmbiguousSiblingName',
		'spell/data/entity/recursiveFind',
		'spell/data/spatial/QuadTree',
		'spell/Defines',
		'spell/shared/util/arrayRemove',
		'spell/shared/util/create',
		'spell/shared/util/createId',
		'spell/shared/util/createModuleId',
		'spell/shared/util/deepClone',
		'spell/data/entity/applyEntityConfig',
		'spell/stringUtil',
		'spell/shared/util/platform/PlatformKit',
		'spell/data/component/init',

		'spell/math/util',
		'spell/math/mat3',
		'spell/math/vec2',

		'spell/functions'
	],
	function(
		LinkedList,
		createAmbiguousSiblingName,
		recursiveFind,
		QuadTree,
		Defines,
		arrayRemove,
		create,
		createId,
		createModuleId,
		deepClone,
		applyEntityConfig,
		stringUtil,
		PlatformKit,
		initComponent,

		mathUtil,
		mat3,
		vec2,

		_
	) {
		'use strict'


		var nextEntityId                     = 1,
			createComponentType              = PlatformKit.createComponentType,
			INVALID_ENTITY_ID                = Defines.INVALID_ENTITY_ID,
			ROOT_ENTITY_ID                   = Defines.ROOT_ENTITY_ID,
			COMPOSITE_COMPONENT_ID           = Defines.COMPOSITE_COMPONENT_ID,
			METADATA_COMPONENT_ID            = Defines.METADATA_COMPONENT_ID,
			TRANSFORM_COMPONENT_ID           = Defines.TRANSFORM_COMPONENT_ID,
			TEXTURE_MATRIX_COMPONENT_ID      = Defines.TEXTURE_MATRIX_COMPONENT_ID,
			EVENT_HANDLERS_COMPONENT_ID      = Defines.EVENT_HANDLERS_COMPONENT_ID,
			STATIC_APPEARANCE_COMPONENT_ID   = Defines.STATIC_APPEARANCE_COMPONENT_ID,
			ANIMATED_APPEARANCE_COMPONENT_ID = Defines.ANIMATED_APPEARANCE_COMPONENT_ID,
			QUAD_GEOMETRY_COMPONENT_ID       = Defines.QUAD_GEOMETRY_COMPONENT_ID,
			TILEMAP_COMPONENT_ID             = Defines.TILEMAP_COMPONENT_ID,
			VISUAL_OBJECT_COMPONENT_ID       = Defines.VISUAL_OBJECT_COMPONENT_ID

		var DeferredEvent = function( entityId, eventId, eventArguments, timerInMs, timerCondition ) {
			this.entityId       = entityId
			this.eventId        = eventId
			this.eventArguments = eventArguments
			this.timerInMs      = timerInMs
			this.timerCondition = timerCondition
		}

		DeferredEvent.prototype = {
			trigger : function( entityManager ) {
				entityManager.triggerEvent( this.entityId, this.eventId, this.eventArguments )
			},
			ready : function( deltaTimeInMs ) {
				var timerCondition = this.timerCondition

				if( timerCondition && !timerCondition() ) {
					return false
				}

				return ( this.timerInMs -= deltaTimeInMs ) <= 0
			}
		}

		var isValidComponentDefinition = function( template ) {
			// check for ambiguous attribute names
			var attributeNameCounts = _.reduce(
				template.attributes,
				function( memo, attributeConfig ) {
					var attributeName = attributeConfig.name

					memo[ attributeName ] = memo[ attributeName ] ?
						memo[ attributeName ] + 1 :
						1

					return memo
				},
				{}
			)

			return !_.any(
				attributeNameCounts,
				function( iter ) { return iter > 1 }
			)
		}

		/**
		 * Returns an entity id. If no entity id is provided a new one is generated.
		 *
		 * @private
		 * @param {Object} id
		 * @return {*}
		 */
		var getEntityId = function( id ) {
			if( !id ) {
				return '' + nextEntityId++
			}

			var number = parseInt( id )

			if( _.isNaN( number ) ) return id

			nextEntityId = Math.max( number + 1, nextEntityId )

			return '' + number
		}

		/**
		 * Returns the id of the nearest ancestor entity which has a specific component instance.
		 *
		 * @param compositeComponents
		 * @param components component map of the requested component type
		 * @param entityId the search begins at the entity with this id
		 * @return {*}
		 */
		var getAncestorId = function( compositeComponents, components, entityId ) {
			var compositeComponent

			while( entityId !== INVALID_ENTITY_ID ) {
				compositeComponent = compositeComponents[ entityId ]
				if( !compositeComponent ) return

				entityId = compositeComponent.parentId

				if( components[ entityId ] ) {
					return entityId
				}
			}
		}

		/**
		 * Returns the next available component from the path in the entity composite tree that spans from the current entity to the root entity.
		 *
		 * @param compositeComponents
		 * @param components
		 * @param entityId
		 * @param includeCurrentEntity
		 * @return {Object}
		 */
		var getNearestComponent = function( compositeComponents, components, entityId, includeCurrentEntity ) {
			var currentComponent

			if( includeCurrentEntity ) {
				currentComponent = components[ entityId ]

				if( currentComponent ) {
					return currentComponent
				}
			}

			while( entityId !== INVALID_ENTITY_ID ) {
				entityId = compositeComponents[ entityId ].parentId

				currentComponent = components[ entityId ]

				if( currentComponent ) {
					return currentComponent
				}
			}
		}

		/**
		 * Updates the world transformation from a local transformation
		 *
		 * @private
		 * @param componentMaps
		 * @param entityId
		 * @return {*}
		 */
		var updateWorldTransform = function( componentMaps, eventManager, spatialIndex, syncSpatialIndex, entityId ) {
			var transformComponents = componentMaps[ TRANSFORM_COMPONENT_ID ],
				transform           = transformComponents[ entityId ]

			if( transform ) {
				var localMatrix = transform.localMatrix,
					worldMatrix = transform.worldMatrix

				// set new localToWorldMatrix
				mat3.identity( localMatrix )
				mat3.translate( localMatrix, localMatrix, transform.translation )
				mat3.rotate( localMatrix, localMatrix, transform.rotation )
				mat3.scale( localMatrix, localMatrix, transform.scale )

				// get nearest ancestor with a transform component
				var ancestorTransform = getNearestComponent( componentMaps[ COMPOSITE_COMPONENT_ID ], transformComponents, entityId, false )

				if( ancestorTransform ) {
					// multiply parent's localToWorldMatrix with ours
					mat3.multiply( worldMatrix, ancestorTransform.worldMatrix, localMatrix )

				} else {
					// if this entity has no parent, the localToWorld Matrix equals the localMatrix
					mat3.copy( worldMatrix, localMatrix )
				}

				transform.worldTranslation[ 0 ] = worldMatrix[ 6 ]
				transform.worldTranslation[ 1 ] = worldMatrix[ 7 ]

				if( syncSpatialIndex ) {
					updateSpatialIndex( componentMaps, spatialIndex, entityId )
				}
			}

			// update the children
			var compositeComponents = componentMaps[ COMPOSITE_COMPONENT_ID ],
				childrenIds         = compositeComponents[ entityId ].childrenIds

			for( var i = 0, n = childrenIds.length; i < n; i++ ) {
				updateWorldTransform( componentMaps, eventManager, spatialIndex, syncSpatialIndex, childrenIds[ i ] )
			}
		}

		var updateTextureMatrix = function( textureMatrix ) {
			var matrix      = textureMatrix.matrix,
				translation = textureMatrix.translation,
				scale       = textureMatrix.scale

			mat3.identity( matrix )
			mat3.translate( matrix, matrix, translation )
			mat3.scale( matrix, matrix, scale )

			textureMatrix.isIdentity = (
				translation[ 0 ] === 0 &&
				translation[ 1 ] === 0 &&
				scale[ 0 ] === 1 &&
				scale[ 1 ] === 1
			)
		}

		var updateVisualObjectR = function( compositeComponents, visualObjectComponents, entityId, ancestorWorldOpacity ) {
			var visualObjectComponent = visualObjectComponents[ entityId ],
				worldOpacity          = ancestorWorldOpacity

			if( visualObjectComponent ) {
				visualObjectComponent.worldOpacity = worldOpacity *= visualObjectComponent.opacity
			}

			var childrenIds = compositeComponents[ entityId ].childrenIds

			for( var i = 0, n = childrenIds.length; i < n; i++ ) {
				updateVisualObjectR( compositeComponents, visualObjectComponents, childrenIds[ i ], worldOpacity )
			}
		}

		var updateVisualObject = function( componentMaps, entityId ) {
			var compositeComponents  = componentMaps[ COMPOSITE_COMPONENT_ID ],
				visualObjects        = componentMaps[ VISUAL_OBJECT_COMPONENT_ID ],
				ancestorVisualObject = getNearestComponent( compositeComponents, visualObjects, entityId, false )

			updateVisualObjectR(
				compositeComponents,
				visualObjects,
				entityId,
				ancestorVisualObject ? ancestorVisualObject.worldOpacity : 1.0
			)
		}

		var addComponents = function( componentMaps, eventManager, spatialIndex, entityId, entityComponents ) {
			for( var componentId in entityComponents ) {
				var components = componentMaps[ componentId ]

				if( components[ entityId ] ) {
					throw 'Error: Adding a component to the entity with id "' + entityId + '" failed because the entity already has a component named "' + componentId + '". Check with hasComponent first if this entity already has this component.'
				}

				var component = components[ entityId ] = entityComponents[ componentId ]

				if( componentId === COMPOSITE_COMPONENT_ID ) {
					addToParentEntity( components, entityId, component.parentId )

				} else if( componentId === TEXTURE_MATRIX_COMPONENT_ID ) {
					updateTextureMatrix( component )

				} else if( componentId === TRANSFORM_COMPONENT_ID ) {
					updateWorldTransform( componentMaps, eventManager, spatialIndex, true, entityId )

				} else if( componentId === VISUAL_OBJECT_COMPONENT_ID ) {
					updateSpatialIndex( componentMaps, spatialIndex, entityId )
					updateVisualObject( componentMaps, entityId )
				}

				eventManager.publish(
					[ eventManager.EVENT.COMPONENT_CREATED, componentId ],
					[ component, entityId ]
				)
			}
		}

		var entityExists = function( componentMaps, entityId ) {
			for( var componentId in componentMaps ) {
				var componentMap = componentMaps[ componentId ]

				if( componentMap[ entityId ] ) return true
			}

			return false
		}

		/**
		 * Removes the specified component from the entity.
		 *
		 * @param eventManager
		 * @param componentMaps
		 * @param spatialIndex
		 * @param componentId
		 * @param entityId
		 * @return
		 */
		var removeComponent = function( eventManager, componentMaps, spatialIndex, componentId, entityId ) {
			var components = componentMaps[ componentId ],
				component  = components[ entityId ]

			if( !component ) return

			delete components[ entityId ]

			if( componentId === COMPOSITE_COMPONENT_ID ) {
				removeFromParentEntity( components, entityId, component.parentId )

			} else if( componentId === TRANSFORM_COMPONENT_ID ) {
				updateWorldTransform( componentMaps, eventManager, spatialIndex, true, entityId )

			} else if( componentId === VISUAL_OBJECT_COMPONENT_ID ) {
				spatialIndex.remove( entityId )
				updateVisualObject( componentMaps, entityId )
			}

			eventManager.publish( [ eventManager.EVENT.COMPONENT_REMOVED, componentId ], entityId )
		}

		var removeEntity = function( eventManager, componentMaps, spatialIndex, entityId ) {
			var compositeComponent = componentMaps[ COMPOSITE_COMPONENT_ID ][ entityId ]
			if( !compositeComponent ) return

			var childrenIds = compositeComponent.childrenIds

			while( childrenIds.length > 0 ) {
				removeEntity( eventManager, componentMaps, spatialIndex, childrenIds[ 0 ] )
			}

			// remove all components, that is "remove the entity"
			// TODO: use some kind of ordered map here, the current approach is bad
			for( var componentId in componentMaps ) {
				if( componentId === COMPOSITE_COMPONENT_ID ) continue

				removeComponent( eventManager, componentMaps, spatialIndex, componentId, entityId )
			}

			removeComponent( eventManager, componentMaps, spatialIndex, COMPOSITE_COMPONENT_ID, entityId )

			eventManager.publish( eventManager.EVENT.ENTITY_REMOVED, entityId )
		}

		/**
		 * Applies the overloaded children config to the children config defined in a template.
		 *
		 * @private
		 * @param entityTemplateChildrenConfig
		 * @param overloadedChildrenConfig
		 * @return {*}
		 */
		var applyOverloadedChildrenConfig = function( entityTemplateChildrenConfig, overloadedChildrenConfig ) {
			return _.reduce(
				overloadedChildrenConfig,
				function( memo, overloadedChildConfig ) {
					var entityTemplateChildConfig = _.find(
						memo,
						function( entityTemplateChildConfig ) {
							return overloadedChildConfig.name === entityTemplateChildConfig.name
						}
					)

					if( entityTemplateChildConfig ) {
						entityTemplateChildConfig.children = mergeOverloadedChildren( entityTemplateChildConfig.children, overloadedChildConfig.children )
						entityTemplateChildConfig.id       = overloadedChildConfig.id

						if( !entityTemplateChildConfig.config ) {
							entityTemplateChildConfig.config = {}
						}

						applyEntityConfig( entityTemplateChildConfig.config, overloadedChildConfig.config )

					} else {
						memo.push( overloadedChildConfig )
					}

					return memo
				},
				deepClone( entityTemplateChildrenConfig )
			)
		}

		var mergeOverloadedChildren = function( entityTemplateChildren, overloadedChildren ) {
			if( !overloadedChildren || overloadedChildren.length === 0 ) {
				return entityTemplateChildren
			}

			if( !entityTemplateChildren || entityTemplateChildren.length === 0 ) {
				return overloadedChildren
			}

			var result = deepClone( entityTemplateChildren )

			for( var i = 0; i < overloadedChildren.length; i++ ) {
				var overloadedChild = overloadedChildren[ i ]

				var entityTemplateChild = _.find(
					result,
					function( tmp ) {
						return tmp.name === overloadedChild.name
					}
				)

				if( !entityTemplateChild ) {
					result.push( deepClone( overloadedChild ) )
					continue
				}

				if( !entityTemplateChild.config ) {
					entityTemplateChild.config = {}
				}

				applyEntityConfig( entityTemplateChild.config, overloadedChild.config )

				if( overloadedChild.id ) {
					entityTemplateChild.id = overloadedChild.id
				}

				entityTemplateChild.children = applyOverloadedChildrenConfig( entityTemplateChild.children, overloadedChild.children )
			}

			return result
		}

		var addToParentEntity = function( compositeComponents, entityId, parentEntityId ) {
			var parentCompositeComponent = compositeComponents[ parentEntityId ]
			if( !parentCompositeComponent ) return

			parentCompositeComponent.childrenIds.push( entityId )
		}

		var removeFromParentEntity = function( compositeComponents, entityId, parentEntityId ) {
			var parentCompositeComponent = compositeComponents[ parentEntityId ]
			if( !parentCompositeComponent ) return

			var parentChildrenIds = parentCompositeComponent.childrenIds

			// forcing entityId to type string because indexOf performs a type-safe comparison, entityId can be a number on the flash target
			var index = parentChildrenIds.indexOf( '' + entityId )

			if( index >= 0 ) {
				arrayRemove( parentChildrenIds, index )
			}
		}

		var addToSpatialIndex = function( spatialIndex, componentMaps, dimensions, entityId ) {
			var transform    = componentMaps[ TRANSFORM_COMPONENT_ID ][ entityId ],
				visualObject = componentMaps[ VISUAL_OBJECT_COMPONENT_ID ][ entityId ]

			if( !transform ||
				!visualObject ||
				visualObject.pass === 'ui' ||
				visualObject.pass === 'background' ) {

				return
			}

			var compositeComponent = componentMaps[ COMPOSITE_COMPONENT_ID ][ entityId ]

			spatialIndex.insert(
				transform.worldTranslation,
				dimensions,
				{
					id : entityId,
					parent : compositeComponent.parentId,
					children : compositeComponent.childrenIds,
					layer : visualObject ? visualObject.layer : 0
				},
				entityId
			)
		}

		var updateSpatialIndex = function( componentMaps, spatialIndex, entityId ) {
			spatialIndex.remove( entityId )

			addToSpatialIndex(
				spatialIndex,
				componentMaps,
				getEntityDimensions( componentMaps, entityId ),
				entityId
			)
		}

		/**
		 * Normalizes the provided entity config
		 *
		 * @private
		 * @param libraryManager
		 * @param arg1 can be either an entity template id or a entity config
		 * @private
		 * @return {*}
		 */
		var normalizeEntityConfig = function( libraryManager, arg1 ) {
			if( !arg1 ) return

			var entityTemplateId = _.isString( arg1 ) ? arg1 : arg1.entityTemplateId

			var entityConfig = {
				children         : arg1.children || [],
				config           : arg1.config || {},
				id               : arg1.id,
				parentId         : arg1.parentId !== undefined ? arg1.parentId : ROOT_ENTITY_ID,
				name             : arg1.name,
				entityTemplateId : entityTemplateId
			}

			// check for ambiguous sibling names
			var ambiguousName = recursiveFind( entityConfig, createAmbiguousSiblingName )

			if( ambiguousName ) {
				throw 'Error: The entity configuration contains the ambiguous sibling name "' + ambiguousName + '". Entity siblings must have unique names.'
			}

			if( entityTemplateId ) {
				var entityTemplate = libraryManager.get( entityTemplateId )

				if( !entityTemplate ) {
					throw 'Error: Unknown entity template "' + entityTemplateId + '". Could not create entity.'
				}

				entityConfig.children = applyOverloadedChildrenConfig( entityTemplate.children, entityConfig.children )
			}

			return entityConfig
		}

		var createBaseComponents = function( spell, libraryManager, moduleLoader, parentId, name, entityTemplateId ) {
			var result = {},
				component

			// COMPOSITE_COMPONENT_ID
			result[ COMPOSITE_COMPONENT_ID ] = component = createComponent(
				spell,
				moduleLoader,
				libraryManager.get( COMPOSITE_COMPONENT_ID ),
				COMPOSITE_COMPONENT_ID
			)

			component.parentId = parentId

			// METADATA_COMPONENT_ID
			result[ METADATA_COMPONENT_ID ] = component = createComponent(
				spell,
				moduleLoader,
				libraryManager.get( METADATA_COMPONENT_ID ),
				METADATA_COMPONENT_ID
			)

			if( name ) {
				component.name = name
			}

			if( entityTemplateId ) {
				component.entityTemplateId = entityTemplateId
			}

			return result
		}

		var isAmbiguousSiblingName = function( componentMaps, ids, entityId, name ) {
			var metaDataComponents = componentMaps[ METADATA_COMPONENT_ID ]

			for( var i = 0, id, n = ids.length; i < n; i++ ) {
				id = ids[ i ]

				if( entityId != id &&
					metaDataComponents[ id ].name === name ) {

					return true
				}
			}

			return false
		}

		var createComponent = function( spell, moduleLoader, componentDefinition, componentId ) {
			// try component type first
			var component = createComponentType( moduleLoader, spell, componentId )

			// fall back to regular object component when no component type is available
			return initComponent( component || {}, componentDefinition )
		}

		var updateComponent = function( component, attributeConfig ) {
			if( attributeConfig === undefined ) {
				return component

			} else {
				return _.extend( component, attributeConfig )
			}
		}

		var hasAssetIdAttribute = function( attributeConfig ) {
			return !!_.find(
				attributeConfig,
				function( attribute ) {
					var type = attribute.type

					if( !_.isString( type ) ) return false

					return attribute.type.indexOf( 'assetId:' ) === 0
				}
			)
		}

		/**
		 * This function dereferences asset ids. If a component with an asset id attribute is found the reference is resolved and a additional asset attribute
		 * is added to the component instance.
		 *
		 * @private
		 * @param assetManager
		 * @param component
		 * @return {*}
		 */
		var injectAsset = function( assetManager, moduleLoader, component ) {
			var assetId = component.assetId

			if( assetId ) {
				var asset = assetManager.get( assetId )

				if( !asset &&
					stringUtil.startsWith( assetId, 'script:' ) ) {

					var libraryId = assetId.substr( 7 )

					asset = moduleLoader.require( createModuleId( libraryId ) )
				}

				if( !asset ) {
					throw 'Error: Could not resolve asset id "' + assetId + '" to asset instance. Please make sure that the asset id is valid.'
				}

				component.asset = asset
			}

			return component
		}

		var createComponents = function( spell, assetManager, libraryManager, moduleLoader, componentConfig, entityTemplateId, injectAssets ) {
			if( injectAssets === undefined ) injectAssets = true

			if( entityTemplateId ) {
				var entityTemplate = libraryManager.get( entityTemplateId )

				if( !entityTemplate ) {
					throw 'Error: Unknown entity template "' + entityTemplateId + '". Could not create entity.'
				}
			}

			var entity = applyEntityConfig(
				entityTemplate ? deepClone( entityTemplate.config ) : {},
				componentConfig
			)

			_.each(
				entity,
				function( attributeConfig, componentId ) {
					var componentDefinition = libraryManager.get( componentId )

					if( !componentDefinition ) {
						throw 'Error: Could not find component definition "' + componentId +
							entityTemplateId ?
								'" referenced in entity template "' + entityTemplateId + '".' :
								'".'
					}

					var updatedComponent = updateComponent(
						createComponent( spell, moduleLoader, componentDefinition, componentId ),
						attributeConfig
					)

					entity[ componentId ] = hasAssetIdAttribute( componentDefinition.attributes ) && injectAssets ?
						injectAsset( assetManager, moduleLoader, updatedComponent ) :
						updatedComponent
				}
			)

			return entity
		}

		var createEntity = function( spell, assetManager, eventManager, libraryManager, moduleLoader, componentMaps, spatialIndex, entityConfig ) {
			entityConfig = normalizeEntityConfig( libraryManager, entityConfig )

			if( !entityConfig ) throw 'Error: Supplied invalid arguments.'

			var entityTemplateId = entityConfig.entityTemplateId,
				config           = entityConfig.config,
				parentId         = entityConfig.parentId

			if( !entityTemplateId && !config ) {
				throw 'Error: Supplied invalid arguments.'
			}

			var entityId = getEntityId( entityConfig.id )

			// creating base components which the engine requires
			var baseComponents = createBaseComponents( spell, libraryManager, moduleLoader, parentId, entityConfig.name, entityTemplateId )

			addComponents( componentMaps, eventManager, spatialIndex, entityId, baseComponents )

			// creating the entity
			var entityComponents = createComponents( spell, assetManager, libraryManager, moduleLoader, config, entityTemplateId )

			addComponents( componentMaps, eventManager, spatialIndex, entityId, entityComponents )

			// creating child entities
			var children = entityConfig.children

			for( var i = 0, childEntityConfig, n = children.length; i < n; i++ ) {
				childEntityConfig = children[ i ]
				childEntityConfig.parentId = entityId

				createEntity( spell, assetManager, eventManager, libraryManager, moduleLoader, componentMaps, spatialIndex, childEntityConfig )
			}

			// HACK: now that the composite structure is in place the spatial index can be updated for real
			updateSpatialIndex( componentMaps, spatialIndex, entityId )

			// check for validity: is the name unique?
			if( entityConfig.name ) {
				var parentCompositeComponent = componentMaps[ COMPOSITE_COMPONENT_ID ][ parentId ]

				if( isAmbiguousSiblingName( componentMaps, parentCompositeComponent.childrenIds, entityId, entityConfig.name ) ) {
					throw 'Error: The name "' + entityConfig.name + '" of entity ' + entityId + ' collides with one if its siblings. Entity siblings must have unique names.'
				}
			}

			_.extend( entityComponents, baseComponents )
			eventManager.publish( eventManager.EVENT.ENTITY_CREATED, [ entityId, entityComponents ] )

			return entityId
		}

		var assembleEntityInstance = function( componentMaps, id ) {
			return _.reduce(
				componentMaps,
				function( memo, componentMap, componentId ) {
					var component = componentMap[ id ]

					if( component ) {
						memo[ componentId ] = component
					}

					return memo
				},
				{}
			)
		}

		var getEntityCompositeIds = function( compositeComponents, entityId, resultIds ) {
			resultIds.push( entityId )

			var childrenIds = compositeComponents[ entityId ].childrenIds

			for( var i = 0, numChildrenIds = childrenIds.length; i < numChildrenIds; i++ ) {
				getEntityCompositeIds( compositeComponents, childrenIds[ i ], resultIds )
			}

			return resultIds
		}

		var getEntityDimensions = function( componentMaps, entityId ) {
			var staticAppearances   = componentMaps[ STATIC_APPEARANCE_COMPONENT_ID ],
				animatedAppearances = componentMaps[ ANIMATED_APPEARANCE_COMPONENT_ID ],
				transforms          = componentMaps[ TRANSFORM_COMPONENT_ID ],
				quadGeometries      = componentMaps[ QUAD_GEOMETRY_COMPONENT_ID ],
				tilemaps            = componentMaps[ TILEMAP_COMPONENT_ID ],
				dimensions          = vec2.create()

			if( quadGeometries &&
				quadGeometries[ entityId ] &&
				quadGeometries[ entityId ].dimensions ) {

				// if a quadGeometry is specified, always take this
				vec2.copy( dimensions, quadGeometries[ entityId ].dimensions )

			} else if( staticAppearances && staticAppearances[ entityId ] &&
				staticAppearances[ entityId ].asset &&
				staticAppearances[ entityId ].asset.resource &&
				staticAppearances[ entityId ].asset.resource.dimensions ) {

				// entity has a static appearance
				vec2.copy( dimensions, staticAppearances[ entityId ].asset.resource.dimensions )

			} else if( animatedAppearances &&
				animatedAppearances[ entityId ] &&
				animatedAppearances[ entityId ].asset &&
				animatedAppearances[ entityId ].asset.frameDimensions ) {

				// entity has an animated appearance
				vec2.copy( dimensions, animatedAppearances[ entityId ].asset.frameDimensions )

			} else if( tilemaps &&
				tilemaps[ entityId ] &&
				tilemaps[ entityId ].asset ) {

				// entity is a tilemap
				vec2.copy( dimensions, tilemaps[ entityId ].asset.tilemapDimensions )
				vec2.multiply( dimensions, dimensions, tilemaps[ entityId ].asset.spriteSheet.frameDimensions )

			} else {
				return
			}

			// apply scale factor
			if( transforms && transforms[ entityId ] ) {

                // TODO: using the worldScale would be more correct here, but as we don't want to calculate it
                // only for this test, use the local scale
				// vec2.multiply( dimensions, dimensions, transforms[ entityId ].scale )
			}

			return dimensions
		}

		/**
		 * Sets the attribute of a component to the specified value.
		 *
		 * @private
		 * @param component
		 * @param attributeId
		 * @param value
		 */
		var setAttribute = function( component, attributeId, value ) {
			// TODO: Unfortunately there is no generic copy operator in javascript.
			if( _.isObject( value ) ||
				_.isArray( value ) ) {
				_.extend( component[ attributeId ], value )

			} else {
				component[ attributeId ] = value
			}
		}

		var updateComponentAttributeTM = function( assetManager, moduleLoader, componentsWithAssets, componentId, attributeId, component, value ) {
			setAttribute( component, attributeId, value )

			if( componentsWithAssets[ componentId ] ) {
				var assetIdChanged = attributeId === 'assetId'

				if( assetIdChanged ) {
					injectAsset( assetManager, moduleLoader, component )
				}
			}
		}

		var updateComponentTM = function( assetManager, moduleLoader, componentsWithAssets, componentId, component, attributeConfig ) {
			for( var attributeId in attributeConfig ) {
				setAttribute( component, attributeId, attributeConfig[ attributeId ] )
			}

			if( componentsWithAssets[ componentId ] ) {
				var assetIdChanged = !!attributeConfig[ 'assetId' ]

				if( assetIdChanged ) {
					injectAsset( assetManager, moduleLoader, component )
				}
			}
		}

		var bubbleEventR = function( spell, compositeComponents, eventHandlersComponents, entityId, eventId, eventArguments ) {
			var eventHandlersComponent = eventHandlersComponents[ entityId ]

			if( eventHandlersComponent ) {
				var scriptInstance = eventHandlersComponent.asset

				if( scriptInstance ) {
					var eventHandler = eventHandlersComponent.asset[ eventId ]

					if( eventHandler ) {
						eventHandler.apply( null, [ spell, entityId ].concat( eventArguments ) )

						return
					}
				}
			}

			var nearestEntityId = getAncestorId( compositeComponents, eventHandlersComponents, entityId )
			if( !nearestEntityId ) return

			bubbleEventR( spell, compositeComponents, eventHandlersComponents, nearestEntityId, eventId, eventArguments )
		}

		var EntityManager = function( spell, configurationManager, assetManager, eventManager, libraryManager, moduleLoader ) {
			this.configurationManager = configurationManager
			this.componentMaps        = {}
			this.assetManager         = assetManager
			this.eventManager         = eventManager
			this.libraryManager       = libraryManager
			this.moduleLoader         = moduleLoader
			this.spell                = spell
			this.spatialIndex         = undefined
			this.componentsWithAssets = {}
			this.deferredEvents       = new LinkedList()
		}

		EntityManager.prototype = {
			/**
			 * Creates an entity using the given configuration object.
			 *
			 * Available configuration options are:
			 *
			 * * **entityTemplateId** [String] - if the entity should be constructed using an entity template you can specify the library path to the entity template here
			 * * **config** [Object] - component configuration for this entity. It can also be used to partially override an entity template config
			 * * **children** [Array] - if this entity has children, an array of nested config objects can be specified here
			 * * **id** [String] - if specified the entity will be created using this id. Please note: you should not use this function unless you know what you're doing. Normally the engine assigns entityIds automatically.
			 * * **name** [String] - a name for this entity. If specified, you can use the {@link #getEntityIdsByName} function to lookup named entities to their entityIds
			 *
			 * Example:
			 *
			 *     // create a new entity with the given components
			 *     var entityId = spell.entityManager.createEntity({
			 *         config: {
			 *             "spell.component.2d.transform": {
			 *                 "translation": [ 100, 200 ]
			 *             },
			 *             "spell.component.visualObject": {
			 *               // if no configuration is specified the default values of this component will be used
			 *             },
			 *             "spell.component.2d.graphics.appearance": {
			 *                 "assetId": "appearance:library.identifier.of.my.static.appearance"
			 *             }
			 *         }
			 *     })
			 *
			 *     // create a new entity with child entities
			 *     var entityId = spell.entityManager.createEntity({
			 *         config: {
			 *             "spell.component.2d.transform": {
			 *                 "translation": [ 100, 200 ]
			 *             },
			 *             "spell.component.visualObject": {
			 *               // if no configuration is specified the default values of this component will be used
			 *             },
			 *             "spell.component.2d.graphics.appearance": {
			 *                 "assetId": "appearance:library.identifier.of.my.static.appearance"
			 *             }
			 *         },
			 *         children: [
			 *             {
			 *                 config: {
			 *                     "spell.component.2d.transform": {
			 *                         "translation": [ -15, 20 ] // translation is relative to the parent
			 *                     },
			 *                     "spell.component.visualObject": {
			 *                       // if no configuration is specified the default values of this component will be used
			 *                     },
			 *                     "spell.component.2d.graphics.appearance": {
			 *                         "assetId": "appearance:library.identifier.of.my.other.static.appearance"
			 *                     }
			 *                 }
			 *             }
			 *         ]
			 *     })
			 *
			 *     // create a new entity from an entity template
			 *     var entityId = spell.entityManager.createEntity({
			 *         entityTemplateId: 'library.identifier.of.my.template'
			 *     })
			 *
			 *     // create a new entity from an entity template and override values from the template
			 *     var entityId = spell.entityManager.createEntity({
			 *         entityTemplateId: 'library.identifier.of.my.template',
			 *         config: {
			 *             "spell.component.box2d.simpleBox": {
			 *                 "dimensions":[ 100, 100 ]
			 *              },
			 *              "spell.component.2d.transform": {
			 *                  "translation": [ 150, 50 ]
			 *               }
			 *         }
			 *     })
			 *
			 * @param {Object} entityConfig an entity configuration object
			 * @return {String} the entity id of the newly created entity
			 */
			createEntity : function( entityConfig ) {
				return createEntity( this.spell, this.assetManager, this.eventManager, this.libraryManager, this.moduleLoader, this.componentMaps, this.spatialIndex, entityConfig )
			},

			/**
			 * Creates entities from a list of entity configs.
			 *
			 * See {@link #createEntity} function for a documentation of the entity config object.
			 *
			 * @param {Array} entityConfigs
			 */
			createEntities : function( entityConfigs ) {
				for( var i = 0, n = entityConfigs.length; i < n; i++ ) {
					this.createEntity( entityConfigs[ i ] )
				}
			},

			/**
			 * Removes an entity
			 *
			 * @param {String} entityId the id of the entity to remove
			 */
			removeEntity : function( entityId ) {
				if( !entityId ) {
					return false
				}

				removeEntity( this.eventManager, this.componentMaps, this.spatialIndex, entityId )

				return true
			},

			/**
			 * Creates an exact copy of the given entityId
			 * @param entityId
			 */
			cloneEntity: function( entityId ) {
				var entityConfig = {
					config : assembleEntityInstance( this.componentMaps, entityId )
				}

				return createEntity( this.spell, this.assetManager, this.eventManager, this.libraryManager, this.moduleLoader, this.componentMaps, this.spatialIndex, entityConfig )
			},


			/**
			 * Returns the width and height for a given entity
			 * @param entityId
			 * @return vec2 2d-vector containing the dimension
			 */
			getEntityDimensions: function( entityId ) {
				return getEntityDimensions( this.componentMaps, entityId )
			},


			/**
			 * Returns an array of ids of entities which have the requested name.
			 *
			 * @param {String} name the name of the entity
			 * @param {String} scopeEntityId the scope of the search is limited to this entity and its descendants
			 * @return {Array}
			 */
			getEntityIdsByName : function( name, scopeEntityId ) {
				var componentMaps      = this.componentMaps,
					metaDataComponents = componentMaps[ METADATA_COMPONENT_ID ],
					resultIds          = []

				var ids = scopeEntityId ?
					getEntityCompositeIds( componentMaps[ COMPOSITE_COMPONENT_ID ], scopeEntityId, [] ) :
					_.keys( metaDataComponents )

				for( var i = 0, n = ids.length; i < n; i++ ) {
					var nameComponentId = ids[ i ]

					if( metaDataComponents[ nameComponentId ] && metaDataComponents[ nameComponentId ][ 'name' ] === name ) {
						resultIds.push( nameComponentId )
					}
				}

				return resultIds
			},

			/**
			 * Returns all entities which intersect with the region defined by the position and dimension. The return
			 * value is an object with the entity ids as keys and additional entity metadata as value.
			 *
			 * @param position {Array} the position of the region in world coordinates
			 * @param dimensions {Array} the dimensions of the region in world coordinates
			 * @return {Object}
			 */
			getEntityIdsByRegion : function( position, dimensions ) {
				return this.spatialIndex.search( position, dimensions )
			},

			/**
			 * Initializes the entity manager.
			 */
			init : function() {
				this.spatialIndex = new QuadTree( this.configurationManager.getValue( 'quadTreeSize' ) )

				// create root entity
				var entityConfig = {
					id : ROOT_ENTITY_ID,
					parentId : INVALID_ENTITY_ID
				}

				createEntity( this.spell, this.assetManager, this.eventManager, this.libraryManager, this.moduleLoader, this.componentMaps, this.spatialIndex, entityConfig )
            },

			/**
			 * Destroys the entity manager. Frees all internal resources.
			 */
			destroy : function() {
				this.removeEntity( ROOT_ENTITY_ID )
				this.deferredEvents.clear()
			},

			/**
			 * Changes the parent of the specified entity.
			 *
			 * Example:
			 *
			 *     // make entity A the child of entity B
			 *     spell.entityManager.changeParentEntity( aId, bId )
			 *
			 *     // make entity A a root entity, that is it has no parent
			 *     spell.entityManager.changeParentEntity( aId )
			 *
			 * @param entityId the id of the entity which gets reassigned
			 * @param newParentEntityId the id of the entity which will be the parent entity
			 */
			changeParentEntity : function( entityId, newParentEntityId ) {
				if( !entityId ) throw 'Error: Missing entity id.'

				this.updateComponent( entityId, COMPOSITE_COMPONENT_ID, { parentId : newParentEntityId } )
			},

			/**
			 * Check if an entity already has a specific component
			 *
			 * @param {String} entityId of the entity that the component belongs to
			 * @param {String} componentId the library path of the component
			 * @return {Boolean}
			 */
			hasComponent : function( entityId, componentId ) {
				var componentMap = this.componentMaps[ componentId ]
				if( !componentMap ) return false

				return !!componentMap[ entityId ]
			},

			/**
			 * Adds a component to an entity.
			 *
			 * Example:
			 *
			 *     // add a component with it's default configuration to this entity
			 *     spell.entityManager.addComponent( entityId, "spell.component.2d.graphics.debug.box" )
			 *
			 *     // add a component to this entity and override a default value
			 *     spell.entityManager.addComponent(
			 *         entityId,
			 *         "spell.component.2d.graphics.textApperance",
			 *         {
			 *             "text": "Hello World"
			 *         }
			 *     )
			 *
			 * @param {String} entityId of the entity that the component belongs to
			 * @param {String} componentId the library path of the component to add
			 * @param {Object} attributeConfig the attribute configuration of the component
			 */
			addComponent : function( entityId, componentId, attributeConfig ) {
				if( !entityId ) throw 'Error: Missing entity id.'
				if( !componentId ) throw 'Error: Missing component id.'

				var componentConfigs = {}
				componentConfigs[ componentId ] = attributeConfig || {}

				addComponents(
					this.componentMaps,
					this.eventManager,
					this.spatialIndex,
					entityId,
					createComponents( this.spell, this.assetManager, this.libraryManager, this.moduleLoader, componentConfigs )
				)
			},

			/**
			 * Removes a component from an entity.
			 *
			 * @param {String} entityId the id of the entity that the component belongs to
			 * @param {String} componentId the library path of the component to remove
			 */
			removeComponent : function( entityId, componentId ) {
				if( !entityId ) throw 'Error: Missing entity id.'

				var eventManager  = this.eventManager,
					componentMaps = this.componentMaps

				removeComponent( eventManager, componentMaps, this.spatialIndex, componentId, entityId )

				if( !entityExists( componentMaps, entityId ) ) {
					eventManager.publish( eventManager.EVENT.ENTITY_REMOVED, entityId )
				}
			},

			/**
			 * Returns a component from a specific entity.
			 *
			 * @param {String} entityId the id of the requested entity
			 * @param {String} componentId the requested component id
			 * @return {Object}
			 */
			getComponentById : function( entityId, componentId ) {
				var componentMap = this.componentMaps[ componentId ]

				return componentMap ? componentMap[ entityId ] : undefined
			},

			/**
			 * Returns a collection of components which have the requested component id and belong to entities which have the requested name.
			 *
			 * @param {String} componentId the requested component id
			 * @param {String} name the requested entity name
			 * @param {String} scopeEntityId the scope of the search is limited to this entity and its descendants
			 * @return {Object}
			 */
			getComponentsByName : function( componentId, name, scopeEntityId ) {
				var componentMap = this.getComponentMapById( componentId ),
					ids          = this.getEntityIdsByName( name, scopeEntityId )

				if( ids.length === 0 ||
					!componentMap ) {

					return []
				}

				return _.pick( componentMap, ids )
			},

			/**
			 * Updates the attributes of a component. Returns true when successful, false otherwise.
			 *
			 * Example:
			 *     // update a component of an entity
			 *     spell.entityManager.updateComponent(
			 *         entityId,
			 *         "spell.component.2d.graphics.appearance",
			 *         {
			 *             assetId : "appearance:library.identifier.of.my.static.appearance"
			 *         }
			 *     )
			 *
			 * @param {String} entityId the id of the entity which the component belongs to
			 * @param {String} componentId the library path of the component
			 * @param {Object} attributeConfig the attribute configuration change of the component
			 * @return {Boolean} true if the component could be found, false otherwise
			 */
			updateComponent : function( entityId, componentId, attributeConfig ) {
				var componentMaps = this.componentMaps,
					components    = componentMaps[ componentId ],
					component     = components[ entityId ]

				if( !component ) return false

				// HACK: create a partial clone of the component
				var oldComponentState = {}

				for( var attributeId in attributeConfig ) {
					oldComponentState[ attributeId ] = deepClone( component[ attributeId ] )
				}

				updateComponentTM( this.assetManager, this.moduleLoader, this.componentsWithAssets, componentId, component, attributeConfig )

				var eventManager  = this.eventManager,
					spatialIndex  = this.spatialIndex

				if( componentId === COMPOSITE_COMPONENT_ID ) {
					removeFromParentEntity( components, entityId, oldComponentState.parentId )
					addToParentEntity( components, entityId, component.parentId )
					updateWorldTransform( componentMaps, eventManager, spatialIndex, true, entityId )
					updateVisualObject( componentMaps, entityId )

				} else if( componentId === TRANSFORM_COMPONENT_ID ) {
					if( attributeConfig.translation ||
						attributeConfig.scale ||
						attributeConfig.rotation !== undefined ) {

						updateWorldTransform( componentMaps, eventManager, spatialIndex, true, entityId )
					}

				} else if( componentId === TEXTURE_MATRIX_COMPONENT_ID ) {
					if( attributeConfig.translation ||
						attributeConfig.scale ||
						attributeConfig.rotation ) {

						updateTextureMatrix( componentMaps[ TEXTURE_MATRIX_COMPONENT_ID ][ entityId ] )
					}

				} else if( componentId === VISUAL_OBJECT_COMPONENT_ID ) {
					updateSpatialIndex( componentMaps, spatialIndex, entityId )
					updateVisualObject( componentMaps, entityId )
				}

				eventManager.publish( [ eventManager.EVENT.COMPONENT_UPDATED, componentId ], [ component, entityId ] )

				return true
			},

			/**
			 * Updates one attribute of a component. Returns true when successful, false otherwise.
			 *
			 * Example:
			 *     // update a specific attribute of a component of an entity
			 *     spell.entityManager.updateComponentAttribute(
			 *         entityId,
			 *         "spell.component.2d.transform",
			 *         "translation",
			 *         [ 10, 10 ]
			 *     )
			 *
			 * @param {String} entityId the id of the entity which the component belongs to
			 * @param {String} componentId the library path of the component
			 * @param {String} attributeId the id of the attribute
			 * @param {Object} value the value of the attribute
			 * @return {Boolean} true if the component could be found, false otherwise
			 */
			updateComponentAttribute : function( entityId, componentId, attributeId, value ) {
				var componentMaps = this.componentMaps,
					components    = componentMaps[ componentId ],
					component     = components[ entityId ]

				if( !component ) return false

				var oldAttributeValue = component[ attributeId ]
				if( oldAttributeValue === undefined ) return false

				updateComponentAttributeTM( this.assetManager, this.moduleLoader, this.componentsWithAssets, componentId, attributeId, component, value )

				var eventManager  = this.eventManager,
					spatialIndex  = this.spatialIndex

				if( componentId === COMPOSITE_COMPONENT_ID &&
					attributeId === 'parentId' ) {

					removeFromParentEntity( components, entityId, oldAttributeValue )
					addToParentEntity( components, entityId, value )
					updateWorldTransform( componentMaps, eventManager, spatialIndex, true, entityId )
					updateVisualObject( componentMaps, entityId )

				} else if( componentId === TRANSFORM_COMPONENT_ID ) {
					if( attributeId === 'translation' ||
						attributeId === 'scale' ||
						attributeId === 'rotation' ) {

						updateWorldTransform( componentMaps, eventManager, spatialIndex, true, entityId )
					}

				} else if( componentId === TEXTURE_MATRIX_COMPONENT_ID ) {
					if( attributeId === 'translation' ||
						attributeId === 'scale' ||
						attributeId === 'rotation' ) {

						updateTextureMatrix( componentMaps[ TEXTURE_MATRIX_COMPONENT_ID ][ entityId ] )
					}

				} else if( componentId === VISUAL_OBJECT_COMPONENT_ID ) {
					updateSpatialIndex( componentMaps, spatialIndex, entityId )
					updateVisualObject( componentMaps, entityId )
				}

				eventManager.publish( [ eventManager.EVENT.COMPONENT_UPDATED, componentId ], [ component, entityId ] )

				return true
			},

			/**
			 * Returns a component map of a specific type.
			 *
			 * @param {String} componentId the requested component type / id
			 * @return {*}
			 */
			getComponentMapById : function( componentId ) {
				return this.componentMaps[ componentId ]
			},

			updateWorldTransform : function( entityId ) {
				updateWorldTransform( this.componentMaps, this.eventManager, this.spatialIndex, true, entityId )
			},

			updateTextureMatrix : function( entityId ) {
				updateTextureMatrix( this.componentMaps[ TEXTURE_MATRIX_COMPONENT_ID ][ entityId ] )
			},

			/**
			 * Updates all components which reference the asset with the updated asset instance.
			 *
			 * @param assetId
			 * @param asset
			 * @private
			 */
			updateAssetReferences : function( assetId, asset ) {
				var componentMaps = this.componentMaps

				for( var componentId in this.componentsWithAssets ) {
					var componentMap = componentMaps[ componentId ]

					for( var id in componentMap ) {
						var component = componentMap[ id ]

						if( component.assetId === assetId ) {
							component.asset = asset
						}
					}
				}
			},

			/**
			 * Refreshes all references to assets that components hold
			 *
			 * @private
			 * @param assetManager
			 */
			refreshAssetReferences : function( assetManager ) {
				var componentMaps = this.componentMaps

				for( var componentId in this.componentsWithAssets ) {
					var componentMap = componentMaps[ componentId ]

					for( var id in componentMap ) {
						var component = componentMap[ id ]

						if( component.assetId.slice( 0, component.assetId.indexOf( ':' ) ) === 'script' ) {
							continue
						}

						component.asset = assetManager.get( component.assetId )
					}
				}
			},

			/**
			 * Triggers an event on the specified entity.
			 *
			 * @param entityId
			 * @param eventId
			 * @param eventArguments
			 * @param timerInMs
			 * @param timerCondition
			 */
			triggerEvent : function( entityId, eventId, eventArguments, timerInMs, timerCondition ) {
				if( timerInMs ) {
					this.deferredEvents.append( new DeferredEvent( entityId, eventId, eventArguments, timerInMs, timerCondition ) )

				} else {
					var componentMaps = this.componentMaps

					bubbleEventR(
						this.spell,
						componentMaps[ COMPOSITE_COMPONENT_ID ],
						componentMaps[ EVENT_HANDLERS_COMPONENT_ID ],
						entityId,
						eventId,
						eventArguments
					)
				}
			},

			updateEntityTemplate : function( entityDefinition ) {
				var entityTemplateId = createId( entityDefinition.namespace, entityDefinition.name )

				// get ids of entities which are based on this entity template
				var ids = _.reduce(
					this.componentMaps[ METADATA_COMPONENT_ID ],
					function( memo, component, entityId ) {
						if( component.entityTemplateId === entityTemplateId ) {
							memo.push( entityId )
						}

						return memo
					},
					[]
				)

				for( var i = 0, id, n = ids.length; i < n; i++ ) {
					id = ids[ i ]

					// remove entities
					this.removeEntity( id )
					this.spatialIndex.remove( id )

					// recreate entities while using old ids
					this.createEntity( {
						entityTemplateId : entityTemplateId,
						id : id
					} )
				}
			},

			/**
			 * Registers the component specified by componentDefition. Components must be registered with this method before they can be used.
			 *
			 * @private
			 * @param componentDefinition
			 */
			registerComponent : function( componentDefinition ) {
				var componentId = createId( componentDefinition.namespace, componentDefinition.name )

				if( !isValidComponentDefinition( componentDefinition ) ) {
					throw 'Error: The format of the supplied component definition "' + componentId + '" is invalid.'
				}

				if( !this.componentMaps[ componentId ] ) {
					this.componentMaps[ componentId ] = {}
				}

				if( hasAssetIdAttribute( componentDefinition.attributes ) ) {
					this.componentsWithAssets[ componentId ] = true

				} else {
					delete this.componentsWithAssets[ componentId ]
				}
			},

			updateDeferredEvents : function( deltaTimeInMs ) {
				var deferredEvents = this.deferredEvents,
					iterator       = deferredEvents.createIterator(),
					node,
					deferredEvent

				while( node = iterator.next() ) {
					deferredEvent = node.data

					if( deferredEvent.ready( deltaTimeInMs ) ) {
						iterator.remove()
						deferredEvent.trigger( this )
					}
				}
			}
		}

		return EntityManager
	}
)

define(
	'spell/shared/util/Timer',
	[
		'spell/shared/util/platform/Types',

		'spell/functions'
	],
	function(
		Types,

		_
	) {
		'use strict'


		/*
		 * private
		 */

//		var checkTimeWarp = function( newRemoteTime, updatedRemoteTime ) {
//			if( updatedRemoteTime > newRemoteTime ) return
//
//			var tmp = newRemoteTime - updatedRemoteTime
//			console.log( 'WARNING: clock reset into past by ' + tmp + ' ms' )
//		}

		var getCurrentTimeInMs = Types.Time.getCurrentInMs

		/*
		 * public
		 */

		var Timer = function( eventManager, statisticsManager, initialTime ) {
			this.newRemoteTime        = initialTime
			this.remoteTime           = initialTime
			this.newRemoteTimPending  = false
			this.localTime            = initialTime
			this.previousSystemTime   = getCurrentTimeInMs()
			this.elapsedTime          = 0
			this.deltaLocalRemoteTime = 0
			this.statisticsManager    = statisticsManager

			eventManager.subscribe(
				[ 'clockSyncUpdate' ],
				_.bind(
					function( updatedRemoteTime ) {
//						checkTimeWarp( newRemoteTime, updatedRemoteTime )

						this.newRemoteTime = updatedRemoteTime
						this.newRemoteTimPending = true
					},
					this
				)
			)

			eventManager.subscribe(
				eventManager.EVENT.CLOCK_SYNC_ESTABLISHED,
				_.bind(
					function( initialRemoteGameTimeInMs ) {
						this.newRemoteTime = this.remoteTime = this.localTime = initialRemoteGameTimeInMs
						this.newRemoteTimPending = false
					},
					this
				)
			)

			// setting up statistics
//			statisticsManager.addSeries( 'remoteTime', '' )
//			statisticsManager.addSeries( 'localTime', '' )
//			statisticsManager.addSeries( 'deltaLocalRemoteTime', '' )
//			statisticsManager.addSeries( 'relativeClockSkew', '' )
//			statisticsManager.addSeries( 'newRemoteTimeTransfered', '' )
		}

		Timer.prototype = {
			update : function() {
				// TODO: think about incorporating the new value 'softly' instead of directly replacing the old one
				if( this.newRemoteTimPending ) {
					this.remoteTime          = this.newRemoteTime
					this.newRemoteTimPending = false
				}

				// measuring time
				var systemTime            = getCurrentTimeInMs()
				this.elapsedTime          = Math.max( systemTime - this.previousSystemTime, 0 ) // it must never be smaller than 0
				this.previousSystemTime   = systemTime

				this.localTime            += this.elapsedTime
				this.remoteTime           += this.elapsedTime
				this.deltaLocalRemoteTime = this.localTime - this.remoteTime

				// relative clock skew
				var factor = 1000000000
				this.relativeClockSkew = ( ( this.localTime / this.remoteTime * factor ) - factor ) * 2 + 1

				// updating statistics
//				this.statisticsManager.updateSeries( 'remoteTime', this.remoteTime % 2000 )
//				this.statisticsManager.updateSeries( 'localTime', this.localTime % 2000 )
//				this.statisticsManager.updateSeries( 'deltaLocalRemoteTime', this.deltaLocalRemoteTime + 250 )
//				this.statisticsManager.updateSeries( 'relativeClockSkew', this.relativeClockSkew )
			},
			getLocalTime : function() {
				return this.localTime
			},
			getElapsedTime : function() {
				return this.elapsedTime
			},
			getRemoteTime : function() {
				return this.remoteTime
			}//,
//			getDeltaLocalRemoteTime : function() {
//				return deltaRemoteLocalTime
//			},
//			getRelativeClockSkew : function() {
//				return relativeClockSkew
//			}
		}

		return Timer
	}
)

define(
	'spell/shared/util/StopWatch',
	[
		'spell/shared/util/platform/Types'
	],
	function(
		Types
	) {
		'use strict'


		var getCurrentTimeInMs = Types.Time.getCurrentInMs

		var StopWatch = function() {
			this.value = 0
		}

		StopWatch.prototype = {
			start : function() {
				this.value = getCurrentTimeInMs()
			},
			stop : function() {
				return getCurrentTimeInMs() - this.value
			}
		}

		return StopWatch
	}
)

define(
	'spell/data/Tree',
	function() {
		'use strict'


		var getNode = function( currentNode, parentId ) {
			var children = currentNode.children

			if( currentNode.id === parentId ) {
				return currentNode

			} else {
				for( var i = 0, numChildren = children.length; i < numChildren; i++ ) {
					var node = getNode( children[ i ], parentId )

					if( node ) return node
				}
			}
		}

		var addNode = function( currentNode, parentId, newNode ) {
			var parentNode = getNode( currentNode, parentId )

			if( parentNode ) {
				parentNode.children.push( newNode )

				return true
			}

			return false
		}

		var eachNode = function( currentNode, iter, depth ) {
			if( !currentNode ) return
			if( !depth ) depth = 0

			iter( currentNode, depth )

			var children = currentNode.children

			for( var i = 0, numChildren = children.length, nextDepth = depth + 1; i < numChildren; i++ ) {
				eachNode( children[ i ], iter, nextDepth )
			}
		}

		return {
			addNode : addNode,
			getNode : getNode,
			eachNode : eachNode
		}
	}
)

define(
	'spell/shared/util/createMainLoop',
	[
		'spell/data/Tree',
		'spell/shared/util/StopWatch',
		'spell/shared/util/Timer',
		'spell/shared/util/platform/Types',
		'spell/shared/util/platform/PlatformKit',

		'spell/functions'
	],
	function(
		Tree,
		StopWatch,
		Timer,
		Types,
		PlatformKit,

		_
	) {
		'use strict'


		var UPDATE_INTERVAL_IN_MS  = 32,
			MAX_ELAPSED_TIME_IN_MS = 100,
			PERFORMANCE_PRINT_INTERVAL_IN_MS = 10000

		var eachNode = Tree.eachNode

		var indent = function( n ) {
			var result = ''

			while( n-- ) {
				result += ' '
			}

			return result
		}

		var createMetricsMessage = function( tree ) {
			var message = ''

			eachNode(
				tree,
				function( node, depth ) {
					var metrics = node.metrics

					message += indent( depth ) + node.id + ': ' + metrics[ 0 ] + '/' + metrics[ 1 ] + '/' + metrics[ 2 ] + '/' + metrics[ 3 ] + '\n'
				}
			)

			return message
		}

		var callEveryFrameRelease = function( currentTimeInMs ) {
			if( this.preNextFrame.length > 0 ) {
				this.preNextFrame.pop()()
			}

			var timer = this.timer

			timer.update()

			var updateIntervalInMs = this.updateIntervalInMs,
				localTimeInMs      = timer.getLocalTime(),
				elapsedTimeInMs    = Math.min( timer.getElapsedTime(), MAX_ELAPSED_TIME_IN_MS )

			if( this.update ) {
				var accumulatedTimeInMs = this.accumulatedTimeInMs + elapsedTimeInMs

				while( accumulatedTimeInMs >= updateIntervalInMs ) {
					this.update( localTimeInMs, updateIntervalInMs )

					accumulatedTimeInMs -= updateIntervalInMs
				}

				this.accumulatedTimeInMs = accumulatedTimeInMs
			}

			if( this.render ) {
				this.render( localTimeInMs, elapsedTimeInMs )
			}

			PlatformKit.callNextFrame( this.callEveryFramePartial )
		}

		var callEveryFrameDebug = function( currentTimeInMs ) {
			if( this.isPaused ) return

			if( this.preNextFrame.length > 0 ) {
				this.preNextFrame.pop()()
			}

			var statisticsManager = this.statisticsManager,
				timer             = this.timer

			timer.update()

			var updateIntervalInMs = this.updateIntervalInMs,
				localTimeInMs      = timer.getLocalTime(),
				elapsedTimeInMs    = Math.min( timer.getElapsedTime(), MAX_ELAPSED_TIME_IN_MS )

			this.totalStopWatch.start()
			statisticsManager.startTick( localTimeInMs, elapsedTimeInMs )

			if( this.update ) {
				this.stopWatch.start()

				var accumulatedTimeInMs = this.accumulatedTimeInMs + elapsedTimeInMs

				while( accumulatedTimeInMs >= updateIntervalInMs ) {
					this.update( localTimeInMs, updateIntervalInMs )

					accumulatedTimeInMs -= updateIntervalInMs
				}

				this.accumulatedTimeInMs = accumulatedTimeInMs

				statisticsManager.updateNode( 'update', this.stopWatch.stop() )
			}

			if( this.render ) {
				this.stopWatch.start()

				this.render( localTimeInMs, elapsedTimeInMs )

				statisticsManager.updateNode( 'render', this.stopWatch.stop() )
			}

			statisticsManager.updateNode( 'total', this.totalStopWatch.stop() )

			// print performance statistics
			if( this.timeSinceLastPerfPrintInMs > PERFORMANCE_PRINT_INTERVAL_IN_MS ) {
				this.timeSinceLastPerfPrintInMs -= PERFORMANCE_PRINT_INTERVAL_IN_MS

//				console.log(
//					createMetricsMessage( statisticsManager.getMetrics( PERFORMANCE_PRINT_INTERVAL_IN_MS ) )
//				)
			}

			this.timeSinceLastPerfPrintInMs += elapsedTimeInMs

			PlatformKit.callNextFrame( this.callEveryFramePartial )
		}


		var MainLoop = function( eventManager, statisticsManager, isDebug, updateIntervalInMs ) {
			this.isDebug             = isDebug
			this.updateIntervalInMs  = updateIntervalInMs || UPDATE_INTERVAL_IN_MS
			this.render              = null
			this.update              = null
			this.preNextFrame        = []
			this.accumulatedTimeInMs = this.updateIntervalInMs

			// Until the proper remote game time is computed local time will have to do.
			var initialLocalGameTimeInMs = Types.Time.getCurrentInMs()
			this.timer = new Timer( eventManager, statisticsManager, initialLocalGameTimeInMs )

			this.timeSinceLastPerfPrintInMs = 0
			this.statisticsManager = statisticsManager
			this.stopWatch         = new StopWatch()
			this.totalStopWatch    = new StopWatch()
			this.isPaused          = false
		}

		MainLoop.prototype = {
			setRenderCallback : function( f ) {
				this.render = f
			},
			setUpdateCallback : function( f ) {
				this.update = f
			},
			setPreNextFrame: function( f ) {
				this.preNextFrame.push( f )
			},
			run : function() {
				this.callEveryFramePartial = _.bind( this.isDebug ? callEveryFrameDebug : callEveryFrameRelease, this )
				this.callEveryFramePartial( Types.Time.getCurrentInMs() )
			},
			pause : function() {
				this.isPaused = true
			},
			resume : function() {
				this.isPaused = false
			}
		}

		return function( eventManager, statisticsManager, isDebug, updateInterval ) {
			return new MainLoop( eventManager, statisticsManager, isDebug, updateInterval )
		}
	}
)

define(
	'spell/client/showSplashScreen',
	[
		'spell/math/mat3',
		'spell/math/util',
		'spell/math/vec2',
		'spell/math/vec4',
		'spell/shared/util/platform/PlatformKit'
	],
	function(
		mat3,
		mathUtil,
		vec2,
		vec4,
		PlatformKit
	) {
		'use strict'


		var createRGB = function( dataRGBA ) {
			var numPixels = dataRGBA.length / 4,
				dataRGB   = new Array( numPixels * 3 )

			for( var i = 0, srcOffset, dstOffset, n = numPixels; i < n; i ++ ) {
				srcOffset = i * 4
				dstOffset = i * 3

				dataRGB[ dstOffset ]     = dataRGBA[ srcOffset ]
				dataRGB[ dstOffset + 1 ] = dataRGBA[ srcOffset + 1 ]
				dataRGB[ dstOffset + 2 ] = dataRGBA[ srcOffset + 2 ]
			}

			return dataRGB
		}

		return function( spell, next ) {
			var splashScreenImage = PlatformKit.createSplashScreenImage()

			if( splashScreenImage ) {
				var splashTexture = spell.renderingContext.createTexture( splashScreenImage ),
					screenSize    = spell.configurationManager.getValue( 'currentScreenSize' )

				var position = vec2.fromValues(
					Math.round( screenSize[ 0 ] * 0.5 - splashTexture.dimensions[ 0 ] * 0.5 ),
					Math.round( screenSize[ 1 ] * 0.5 - splashTexture.dimensions[ 1 ] * 0.5 )
				)

				var context    = spell.renderingContext,
					tmpMat3    = mat3.create(),
					clearColor = vec4.fromValues( 0, 0, 0, 1 )

				mathUtil.mat3Ortho( tmpMat3, 0.0, screenSize[ 0 ], 0.0, screenSize[ 1 ] )

				context.setViewMatrix( tmpMat3 )
				context.setClearColor( clearColor )
				context.resizeColorBuffer( screenSize[ 0 ], screenSize[ 1 ] )
				context.viewport( 0, 0, screenSize[ 0 ], screenSize [ 1 ] )

				context.drawTexture( splashTexture, position, splashTexture.dimensions, null )

				PlatformKit.registerTimer( next, 3000 )

			} else {
				next()
			}
		}
	}
)

/**
 * @class spell.stringUtil
 * @singleton
 */
define(
	'spell/stringUtil',
	function() {
		'use strict'


		var stringUtil = {}

		stringUtil.startsWith = function( x, prefix ) {
			if( prefix === '' ) return true
			if( !x || !prefix ) return false

			return String( x ).lastIndexOf( String( prefix ), 0 ) === 0
		}

		return stringUtil
	}
)

/**
 * @class spell.recurisveFunctions
 * @singleton
 */
define(
	'spell/recursiveFunctions',
	[
		'spell/functions'
	],
	function(
		_
	) {
		'use strict'


		/**
		 * Performs a recursive walk over all properties of the supplied object. The "object" argument can be either of type object or array. The iterator
		 * argument is called with the arguments "value" and "key" for every property that is encountered on the walk.
		 *
		 * @param {*} object data structure to work on
		 * @param {Function} iterator
		 */
		var walk = function( object, iterator ) {
			for( var key in object ) {
				var value = object[ key ]

				if( _.isObject( value ) ) {
					walk( value, iterator )

				} else {
					iterator( value, key )
				}
			}
		}

		var reduce = function( object, iterator, memo ) {
			var wrapper = function( value, key ) {
				memo = iterator( memo, value, key )
			}

			walk( object, wrapper )

			return memo
		}

		/**
		 * Performs a recursive pluck. All keys of the supplied object argument which are encountered during a recursive walk are checked for their existence
		 * in the properties argument array. If a match is found it is stored in the result array.
		 *
		 * @param {*} object data structure to work on
		 * @param {Array} properties array of strings
		 * @return {Array}
		 */
		var pluck = function( object, properties ) {
			var result = []

			walk(
				object,
				function( key, value ) {
					if( !_.contains( properties, key ) ) return

					result.push( value )
				}
			)

			return result
		}

		return {
			pluck  : pluck,
			reduce : reduce,
			walk   : walk
		}
	}
)

define(
	'spell/client/util/createComprisedRectangle',
	function() {
		'use strict'


		/**
		 * Returns a screen size that has the supplied aspect ratio and comprises the supplied screen dimensions.
		 *
		 * For example:
		 *
		 *   createComprisedRectangle( [ 120, 90 ], 16/9 )
		 *   => [ 160, 90 ]
		 */
		return function( dimensions, requestedAspectRatio, round ) {
			var width              = dimensions[ 0 ],
				height             = dimensions[ 1 ],
				currentAspectRatio = width / height

			if( requestedAspectRatio >= currentAspectRatio ) {
				// screen has additional space left horizontally
				width = requestedAspectRatio * height

			} else {
				// screen has additional space left vertically
				height = width / requestedAspectRatio
			}

			if( round ) {
				width  = Math.round( width )
				height = Math.round( height )
			}

			return [ width, height ]
		}
	}
)

define(
	'spell/client/util/createEffectiveCameraDimensions',
	[
		'spell/client/util/createComprisedRectangle',

		'spell/math/vec2'
	],
	function(
		createComprisedRectangle,

		vec2
	) {
		'use strict'


		return function( cameraWidth, cameraHeight, cameraScale, aspectRatio ) {
			var tmpVec2 = vec2.fromValues( cameraWidth, cameraHeight )

			return vec2.multiply(
				tmpVec2,
				cameraScale,
				createComprisedRectangle( tmpVec2, aspectRatio )
			)
		}
	}
)

define(
	'spell/shared/util/translate',
	function() {
		'use strict'


		return function( assetManager, currentLanguage, translationAssetId, text ) {
			if( !translationAssetId ) return

			var translation = assetManager.get( translationAssetId )
			if( !translation ) return

			var translatedText = translation.config[ text ]
			if( !translatedText ) return

			return translatedText[ currentLanguage ]
		}
	}
)

define(
	'spell/shared/util/createEntityEach',
	[
		'spell/functions'
	],
	function(
		_
	) {
		'use strict'


		return function( primaryComponents, argumentComponents, iterator ) {
			if( !_.isArray( argumentComponents ) ) {
				argumentComponents = [ argumentComponents ]
			}

			return function() {
				var ids    = _.keys( primaryComponents ),
					numIds = ids.length

				for( var i = 0; i < numIds; i++ ) {
					var id = ids[ i ],
						primaryComponent = [ primaryComponents[ id ] ],
						numArgumentComponentsList = argumentComponents.length,
						args = ( arguments ? _.toArray( arguments ).concat( primaryComponent ) : [ primaryComponent ] )

					for( var j = 0; j < numArgumentComponentsList; j++ ) {
						args.push( argumentComponents[ j ][ id ] )
					}

					iterator.apply( null, args )
				}
			}
		}
	}
)

/**
 * @license
 * @preserve
 *
 * The MIT License
 *
 * Copyright (c) 2010-2012 Tween.js authors.
 *
 * Easing equations Copyright (c) 2001 Robert Penner http://robertpenner.com/easing/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

define(
	'spell/shared/Easing',
	[
		'spell/functions'
	],
	function(
		_
	) {
		'use strict'


		var none = function( k ) {
			return k < 1.0 ? 0.0 : 1.0
		}

		var Easing = {
			// None
			None : none,

			// Linear
			Linear : _.identity,

			// Quadratic
			QuadraticIn : function( k ) {
				return k * k
			},
			QuadraticOut : function( k ) {
				return k * ( 2 - k )
			},
			QuadraticInOut : function( k ) {
				if ( ( k *= 2 ) < 1 ) return 0.5 * k * k
				return - 0.5 * ( --k * ( k - 2 ) - 1 )
			},

			// Cubic
			CubicIn : function( k ) {
				return k * k * k
			},
			CubicOut : function( k ) {
				return --k * k * k + 1
			},
			CubicInOut : function( k ) {
				if ( ( k *= 2 ) < 1 ) return 0.5 * k * k * k
				return 0.5 * ( ( k -= 2 ) * k * k + 2 )
			},

			// Quartic
			QuarticIn : function( k ) {
				return k * k * k * k
			},
			QuarticOut : function( k ) {
				return 1 - --k * k * k * k
			},
			QuarticInOut : function( k ) {
				if ( ( k *= 2 ) < 1) return 0.5 * k * k * k * k
				return - 0.5 * ( ( k -= 2 ) * k * k * k - 2 )
			},

			// Quintic
			QuinticIn : function( k ) {
				return k * k * k * k * k
			},
			QuinticOut : function( k ) {
				return --k * k * k * k * k + 1
			},
			QuinticInOut : function( k ) {
				if ( ( k *= 2 ) < 1 ) return 0.5 * k * k * k * k * k
				return 0.5 * ( ( k -= 2 ) * k * k * k * k + 2 )
			},

			// Sinusoidal
			SinusoidalIn : function( k ) {
				return 1 - Math.cos( k * Math.PI / 2 )
			},
			SinusoidalOut : function( k ) {
				return Math.sin( k * Math.PI / 2 )
			},
			SinusoidalInOut : function( k ) {
				return 0.5 * ( 1 - Math.cos( Math.PI * k ) )
			},

			// Exponential
			ExponentialIn : function( k ) {
				return k === 0 ? 0 : Math.pow( 1024, k - 1 )
			},
			ExponentialOut : function( k ) {
				return k === 1 ? 1 : 1 - Math.pow( 2, - 10 * k )
			},
			ExponentialInOut : function( k ) {
				if ( k === 0 ) return 0
				if ( k === 1 ) return 1
				if ( ( k *= 2 ) < 1 ) return 0.5 * Math.pow( 1024, k - 1 )
				return 0.5 * ( - Math.pow( 2, - 10 * ( k - 1 ) ) + 2 )
			},

			// Circular
			CircularIn : function( k ) {
				return 1 - Math.sqrt( 1 - k * k )
			},
			CircularOut : function( k ) {
				return Math.sqrt( 1 - --k * k )
			},
			CircularInOut : function( k ) {
				if ( ( k *= 2 ) < 1) return - 0.5 * ( Math.sqrt( 1 - k * k) - 1)
				return 0.5 * ( Math.sqrt( 1 - ( k -= 2) * k) + 1)
			},

			// Elastic
			ElasticIn : function( k ) {
				var s, a = 0.1, p = 0.4
				if ( k === 0 ) return 0
				if ( k === 1 ) return 1
				if ( !a || a < 1 ) { a = 1; s = p / 4; }
				else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI )
				return - ( a * Math.pow( 2, 10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) )
			},
			ElasticOut : function( k ) {
				var s, a = 0.1, p = 0.4
				if ( k === 0 ) return 0
				if ( k === 1 ) return 1
				if ( !a || a < 1 ) { a = 1; s = p / 4; }
				else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI )
				return ( a * Math.pow( 2, - 10 * k) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) + 1 )
			},
			ElasticInOut : function( k ) {
				var s, a = 0.1, p = 0.4
				if ( k === 0 ) return 0
				if ( k === 1 ) return 1
				if ( !a || a < 1 ) { a = 1; s = p / 4; }
				else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI )
				if ( ( k *= 2 ) < 1 ) return - 0.5 * ( a * Math.pow( 2, 10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) )
				return a * Math.pow( 2, -10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) * 0.5 + 1
			},

			// Back
			BackIn : function( k ) {
				var s = 1.70158
				return k * k * ( ( s + 1 ) * k - s )
			},
			BackOut : function( k ) {
				var s = 1.70158
				return --k * k * ( ( s + 1 ) * k + s ) + 1
			},
			BackInOut : function( k ) {
				var s = 1.70158 * 1.525
				if ( ( k *= 2 ) < 1 ) return 0.5 * ( k * k * ( ( s + 1 ) * k - s ) )
				return 0.5 * ( ( k -= 2 ) * k * ( ( s + 1 ) * k + s ) + 2 )
			},

			// Bounce
			BounceIn : function( k ) {
				return 1 - Easing.BounceOut( 1 - k )
			},
			BounceOut : function( k ) {
				if ( k < ( 1 / 2.75 ) ) {
					return 7.5625 * k * k

				} else if ( k < ( 2 / 2.75 ) ) {
					return 7.5625 * ( k -= ( 1.5 / 2.75 ) ) * k + 0.75

				} else if ( k < ( 2.5 / 2.75 ) ) {
					return 7.5625 * ( k -= ( 2.25 / 2.75 ) ) * k + 0.9375

				} else {
					return 7.5625 * ( k -= ( 2.625 / 2.75 ) ) * k + 0.984375
				}
			},
			BounceInOut : function( k ) {
				if ( k < 0.5 ) return Easing.BounceIn( k * 2 ) * 0.5
				return Easing.BounceOut( k * 2 - 1 ) * 0.5 + 0.5
			}
		}

		return Easing
	}
)

/**
 * UUID.core.js: The minimal subset of the RFC-compliant UUID generator UUID.js.
 *
 * author:  LiosK
 * version: core-1.0
 * license: The MIT License: Copyright (c) 2012 LiosK.
 *
 * @private
 */
define(
	'spell/math/random/UUID',
	function() {
		'use strict'


		/**
		 * Returns an unsigned x-bit random integer (0 <= f(x) < 2^x).
		 *
		 * @private
		 * @param {Number} x A positive integer ranging from 0 to 53, inclusive.
		 * @returns {Number}
		 */
		var getRandomInt = function(x) {
			if (x <   0) return NaN;
			if (x <= 30) return (0 | Math.random() * (1 <<      x));
			if (x <= 53) return (0 | Math.random() * (1 <<     30))
				+ (0 | Math.random() * (1 << x - 30)) * (1 << 30);
			return NaN;
		};

		/**
		 * Converts an integer to a zero-filled hexadecimal string.
		 *
		 * @private
		 * @param {Number} num
		 * @param {Number} length
		 * @returns {String}
		 */
		var hex = function(num, length) {
			var str = num.toString(16), i = length - str.length, z = "0";
			for (; i > 0; i >>>= 1, z += z) { if (i & 1) { str = z + str; } }
			return str;
		};


		/**
		 * Enables the generation of UUIDs. See http://en.wikipedia.org/wiki/Universally_unique_identifier.
		 *
		 * @class spell.math.random.UUID
		 * @constructor
		 */
		var UUID = function() {}

		/**
		 * Generates an UUID string.
		 *
		 * @returns {String}
		 */
		UUID.generate = function() {
			return  hex(getRandomInt(32), 8)        // time_low
				+ "-"
				+ hex(getRandomInt(16), 4)          // time_mid
				+ "-"
				+ hex(0x4000 | getRandomInt(12), 4) // time_hi_and_version
				+ "-"
				+ hex(0x8000 | getRandomInt(14), 4) // clock_seq_hi_and_reserved clock_seq_low
				+ "-"
				+ hex(getRandomInt(48), 12);        // node
		};

		return UUID
	}
)

define(
	'spell/math/random/ShuffledSet',
	function() {
		'use strict'


		var swap = function( values, i, j ) {
		    var x = values[ j ]

		    values[ j ] = values[ i ]
		    values[ i ] = x
		}

		/**
		 * Shuffles the supplied values. Uses the Fisher-Yates shuffling algorithm.
		 *
		 * @param prng the pseudo random number generator to use
		 * @param values the values to shuffle
		 * @constructor
		 */
		var ShuffledSet = function( prng, values ) {
		    this.prng = prng
		    this.values = values.slice()
		    this.lastNotYetChosenIndex = this.values.length - 1
		}

		ShuffledSet.prototype = {
		    next : function() {
		        var lastNotYetChosenIndex = this.lastNotYetChosenIndex
		        if( lastNotYetChosenIndex < 0 ) return

		        var values = this.values,
		            index  = Math.floor( this.prng.nextBetween( 0, lastNotYetChosenIndex ) ),
		            x      = values[ index ]

		        swap( values, index, lastNotYetChosenIndex )

		        this.lastNotYetChosenIndex--

		        return x
		    }
		}

		return ShuffledSet
	}
)

define(
	'spell/data/spatial/QuadTree',
	function() {
		'use strict'


		var contains = function( boundA, boundB ) {
			return boundA[ 0 ] <= boundB[ 0 ] &&
				boundA[ 1 ] > boundB[ 1 ] &&
				boundA[ 2 ] <= boundB[ 2 ] &&
				boundA[ 3 ] > boundB[ 3 ]
		}

		var intersect = function( boundA, boundB ) {
			return boundA[ 0 ] <= boundB[ 1 ] &&
				boundB[ 0 ] < boundA[ 1 ] &&
				boundA[ 2 ] <= boundB[ 3 ] &&
				boundB[ 2 ] < boundA[ 3 ]
		}

		var split = function( node ) {
			var bound    = node.bound,
				left     = bound[ 0 ],
				right    = bound[ 1 ],
				bottom   = bound[ 2 ],
				top      = bound[ 3 ],
				centerX  = ( left + right ) * 0.5,
				centerY  = ( bottom + top ) * 0.5,
				children = node.children

			children[ 0 ] = createTreeNode( node, [ centerX, right, centerY, top ] )
			children[ 1 ] = createTreeNode( node, [ left, centerX, centerY, top ] )
			children[ 2 ] = createTreeNode( node, [ left, centerX, bottom, centerY ] )
			children[ 3 ] = createTreeNode( node, [ centerX, right, bottom, centerY ] )
		}

		var unite = function( node ) {
			var children = node.children

			children[ 0 ].parent = undefined
			children[ 0 ] = undefined

			children[ 1 ].parent = undefined
			children[ 1 ] = undefined

			children[ 2 ].parent = undefined
			children[ 2 ] = undefined

			children[ 3 ].parent = undefined
			children[ 3 ] = undefined
		}

		var insert = function( idToNode, root, item ) {
			var node = insertR( root, item, item.bound ),
				id   = item.id

			if( !node ) {
				throw 'Could not insert item ' + id ? ' with id "' + id + '" ' : '' + 'because it is not contained in the space covered by the tree.'
			}

			if( id ) {
				idToNode[ id ] = node
			}
		}

		var insertR = function( node, item, itemBound ) {
			if( !contains( node.bound, itemBound ) ) return

			var children = node.children

			if( !children[ 0 ] ) {
				split( node )
			}

			for( var i = 0, success; i < 4; i++ ) {
				success = insertR( children[ i ], item, itemBound )

				if( success ) {
					node.numDescendantItems++

					return success
				}
			}

			if( !success ) {
				node.items[ item.id ] = item

				return node
			}
		}

		var remove = function( node, id ) {
			delete node.items[ id ]

			var parent = node.parent

			while( parent ) {
				parent.numDescendantItems--

				if( parent.numDescendantItems === 0 ) {
					unite( parent )
				}

				parent = parent.parent
			}
		}

		var searchItems = function( node, searchBound, result ) {
			// check the nodes' items
			var items  = node.items

			for( var id in items ) {
				var item      = items[ id ],
					itemBound = item.bound

				if( contains( itemBound, searchBound ) ||
					contains( searchBound, itemBound ) ||
					intersect( searchBound, itemBound ) ) {

					result[ id ] = item.payload
				}
			}

			// check the nodes' children
			var children = node.children

			if( !children[ 0 ] ) return

			for( var i = 0; i < 4; i++ ) {
				var child      = children[ i ],
					childBound = child.bound

				if( contains( searchBound, childBound ) ) {
					// add all descendant items of branch to the result set
					getAllItems( child, result )

				} else if( contains( childBound, searchBound ) ) {
					// search further down this branch and skip the other branches
					searchItems( child, searchBound, result )

					break

				} else if( intersect( childBound, searchBound ) ) {
					// search further down this branch
					searchItems( child, searchBound, result )
				}
			}
		}

		var getAllItems = function( node, result ) {
			// add nodes' items
			var items = node.items

			for( var id in items ) {
				result[ id ] = items[ id ].payload
			}

			// add childrens' items
			var children = node.children
			if( !children[ 0 ] ) return

			for( var i = 0; i < 4; i++ ) {
				getAllItems( children[ i ], result )
			}
		}

		var createBound = function( position, dimensions ) {
			var halfWidth  = dimensions[ 0 ] * 0.5,
				halfHeight = dimensions[ 1 ] * 0.5

			return [
				position[ 0 ] - halfWidth,  // left
				position[ 0 ] + halfWidth,  // right
				position[ 1 ] - halfHeight, // bottom
				position[ 1 ] + halfHeight  // top
			]
		}

		var createTreeNode = function( parent, bound ) {
			return {
				parent : parent,
				children : new Array( 4 ),
				bound : bound,
				items : {},
				numDescendantItems : 0
			}
		}

		var createItem = function( size, position, dimensions, payload, id ) {
			// HACK: this is necessary in order to support entities which do not have a dimensions
			if( !dimensions ) {
				position = [ 0, 0 ]
				dimensions = [ size - 1, size - 1 ]
			}

			return {
				id : id,
				bound : createBound( position, dimensions ),
				payload : payload
			}
		}


		var QuadTree = function( size ) {
			this.idToNode = {}
			this.size = size
			this.root = createTreeNode(
				null,
				createBound( [ 0, 0 ], [ size, size ] )
			)
		}

		QuadTree.prototype = {
			insert : function( position, dimensions, payload, id ) {
				if( id &&
					this.idToNode[ id ] ) {

					throw 'The provided id "' + id + '" is already in use.'
				}

				insert(
					this.idToNode,
					this.root,
					createItem( this.size, position, dimensions, payload, id )
				)
			},
			remove : function( id ) {
				var node = this.idToNode[ id ]
				if( !node ) return

				remove( node, id )

				delete this.idToNode[ id ]
			},
			search : function( position, dimensions ) {
				var result = {}

				searchItems(
					this.root,
					createBound( position, dimensions ),
					result
				)

				return result
			}
		}

		return QuadTree
	}
)

define(
	'spell/client/util/createIncludedRectangle',
	function() {
		'use strict'


		/**
		 * Returns a screen size that has the supplied aspect ratio and includes the supplied screen dimensions.
		 *
		 * For example:
		 *
		 *   createIncludedRectangle( [ 120, 90 ], 16/9 )
		 *   => [ 120, 67.5 ]
		 */
		return function( dimensions, requestedAspectRatio, round ) {
			var width              = dimensions[ 0 ],
				height             = dimensions[ 1 ],
				currentAspectRatio = width / height

			if( requestedAspectRatio <= currentAspectRatio ) {
				// screen has additional space left horizontally
				width = requestedAspectRatio * height

			} else {
				// screen has additional space left vertically
				height = width / requestedAspectRatio
			}

			if( round ) {
				width  = Math.round( width )
				height = Math.round( height )
			}

			return [ width, height ]
		}
	}
)

define(
	'spell/client/2d/graphics/drawTitleSafeOutline',
	[
		'spell/client/util/createIncludedRectangle',

		'spell/math/util',
		'spell/math/mat3',
		'spell/math/vec2'
	],
	function(
		createIncludedRectangle,


		mathUtil,
		mat3,
		vec2
	) {
		'use strict'


		var tmpMat3 = mat3.identity( mat3.create() ),
			tmp     = vec2.create()

		var drawRect = function( context, dx, dy, width, height, lineWidth ) {
			if( !lineWidth || lineWidth < 0 ) {
				lineWidth = 1
			}

			var doubledLineWidth = lineWidth * 2

			context.save()
			{
				// horizontal
				context.fillRect( dx, dy, width, lineWidth )
				context.fillRect( dx, dy + height - lineWidth, width, lineWidth )

				// vertical
				context.fillRect( dx, dy + lineWidth, lineWidth, height - doubledLineWidth )
				context.fillRect( dx + width - lineWidth, dy + lineWidth, lineWidth, height - doubledLineWidth )
			}
			context.restore()
		}


		return function( context, screenSize, cameraDimensions, cameraTransform ) {
			var scale                     = cameraTransform.scale,
				color                     = [ 1, 0, 1, 1 ],
				scaledCameraDimensions    = vec2.multiply( tmp, cameraDimensions, scale ),
				cameraAspectRatio         = scaledCameraDimensions[ 0 ] / scaledCameraDimensions[ 1 ],
				effectiveCameraDimensions = createIncludedRectangle( screenSize, cameraAspectRatio )

			var translation = vec2.scale(
				tmp,
				vec2.subtract( tmp, screenSize, effectiveCameraDimensions ),
				0.5
			)

			context.save()
			{
				// world to view matrix
				mathUtil.mat3Ortho( tmpMat3, 0, screenSize[ 0 ], 0, screenSize[ 1 ] )
				mat3.translate( tmpMat3, tmpMat3, translation )

				context.setViewMatrix( tmpMat3 )

				context.setColor( color )
				drawRect( context, 0, 0, effectiveCameraDimensions[ 0 ], effectiveCameraDimensions[ 1 ], 2 )
			}
			context.restore()
		}
	}
)

define(
	'spell/client/2d/graphics/drawText',
	[
		'spell/math/vec2'
	],
	function(
		vec2
	) {
		'use strict'


		var sourcePosition      = vec2.create(),
			destinationPosition = vec2.create(),
			dimensions          = vec2.create()

		/**
		 * Draws a character on a context.
		 *
		 * @param context
		 * @param texture
		 * @param charData
		 * @param dx
		 * @param dy
		 * @param spacing the actual spacing to be used
		 * @param fontMapHSpacing the fake horizontal spacing introduced by the font map
		 * @param fontMapVSpacing the fake vertical spacing introduced by the font map
		 */
		var drawCharacter = function( context, texture, charData, dx, dy, spacing, fontMapHSpacing, fontMapVSpacing ) {
			sourcePosition[ 0 ] = charData.x - fontMapHSpacing
			sourcePosition[ 1 ] = charData.y

			destinationPosition[ 0 ] = dx - fontMapHSpacing
			destinationPosition[ 1 ] = dy - fontMapVSpacing

			dimensions[ 0 ] = charData.width + fontMapHSpacing * 2
			dimensions[ 1 ] = charData.height + fontMapVSpacing * 2

			context.drawSubTexture(
				texture,
				sourcePosition,
				dimensions,
				destinationPosition,
				dimensions
			)

			return charData.width + spacing + fontMapHSpacing
		}

		var calculateAlignPosition = function( text, fontAsset, align, spacing ) {
			spacing = fontAsset.config.hSpacing + spacing
			if( !align ) return 0

			var width         = 0,
				numCharacters = text.length,
				charset       = fontAsset.config.charset

			if( align === 'left' ) return width
			if( align === 'right' ) return width

			if( align === 'center' ) {
				for( var i = 0; i < numCharacters; i++ ) {
					var charData = charset[ text.charAt( i ) ]

					// in case of unsupported character perform a fallback
					if( !charData ) {
						charData = charset[ ' ' ]
					}

					width += charData.width + spacing
				}

				return width * 0.5
			}
		}

		return function( context, fontAsset, fontTexture, dx, dy, text, spacing, align ) {
			spacing = spacing || 0
			text    = text.toString()
			dx      = dx - calculateAlignPosition( text, fontAsset, align, spacing )

			var numCharacters   = text.length,
				charset         = fontAsset.config.charset,
				fontMapHSpacing = fontAsset.config.hSpacing,
				fontMapVSpacing = fontAsset.config.vSpacing

			for( var i = 0; i < numCharacters; i++ ) {
				var charData = charset[ text.charAt( i ) ]

				// in case of unsupported character perform a fallback
				if( !charData ) {
					charData = charset[ ' ' ]
				}

				dx += drawCharacter( context, fontTexture, charData, dx, dy, spacing, fontMapHSpacing, fontMapVSpacing )
			}
		}
    }
)

define(
	'spell/client/2d/graphics/drawCoordinateGrid',
	[
		'spell/client/2d/graphics/drawText',

		'spell/math/util',
		'spell/math/vec2',
		'spell/math/vec4',
		'spell/math/mat3'
	],
	function(
		drawText,

		mathUtil,
		vec2,
		vec4,
		mat3
	) {
		'use strict'


		var tmpMat3         = mat3.identity( mat3.create() ),
			invScale        = vec2.create(),
			lineOpacity     = 0.5,
			paleLineColor   = vec4.fromValues( 0.4, 0.4, 0.4, lineOpacity ),
			brightLineColor = vec4.fromValues( 0.7, 0.7, 0.7, lineOpacity ),
			XAxisColor      = vec4.fromValues( 0.0, 0.0, 0.7, lineOpacity ),
			YAxisColor      = vec4.fromValues( 0.0, 0.7, 0.0, lineOpacity )

		var computeGridLineStepSize = function( s ) {
		    var log = Math.log( s ) / Math.log( 10 )
		    var exp = Math.round( log )

		    return Math.pow( 10, exp - 1 )
		}

		var computeGridStart = function( value, stepSize ) {
			var rest = value % stepSize

			return ( rest !== 0 ?
				( value > 0 ?
					value - rest + stepSize :
					value - rest
				) :
				value
			)
		}

		var computeNumLines = function( range, stepSize ) {
			return Math.floor( range / stepSize )
		}

		var drawGridLinesY = function( context, fontAsset, fontTexture, height, stepSize, startX, y, invScale, worldToScreenTranslation, numLines ) {
			var nextStepSize = stepSize * 10,
				scaledY = Math.round( ( y + worldToScreenTranslation[ 1 ] ) * invScale ),
				scaledX,
				x

			for( var i = 0; i <= numLines; i++ ) {
				x = ( startX + i * stepSize )
				scaledX = Math.round( ( x + worldToScreenTranslation[ 0 ] ) * invScale )

				// determining the color
				context.setColor(
					( x === 0 ?
						YAxisColor :
						( x % nextStepSize === 0 ?
							brightLineColor :
							paleLineColor
						)
					)
				)

				// draw line
				context.fillRect( scaledX, scaledY, 1, height )

				// draw label
				drawText( context, fontAsset, fontTexture, scaledX + 3, scaledY, x )
			}
		}

		var drawGridLinesX = function( context, fontAsset, fontTexture, width, stepSize, startY, x, invScale, worldToScreenTranslation, numLines ) {
			var nextStepSize = stepSize * 10,
				scaledX = Math.round( ( x + worldToScreenTranslation[ 0 ] ) * invScale ),
				scaledY,
				y

			for( var i = 0; i <= numLines; i++ ) {
				y = ( startY + i * stepSize )
				scaledY = Math.round( ( y + worldToScreenTranslation[ 1 ] ) * invScale )

				// determining the color
				context.setColor(
					( y === 0 ?
						XAxisColor :
						( y % nextStepSize === 0 ?
							brightLineColor :
							paleLineColor
						)
					)
				)

				// draw line
				context.fillRect( scaledX, scaledY, width, 1 )

				// draw label
				drawText( context, fontAsset, fontTexture, scaledX + 3, scaledY, y )
			}
		}

		return function( context, fontAsset, screenSize, cameraDimensions, cameraTransform ) {
			var position     = cameraTransform.translation,
				cameraWidth  = cameraDimensions[ 0 ],
				cameraHeight = cameraDimensions[ 1 ],
				minX         = position[ 0 ] - cameraWidth / 2,
				minY         = position[ 1 ] - cameraHeight / 2,
				maxX         = minX + cameraWidth,
				maxY         = minY + cameraHeight,
				stepSize     = computeGridLineStepSize( cameraWidth ),
				worldToScreenTranslation = [ -minX, -minY ],
				fontTexture  = fontAsset.resource

			vec2.divide( invScale, screenSize, cameraDimensions )

			context.save()
			{
				// world to view matrix
				mathUtil.mat3Ortho( tmpMat3, 0, screenSize[ 0 ], 0, screenSize[ 1 ] )

				context.setViewMatrix( tmpMat3 )

				// grid lines parallel to y-axis
				drawGridLinesY(
					context,
					fontAsset,
					fontTexture,
					screenSize[ 1 ],
					stepSize,
					computeGridStart( minX, stepSize ),
					minY,
					invScale[ 1 ],
					worldToScreenTranslation,
					computeNumLines( cameraWidth, stepSize )
				)

				// grid lines parallel to x-axis
				drawGridLinesX(
					context,
					fontAsset,
					fontTexture,
					screenSize[ 0 ],
					stepSize,
					computeGridStart( minY, stepSize ),
					minX,
					invScale[ 0 ],
					worldToScreenTranslation,
					computeNumLines( cameraHeight, stepSize )
				)
			}
			context.restore()
		}
	}
)

define(
	'spell/client/2d/graphics/physics/drawOrigin',
	function() {
		'use strict'


		return function( context, scale ) {
			if( !scale ) scale = 1

			context.drawLine( -scale, -scale, scale, scale )
			context.drawLine( -scale, scale, scale, -scale )
		}
	}
)

define(
	'spell/client/2d/graphics/physics/drawPoint',
	function() {
		'use strict'


		return function( context, scale ) {
			if( !scale ) scale = 1

			var a = 2 * scale,
				halfA = a * 0.5

			context.fillRect( -halfA, -halfA, a, a )
		}
	}
)

define(
	'spell/client/2d/graphics/physics/drawCircle',
	function() {
		'use strict'


		return function( context, radius, color, lineWidth ) {
			var negHalfRadius = radius * -0.5

			context.setLineColor( color )
			context.drawCircle( 0, 0, radius, lineWidth )
			context.drawLine( radius, 0, radius * 0.618, 0, lineWidth )
		}
	}
)

define(
	'spell/client/2d/graphics/physics/drawBox',
	function() {
		'use strict'


		return function( context, width, height, color, lineWidth ) {
			var halfWidth  = width * 0.5,
				halfHeight = height * 0.5

			context.setLineColor( color )
			context.drawRect( -halfWidth, -halfHeight, width, height, lineWidth )
			context.drawLine( halfWidth * 0.618, 0, halfWidth, 0, lineWidth )
		}
	}
)

define(
	'spell/client/2d/graphics/drawShape',
	function() {
		'use strict'


		return {
			rectangle : function( context, shape ) {
				var width         = shape.width,
					height        = shape.height,
					negHalfWidth  = width * -0.5,
					negHalfHeight = height * -0.5

				if( shape.fill ) {
					context.setColor( shape.fillColor )
					context.fillRect( negHalfWidth, negHalfHeight, width, height )
				}

				context.setLineColor( shape.lineColor )
				context.drawRect( negHalfWidth, negHalfHeight, width, height, shape.lineWidth )
			}
		}
	}
)

/**
 * This module acts as a static include list for modules that must be included in the engine library even though they are not used by the engine itself. This is
 * the case for certain math modules or similar modules which are useful for end users/developers.
 */

define(
	'spell/client/staticInclude',
	[
		'spell/client/2d/graphics/drawShape',
		'spell/client/2d/graphics/physics/drawBox',
		'spell/client/2d/graphics/physics/drawCircle',
		'spell/client/2d/graphics/physics/drawPoint',
		'spell/client/2d/graphics/physics/drawOrigin',
		'spell/client/2d/graphics/drawCoordinateGrid',
		'spell/client/2d/graphics/drawTitleSafeOutline',
		'spell/data/spatial/QuadTree',
		'spell/math/mat2',
		'spell/math/mat2d',
		'spell/math/mat3',
		'spell/math/mat4',
		'spell/math/quat',
		'spell/math/util',
		'spell/math/vec2',
		'spell/math/vec3',
		'spell/math/vec4',
		'spell/math/random/ShuffledSet',
		'spell/math/random/UUID',
		'spell/math/random/XorShift32',
		'spell/shared/Easing',
		'spell/shared/util/createEntityEach',
		'spell/shared/util/input/keyCodes',
		'spell/shared/util/translate',
		'spell/client/util/createEffectiveCameraDimensions',
		'spell/client/util/createIncludedRectangle',
		'spell/recursiveFunctions',
		'spell/stringUtil'
	],
	function() {
		return undefined
	}
)

/**
 * This module is overwritten during the debug build process.
 */

define(
	'spell/client/isDebug',
	function() {
		'use strict'


		return false
	}
)

define(
	'spell/client/development/createSystemMessageHandler',
	[
		'spell/client/development/createMessageDispatcher',
		'spell/shared/util/createId'
	],
	function(
		createMessageDispatcher,
		createId
	) {
		'use strict'


		return function( spell ) {
			return createMessageDispatcher( {
				add : function( payload ) {
					spell.sceneManager.addSystem( payload.systemId, payload.executionGroupId, payload.index, payload.systemConfig )
				},
				move : function( payload ) {
					spell.sceneManager.moveSystem( payload.systemId, payload.srcExecutionGroupId, payload.dstExecutionGroupId, payload.dstIndex )
				},
				remove : function( payload ) {
					spell.sceneManager.removeSystem( payload.systemId, payload.executionGroupId )
				},
				update : function( payload ) {
					var definition = payload.definition

					if( !definition.namespace || !definition.name ) {
						throw 'Error: System definition is missing namespace and or name attribute.'
					}

					var libraryId = createId( definition.namespace, definition.name )

					var metaDataCache = {}

					metaDataCache[ libraryId ] = definition

					spell.libraryManager.addToCache( metaDataCache )

					spell.sceneManager.restartSystem( libraryId, payload.executionGroupId, payload.systemConfig )
				}
			} )
		}
	}
)

define(
	'spell/client/development/createSettingsMessageHandler',
	[
		'spell/client/development/createMessageDispatcher'
	],
	function(
		createMessageDispatcher
	) {
		'use strict'


		return function( spell ) {
			return createMessageDispatcher( {
				drawCoordinateGrid : function( payload ) {
					spell.configurationManager.setValue( 'drawCoordinateGrid', payload )
				},
				drawTitleSafeOutline : function( payload ) {
					spell.configurationManager.setValue( 'drawTitleSafeOutline', payload )
				},
				setScreenMode : function( payload ) {
					spell.configurationManager.setValue( 'screenMode', payload )
				},
				simulateScreenAspectRatio : function( payload ) {
					spell.configurationManager.setValue( 'screenAspectRatio', payload.aspectRatio )
				}
			} )
		}
	}
)

define(
	'spell/client/setApplicationModule',
    [
        'spell/functions'
    ],
	function(
        _
    ) {
		'use strict'


		return function( spell, configurationManager, target, applicationModule, loaderConfig ) {
			if( !applicationModule ) {
				throw 'Error: Missing application module. Please provide a application module.'
			}

			var applicationConfig = applicationModule.config,
				targetConfig      = applicationConfig[ target ]

			if( !targetConfig ) {
				throw 'Error: The application config does not include configuration for the target "' + target + '".'
			}

			spell.applicationModule = applicationModule

			// TODO: move all general configuration options below a common parent attribute (i.e. "general") in the project.json
			var generalConfig = _.pick(
				applicationModule.config,
				'screenSize',
				'screenMode',
				'orientation',
				'loadingScene',
				'projectId',
				'version',
				'quadTreeSize',
				'defaultLanguage',
				'qualityLevels',
				'supportedLanguages'
			)

            // config precedence: loader config > target config > general config
			configurationManager.setConfig( _.extend( generalConfig, targetConfig, loaderConfig ) )
		}
	}
)

define(
	'spell/client/development/createApplicationMessageHandler',
	[
		'spell/client/setApplicationModule',
		'spell/client/development/createMessageDispatcher'
	],
	function(
		setApplicationModule,
		createMessageDispatcher
	) {
		'use strict'


		return function( spell, startEngine ) {
			return createMessageDispatcher( {
				/**
				 * Starts the application module. Used in standalone development mode.
				 *
				 * @param payload
				 */
				startApplicationModule : function( payload ) {
					startEngine( payload.applicationModule )
				},

				/**
				 * Sets the application module. Used in embedded development mode.
				 *
				 * @param payload
				 */
				setApplicationModule : function( payload ) {
                    setApplicationModule(
                        spell,
                        spell.configurationManager,
                        payload.applicationModule,
                        payload.applicationModule.config,
                        spell.loaderConfig
                    )
				},

				/**
				 * Adds entries to the library cache. Used in embedded development mode.
				 *
				 * @param payload
				 */
				addToCache : function( payload ) {
					spell.libraryManager.addToCache( payload.cacheContent )
				},

				/**
				 * Starts a scene. Used in embedded development mode.
				 *
				 * @param payload
				 */
				startScene : function( payload ) {
					spell.sceneManager.startScene( payload.targetSceneId, payload.initialConfig, payload.showLoadingScene )
				}
			} )
		}
	}
)

/*
 * @class spell.shared.util.platform.PlatformKit
 * @singleton
 */
define(
	'spell/shared/util/platform/PlatformKit',
	[
		'spell/shared/util/createAssetId',
		'spell/shared/util/platform/private/Application',
		'spell/shared/util/platform/private/Box2D',
		'spell/shared/util/platform/private/callNextFrame',
		'spell/shared/util/platform/private/createHost',
		'spell/shared/util/platform/private/jsonCoder',
		'spell/shared/util/platform/private/network/createSocket',
		'spell/shared/util/platform/private/network/performHttpRequest',
		'spell/shared/util/platform/private/getAvailableScreenSize',
		'spell/shared/util/platform/private/ModuleLoader',
		'spell/shared/util/platform/private/graphics/RenderingFactory',
		'spell/shared/util/platform/private/graphics/createSplashScreenImage',
		'spell/shared/util/platform/private/sound/AudioFactory',
		'spell/shared/util/platform/private/registerTimer',
		'spell/shared/util/platform/private/loader/ImageLoader',
		'spell/shared/util/platform/private/loader/SoundLoader',
		'spell/shared/util/platform/private/loader/TextLoader',
		'spell/shared/util/platform/private/input/support',
		'spell/shared/util/platform/private/Input',
		'spell/shared/util/platform/private/Environment',
		'spell/shared/util/platform/private/configurationOptions',
		'spell/shared/util/platform/private/storage/PersistentStorage',
		'spell/shared/util/platform/private/openURL',
		'spell/shared/util/platform/private/platformDetails',
		'spell/shared/util/platform/private/graphics/initViewport',
		'spell/shared/util/platform/private/advertisement',
		'spell/shared/util/platform/private/flurry',
		'spell/shared/util/platform/private/createComponentType',
		'spell/shared/util/platform/private/environment/isHtml5Ejecta',
		'spell/shared/util/platform/private/environment/isHtml5GameClosure',
		'spell/functions'
	],
	function(
		createAssetId,
		Application,
		Box2D,
		callNextFrame,
		createHost,
		jsonCoder,
		createSocket,
		performHttpRequest,
		getAvailableScreenSize,
		ModuleLoader,
		RenderingFactory,
		createSplashScreenImage,
		AudioFactory,
		registerTimer,
		ImageLoader,
		SoundLoader,
		TextLoader,
		support,
		Input,
		Environment,
		configurationOptions,
		PersistentStorage,
		openURL,
		platformDetails,
		initViewport,
		advertisement,
		flurry,
		createComponentType,
		isHtml5Ejecta,
		isHtml5GameClosure,
		_
	) {
		'use strict'


		var getHost = function() {
			return createHost()
		}

		var createInput = function( configurationManager, renderingContext ) {
			return new Input( configurationManager, renderingContext )
		}

		var createEnvironment = function( configurationManager, eventManager ) {
			var environment = new Environment( configurationManager, eventManager )

			environment.init()

			return environment
		}

		return {
			/*
			 *
			 */
			Box2D : Box2D,

			/*
			 *
			 */
			callNextFrame : callNextFrame,

			/*
			 *
			 */
			registerTimer : registerTimer,

			/*
			 *
			 */
			network : {
				createSocket : createSocket,
				performHttpRequest : performHttpRequest
			},

			/*
			 *
			 */
			AudioFactory : AudioFactory,

			/*
			 *
			 */
			RenderingFactory : RenderingFactory,

			/*
			 *
			 */
			getHost : getHost,

			/*
			 *
			 */
			ModuleLoader : ModuleLoader,

			/*
			 *
			 */
			configurationOptions : configurationOptions,

			/*
			 *
			 */
			platformDetails : platformDetails,

			/*
			 *
			 */
			jsonCoder : jsonCoder,

			/*
			 *
			 */
			createInput : createInput,

			/*
			 *
			 */
			createEnvironment : createEnvironment,

			/*
			 *
			 */
			getAvailableScreenSize : getAvailableScreenSize,

			openURL : openURL,

			createPersistentStorage : function() {
				return new PersistentStorage()
			},

			createImageLoader : function( renderingContext, assetManager, libraryId, url, onLoadCallback, onErrorCallback, onTimedOutCallback ) {
				return new ImageLoader( renderingContext, url, onLoadCallback, onErrorCallback, onTimedOutCallback )
			},

			createSoundLoader : function( audioContext, assetManager, libraryId, url, onLoadCallback, onErrorCallback, onTimedOutCallback ) {
				var asset = assetManager.get( createAssetId( 'sound', libraryId ) )

				return new SoundLoader( audioContext, asset, url, onLoadCallback, onErrorCallback, onTimedOutCallback )
			},

			createTextLoader : function( postProcess, assetManager, libraryId, url, onLoadCallback, onErrorCallback, onTimedOutCallback ) {
				return new TextLoader( postProcess, url, onLoadCallback, onErrorCallback, onTimedOutCallback )
			},

			flurry : flurry,

			createComponentType : createComponentType,

			Application : Application,

			createSplashScreenImage : createSplashScreenImage,

			init : function( spell, next ) {
				initViewport(
					spell.eventManager,
					spell.configurationManager.getValue( 'id' ),
					spell.configurationManager.getValue( 'currentScreenSize' )
				)

				support.init(
					spell,
					_.bind( advertisement.init, advertisement, spell, next )
				)
			},

			getPlugins : function() {
				if( isHtml5Ejecta ||
					isHtml5GameClosure ) {

					return {
						admob : advertisement,
						admobWithChartboost : advertisement
					}

				} else {
					return {}
				}
			}
		}
	}
)

define(
	'spell/shared/util/createModuleId',
	function() {
		'use strict'


		return function( scriptId ) {
			return scriptId.replace( /\./g, '/' )
		}
	}
)

define(
	'spell/client/development/library/updateScript',
	[
		'spell/shared/util/createId',
		'spell/shared/util/createModuleId',
		'spell/shared/util/platform/PlatformKit',

		'spell/functions'
	],
	function(
		createId,
		createModuleId,
		PlatformKit,

		_
	) {
		'use strict'


		var createAffectedSystems = function( libraryManager, dependentModules ) {
			return _.reduce(
				libraryManager.getMetaDataRecordsByType( 'system' ),
				function( memo, system ) {
					var systemId       = createId( system.namespace, system.name ),
						systemModuleId = createModuleId( systemId )

					if( _.contains( dependentModules, systemModuleId ) ) {
						memo.push( systemId )
					}

					return memo
				},
				[]
			)
		}

		return function( spell, payload ) {
			var libraryId = payload.id,
				moduleId  = createModuleId( libraryId )

			// reload amd module
			PlatformKit.ModuleLoader.define( moduleId, payload.moduleSource )

			var dependentModules = PlatformKit.ModuleLoader.createDependentModules( moduleId ).concat( moduleId )

			// restart affected systems
			var sceneManager = spell.sceneManager,
				systemIds    = createAffectedSystems( spell.libraryManager, dependentModules )

			_.each(
				systemIds,
				function( systemId ) {
					sceneManager.restartSystem( systemId )
				}
			)

			// refresh references in component instances
			spell.entityManager.updateAssetReferences(
				'script:' + libraryId,
				spell.moduleLoader.require( moduleId )
			)
		}
	}
)

define(
	'spell/client/development/library/updateEntityTemplate',
	[
		'spell/shared/util/createId',
		'spell/shared/util/createLibraryFilePathFromId'
	],
	function(
		createId,
		createLibraryFilePathFromId
	) {
		'use strict'


		return function( spell, payload ) {
			var cacheContent    = {},
				definition      = payload.definition,
				libraryFilePath = createLibraryFilePathFromId( createId( definition.namespace, definition.name ) )

			cacheContent[ libraryFilePath ] = definition

			spell.libraryManager.addToCache( cacheContent )
			spell.entityManager.updateEntityTemplate( definition )
		}
	}
)

define(
	'spell/client/loading/addNamespaceAndName',
	function() {
		'use strict'


		/**
		 * Adds the namespace and name attribute to library records.
		 *
		 * @param records
		 */
		var addNamespaceAndName = function( records ) {
			for( var key in records ) {
				var value = records[ key ]

				var splitOffset = key.lastIndexOf( '.' )

				value.name      = key.substr( splitOffset + 1, key.length )
				value.namespace = key.substr( 0, splitOffset )
			}
		}

		return addNamespaceAndName
	}
)

define(
	'spell/client/development/library/updateAsset',
	[
		'spell/client/development/library/loadAsset',
		'spell/client/loading/addNamespaceAndName',
		'spell/client/loading/createFilesToLoad',
		'spell/client/util/updateAssets',
		'spell/shared/util/createAssetId',
		'spell/shared/util/createId',
		'spell/shared/util/createLibraryFilePath',
		'spell/shared/util/createLibraryFilePathFromId',
		'spell/shared/util/createLibraryIdFromAssetId',

		'spell/functions'
	],
	function(
		loadAsset,
		addNamespaceAndName,
		createFilesToLoad,
		updateAssets,
		createAssetId,
		createId,
		createLibraryFilePath,
		createLibraryFilePathFromId,
		createLibraryIdFromAssetId,

		_
	) {
		'use strict'


		return function( spell, payload ) {
			var assetManager         = spell.assetManager,
				eventManager         = spell.eventManager,
				configurationManager = spell.configurationManager,
				definition           = payload.definition,
				id                   = createId( definition.namespace, definition.name ),
				typedId              = createAssetId( definition.subtype, id )

			var loadedAssets = [ definition ]

			// The current state of asset update handling needs to be improved. In order to do that dependencies between assets must be accessible in a
			// normalized fashion.

			if( !definition.file &&
				!definition.assetId ) {

				updateAssets( assetManager, loadedAssets, true )

				eventManager.publish(
					[ eventManager.EVENT.ASSET_UPDATED, definition.subtype ],
					[ typedId ]
				)
			}

			if( definition.file ) {
				spell.libraryManager.load(
					createFilesToLoad( configurationManager, loadedAssets ),
					{
						assetManager       : spell.assetManager,
						isMetaDataLoad     : false,
						omitCache          : true,
						onLoadingCompleted : function( loadedFiles ) {
							updateAssets( assetManager, loadedAssets, true )

							spell.libraryManager.addToCache( loadedAssets )

							var libraryIds = assetManager.getLibraryIdByResourceId( createLibraryFilePath( definition.namespace, definition.file ) )

							var assetsToUpdate = _.reduce(
								libraryIds,
								function( memo, libraryId ) {
									var libraryPathJson = createLibraryFilePathFromId( libraryId )

									memo[ libraryPathJson ] = spell.libraryManager.get( libraryPathJson )

									return memo
								},
								{}
							)

							updateAssets( assetManager, assetsToUpdate, true )

							assetManager.injectResources( loadedFiles )

							spell.entityManager.refreshAssetReferences( assetManager )

							eventManager.publish(
								[ eventManager.EVENT.ASSET_UPDATED, definition.subtype ],
								[ typedId ]
							)
						}
					}
				)
			}

			var assetId = definition.assetId

			if( assetId ) {
				// load referenced asset first
				loadAsset(
					spell,
					createLibraryIdFromAssetId( assetId ),
					function( loadedFiles ) {
						// now update referencing asset (-> updated definition) and inject referenced asset
						updateAssets( assetManager, loadedAssets, true )

						assetManager.injectResources( loadedFiles )

						spell.entityManager.updateAssetReferences( typedId, assetManager.get( typedId ) )

						eventManager.publish(
							[ eventManager.EVENT.ASSET_UPDATED, definition.subtype ],
							[ typedId ]
						)
					}
				)
			}
		}
	}
)

define(
	'spell/client/development/createLibraryMessageHandler',
	[
		'spell/client/development/createMessageDispatcher',
		'spell/client/development/library/updateAsset',
		'spell/client/development/library/updateEntityTemplate',
		'spell/client/development/library/updateScript',

		'spell/functions'
	],
	function(
		createMessageDispatcher,
		updateAsset,
		updateEntityTemplate,
		updateScript,

		_
	) {
		'use strict'


		return function( spell ) {
			return createMessageDispatcher( {
				updateAsset : _.bind( updateAsset, null, spell ),
				updateEntityTemplate : _.bind( updateEntityTemplate, null, spell ),
				updateScript : _.bind( updateScript, null, spell )
			} )
		}
	}
)

define(
	'spell/client/development/createEntityMessageHandler',
	[
		'spell/client/development/createMessageDispatcher'
	],
	function(
		createMessageDispatcher
	) {
		'use strict'


		return function( spell ) {
			return createMessageDispatcher( {
				create : function( payload ) {
					spell.entityManager.createEntity( payload.entityConfig )
				},
				remove : function( payload ) {
					spell.entityManager.removeEntity( payload.entityId )
				}
			} )
		}
	}
)

define(
	'spell/shared/util/createLibraryIdFromAssetId',
	function() {
		'use strict'


		return function( assetId ) {
			return assetId ?
				assetId.slice( assetId.indexOf( ':' ) + 1 ) :
				undefined
		}
	}
)

define(
	'spell/shared/util/createLibraryFilePathFromId',
	function() {
		'use strict'


		return function( id ) {
			return id.replace( /\./g, '/' ) + '.json'
		}
	}
)

define(
	"spell/shared/util/input/keyCodes",
	function() {
		return {
		    "BACKSPACE": 8,
		    "TAB": 9,
		    "ENTER": 13,
		    "SHIFT": 16,
		    "CTRL": 17,
		    "ALT": 18,
		    "PAUSE": 19,
		    "CAPS_LOCK": 20,
		    "ESCAPE": 27,
		    "SPACE": 32,
		    "PAGE_UP": 33,
		    "PAGE_DOWN": 34,
		    "END": 35,
		    "HOME": 36,
		    "LEFT_ARROW": 37,
		    "UP_ARROW": 38,
		    "RIGHT_ARROW": 39,
		    "DOWN_ARROW": 40,
		    "INSERT": 45,
		    "DELETE": 46,
		    "0": 48,
		    "1": 49,
		    "2": 50,
		    "3": 51,
		    "4": 52,
		    "5": 53,
		    "6": 54,
		    "7": 55,
		    "8": 56,
		    "9": 57,
		    "A": 65,
		    "B": 66,
		    "C": 67,
		    "D": 68,
		    "E": 69,
		    "F": 70,
		    "G": 71,
		    "H": 72,
		    "I": 73,
		    "J": 74,
		    "K": 75,
		    "L": 76,
		    "M": 77,
		    "N": 78,
		    "O": 79,
		    "P": 80,
		    "Q": 81,
		    "R": 82,
		    "S": 83,
		    "T": 84,
		    "U": 85,
		    "V": 86,
		    "W": 87,
		    "X": 88,
		    "Y": 89,
		    "Z": 90,
		    "LEFT_WINDOW_KEY": 91,
		    "RIGHT_WINDOW_KEY": 92,
		    "SELECT_KEY": 93,
		    "NUMPAD_0": 96,
		    "NUMPAD_1": 97,
		    "NUMPAD_2": 98,
		    "NUMPAD_3": 99,
		    "NUMPAD_4": 100,
		    "NUMPAD_5": 101,
		    "NUMPAD_6": 102,
		    "NUMPAD_7": 103,
		    "NUMPAD_8": 104,
		    "NUMPAD_9": 105,
		    "MULTIPLY": 106,
		    "ADD": 107,
		    "SUBTRACT": 109,
		    "DECIMAL_POINT": 110,
		    "DIVIDE": 111,
		    "F1": 112,
		    "F2": 113,
		    "F3": 114,
		    "F4": 115,
		    "F5": 116,
		    "F6": 117,
		    "F7": 118,
		    "F8": 119,
		    "F9": 120,
		    "F10": 121,
		    "F11": 122,
		    "F12": 123,
		    "NUM_LOCK": 144,
		    "SCROLL_LOCK": 145,
		    "SEMI-COLON": 186,
		    "EQUAL_SIGN": 187,
		    "COMMA": 188,
		    "DASH": 189,
		    "PERIOD": 190,
		    "FORWARD_SLASH": 191,
		    "GRAVE_ACCENT": 192,
		    "OPEN_BRACKET": 219,
		    "BACK_SLASH": 220,
		    "CLOSE_BRACKET": 221,
		    "SINGLE_QUOTE": 222,

			/**
			 * Hardware buttons. The key codes are arbitrarily choosen.
			 */
			"BACK": 230,
			"MENU": 231,
			"POWER": 232,
			"HOME": 233
		}
	}
)

define(
	'spell/shared/util/createAssetId',
	[
		'spell/shared/util/createId',

		'spell/functions'
	],
	function(
		createId,

		_
	) {
		'use strict'


		return function( scheme ) {
			if( !scheme ) throw 'Error: Missing argument \'scheme\'.'

			return scheme + ':' + createId(
				_.toArray( arguments ).slice( 1 )
			)
		}
	}
)

define(
	'spell/shared/util/createId',
	[
		'spell/functions'
	],
	function(
		_
	) {
		'use strict'


		return function( args ) {
			var numArgs = arguments.length

			if( numArgs === 1 ) {
				if( !_.isArray( args ) ) {
					args = [ args ]
				}

			} else if( numArgs > 1 ) {
				args = _.toArray( arguments )
			}

			if( !args || args.length === 0 ) throw 'Error: Missing name and or namespace.'

			return _.reduce(
				args,
				function( memo, argument ) {
					if( argument === '' ) return memo

					return memo + ( memo !== '' ? '.' : '' )  + argument
				},
				''
			)
		}
	}
)

define(
	'spell/client/util/updateAssets',
	[
		'spell/shared/util/createId',
		'spell/shared/util/createAssetId',
		'spell/shared/util/input/keyCodes',

		'spell/functions'
	],
	function(
		createId,
		createAssetId,
		keyCodes,

		_
	) {
		'use strict'


		var createFrameOffset = function( frameWidth, frameHeight, numX, numY, frameId, innerPadding ) {
			if( !innerPadding ) innerPadding = 0

			frameWidth  += innerPadding * 2
			frameHeight += innerPadding * 2

			return [
				( frameId % numX ) * frameWidth + innerPadding,
				Math.floor( frameId / numX ) * frameHeight + innerPadding
			]
		}

		var createTilemapAsset = function( assetManager, asset ) {
			var spriteSheetAssetId = asset.assetId,
				spriteSheetAsset   = assetManager.get( spriteSheetAssetId )

			if( !spriteSheetAsset ) {
				return
			}

			return {
				type                : asset.subtype,
				resourceId          : spriteSheetAsset.resourceId,
				spriteSheet         : spriteSheetAsset,
				config              : asset.config,
				tilemapDimensions   : [ asset.config.width, asset.config.height ],
				tilemapData         : asset.config.tileLayerData
			}
		}

		var createAnimationAsset = function( assetManager, asset ) {
			var spriteSheetAssetId = asset.assetId,
				spriteSheetAsset   = assetManager.get( spriteSheetAssetId )

			if( !spriteSheetAsset ) {
				return
			}

			var frameWidth      = spriteSheetAsset.config.frameWidth,
				frameHeight     = spriteSheetAsset.config.frameHeight,
				innerPadding    = spriteSheetAsset.config.innerPadding || 0,
				numX            = Math.floor( spriteSheetAsset.config.textureWidth / ( frameWidth + innerPadding * 2 ) ),
				numY            = Math.floor( spriteSheetAsset.config.textureHeight / ( frameHeight + innerPadding * 2 ) ),
				numFrames       = _.size( asset.config.frameIds ),
				createFrameOffsetPartial = _.bind( createFrameOffset, null, frameWidth, frameHeight )

			return {
				type            : asset.subtype,
				resourceId      : spriteSheetAsset.resourceId,
				frameDimensions : [ frameWidth, frameHeight ],
				frameDuration   : asset.config.duration / numFrames,
				frameOffsets    : _.map( asset.config.frameIds, function( frameId ) { return createFrameOffsetPartial( numX, numY, frameId, innerPadding ) } ),
				numFrames       : numFrames
			}
		}

		var createInputMapAsset = function( asset ) {
			return _.reduce(
				asset.config,
				function( memo, action, key ) {
					memo[ keyCodes[ key ] ] = action

					return memo
				},
				{}
			)
		}

		var eachAnimatedAttribute = function( animate, iterator ) {
			return _.each(
				animate,
				function( attributes ) {
					_.each( attributes, iterator )
				}
			)
		}

		var createKeyFrameAnimationAsset = function( asset ) {
			var config = asset.config

			// determine and add length of attribute animations
			eachAnimatedAttribute(
				config.animate,
				function( attribute ) {
					attribute.length = _.last( attribute.keyFrames ).time
				}
			)

			return {
				animate : config.animate,
				type    : asset.subtype,
				length  : config.length
			}
		}

		var createSpriteSheetAsset = function( asset ) {
			var frameWidth      = asset.config.frameWidth || 1,
				frameHeight     = asset.config.frameHeight || 1,
				innerPadding    = asset.config.innerPadding || 0,
				numX            = Math.floor( asset.config.textureWidth / ( frameWidth + innerPadding * 2 ) ),
				numY            = Math.floor( asset.config.textureHeight / ( frameHeight + innerPadding * 2 ) ),
				numFrames       = numX * numY

			// create a lookup table to lookup the subtextures
			var frameOffsets = []

			for( var i = 0; i < numFrames; i++ ) {
				frameOffsets.push( createFrameOffset( frameWidth, frameHeight, numX, numY, i, innerPadding ) )
			}

			return {
				frameDimensions : [ frameWidth, frameHeight ],
				frameOffsets    : frameOffsets,
				frameMaxX       : numX,
				frameMaxY       : numY,
				config          : asset.config,
				type            : asset.subtype
			}
		}

		var addResourceId = function( asset, assetDefinition ) {
			var file = assetDefinition.file

			if( !file ) {
				return
			}

			asset.resourceId = createId( assetDefinition.namespace, assetDefinition.name )
		}


		return function( assetManager, newAssetDefinitions, overwriteExisting ) {
			var filteredAssetDefinitions = overwriteExisting ?
				newAssetDefinitions :
				_.filter(
					newAssetDefinitions,
					function( assetDefinition ) {
						return !assetManager.has( createAssetId( assetDefinition.subtype, assetDefinition.namespace, assetDefinition.name ) )
					}
				)

			// in a first pass all assets which do not depend on other assets are created
			_.each(
				filteredAssetDefinitions,
				function( assetDefinition ) {
					var asset,
						type    = assetDefinition.subtype,
						assetId = createAssetId( type, assetDefinition.namespace, assetDefinition.name )

					if( type === 'appearance' ) {
						asset = {
							type : type
						}

					} else if( type === 'sound' ) {
						asset = {
							type : type,
							isMusic : !!assetDefinition.config.isMusic
						}

					} else if( type === 'spriteSheet' ) {
						asset = createSpriteSheetAsset( assetDefinition )

					} else if( type === 'font') {

						asset = {
							config : assetDefinition.config,
							type : type
						}

					} else if( type === 'inputMap' ) {
						asset = createInputMapAsset( assetDefinition )

					} else if( type === 'keyFrameAnimation' ) {
						asset = createKeyFrameAnimationAsset( assetDefinition )

					} else if( type === 'translation' ) {
						asset = {
							config : assetDefinition.config,
							type : type
						}
					}

					addResourceId( asset, assetDefinition )

					if( asset ) {
						asset.assetId = assetId
					}

					assetManager.add( assetId, asset )
				}
			)

			// in a second pass all assets that reference other assets are created
			_.each(
				newAssetDefinitions,
				function( assetDefinition ) {
					var type = assetDefinition.subtype

					if( type === 'animation' ) {
						var animationAsset = createAnimationAsset( assetManager, assetDefinition )

						if( animationAsset ) {
							assetManager.add(
								createAssetId(
									type,
									assetDefinition.namespace,
									assetDefinition.name
								),
								animationAsset
							)
						}

					} else if ( type === '2dTileMap') {
						var tileMapAsset = createTilemapAsset( assetManager, assetDefinition )

						if( tileMapAsset ) {
							assetManager.add(
								createAssetId(
									type,
									assetDefinition.namespace,
									assetDefinition.name
								),
								tileMapAsset
							)
						}
					}
				}
			)
		}
	}
)

define(
	'spell/shared/util/createLibraryFilePath',
	function() {
		'use strict'


		return function( namespace, fileName ) {
			return namespace.replace( /\./g, '/' ) + '/' + fileName
		}
	}
)

define(
	'spell/client/loading/createFilesToLoad',
	[
		'spell/shared/util/createLibraryFilePath',

		'spell/functions'
	],
	function(
		createLibraryFilePath,

		_
	) {
		'use strict'


		return function( configurationManager, assets ) {
			var currentLanguage     = configurationManager.getValue( 'currentLanguage' ),
				currentQualityLevel = configurationManager.getValue( 'currentQualityLevel' )

			return _.reduce(
				assets,
				function( memo, asset, libraryId ) {
					var config          = asset.config,
						subtype         = asset.subtype,
						isSound         = subtype === 'sound',
						isAppearance    = subtype === 'appearance',
						isFont          = subtype === 'font',
						isSpriteSheet   = subtype === 'spriteSheet',
						libraryFilePath

					if( config &&
						( isSound || isAppearance || isFont || isSpriteSheet ) ) {

						if( isFont || isSpriteSheet ) {
							libraryFilePath = createLibraryFilePath( asset.namespace, asset.file )

						} else {
							var isLocalized        = config.localized,
								qualityLevelSuffix = config.qualityLevels ? '.' + currentQualityLevel : ''

							if( isLocalized ) {
								var languageToExtension = config.localization,
									fileExtension       = isSound ? 'mp3' : languageToExtension[ currentLanguage ],
									localizedFileName   = asset.name + '.' + currentLanguage + qualityLevelSuffix + '.' + fileExtension

								libraryFilePath = createLibraryFilePath( asset.namespace, localizedFileName )

							} else {
								libraryFilePath = createLibraryFilePath(
									asset.namespace,
									asset.name + qualityLevelSuffix + ( isSound ? '.mp3' : '.' + config.extension )
								)
							}
						}

						memo[ libraryId ] = libraryFilePath
					}

					return memo
				},
				{}
			)
		}
	}
)

define(
	'spell/client/development/library/loadAsset',
	[
		'spell/client/loading/createFilesToLoad',
		'spell/client/util/updateAssets',
		'spell/shared/util/createLibraryFilePathFromId'
	],
	function(
		createFilesToLoad,
		updateAssets,
		createLibraryFilePathFromId
	) {
		'use strict'


		return function( spell, libraryId, next ) {
			// load meta data record
			spell.libraryManager.load(
				[ createLibraryFilePathFromId( libraryId ) ],
				{
					assetManager       : spell.assetManager,
					omitCache          : true,
					onLoadingCompleted : function( loadedLibraryRecords ) {
						updateAssets( spell.assetManager, loadedLibraryRecords )

						var filesToLoad = createFilesToLoad( spell.configurationManager, loadedLibraryRecords )

						if( filesToLoad.length > 0 ) {
							spell.libraryManager.load(
								filesToLoad,
								{
									assetManager       : spell.assetManager,
									isMetaDataLoad     : false,
									omitCache          : true,
									onLoadingCompleted : next
								}
							)

						} else {
							next()
						}
					}
				}
			)
		}
	}
)

define(
	'spell/client/development/createComponentMessageHandler',
	[
		'spell/client/development/createMessageDispatcher',
		'spell/client/development/library/loadAsset',
		'spell/shared/util/createLibraryIdFromAssetId'
	],
	function(
		createMessageDispatcher,
		loadAsset,
		createLibraryIdFromAssetId
	) {
		'use strict'


		return function( spell ) {
			var updateComponent = function( payload ) {
				var success = spell.entityManager.updateComponent( payload.entityId, payload.componentId, payload.config )

				if( !success ) {
					spell.console.error( 'Could not update component "' + payload.componentId + '" in entity ' + payload.entityId + '.' )
				}
			}

			return createMessageDispatcher( {
				add : function( payload ) {
					spell.entityManager.addComponent( payload.entityId, payload.componentId )
				},
				remove : function( payload ) {
					spell.entityManager.removeComponent( payload.entityId, payload.componentId )
				},
				update : function( payload ) {
					var assetId = payload.config.assetId

					if( assetId ) {
						loadAsset(
							spell,
							createLibraryIdFromAssetId( assetId ),
							function( loadedFiles ) {
								spell.assetManager.injectResources( loadedFiles )

								spell.entityManager.updateAssetReferences( assetId, spell.assetManager.get( assetId ) )

								updateComponent( payload )
							}
						)

					} else {
						updateComponent( payload )
					}
				}
			} )
		}
	}
)

define(
	'spell/shared/util/platform/functions',
	[
		'spell/shared/util/platform/private/functions'
	],
	function(
		functions
	) {
		return functions
	}
)

/*
 * This class is derived from the library "Underscore" which original license follows:
 *
 * Licence Notice Underscore.js 1.3.3:
 *
 * Copyright (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

/**
 * *spell.functions* is a collection of utility functions akin to [underscore.js](http://underscorejs.org).
 *
 * @class spell.functions
 * @singleton
 * @license
 * @preserve
 */

define(
	'spell/functions',
	[
		'spell/shared/util/platform/functions'
	],
	function(
		platformImpl
	) {
		'use strict'


		var _ = {};

		/**
		 * Returns *true* if **object** is an Array.
		 *
		 * Examples:
		 *
		 *     (function(){ return _.isArray(arguments); })();
		 *     //=> false
		 *     _.isArray([1,2,3]);
		 *     => true
		 *
		 * @param {Object} object
		 * @returns {Boolean}
		 */
		_.isArray = platformImpl.isArray;

		/**
		 * Returns *true* if **value** is an Object.
		 *
		 * Examples:
		 *
		 *     _.isObject({});
		 *     //=> true
		 *     _.isObject(1);
		 *     //=> false
		 *
		 * @param {Object} value
		 * @return {Boolean}
		 */
		_.isObject = platformImpl.isObject;

		/**
		 * Return the number of values in the **list**.
		 *
		 * Example:
		 *
		 *     _.size({one : 1, two : 2, three : 3})
		 *     //=> 3
		 *
		 * @param {Object} list
		 * @return {Number}
		 */
		_.size = platformImpl.size;

		/**
		 * Converts the **list** (anything that can be iterated over), into a real Array.
		 * Useful for transmuting the arguments object.
		 *
		 * Example:
		 *
		 *     (function(){ return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
		 *     //=> [2, 3, 4]
		 *
		 * @param {Object}list
		 * @return {Array}
		 */
		_.toArray = platformImpl.toArray;


		/**
		 * Iterates over a **list** of elements, yielding each in turn to an **iterator** function.
		 * The **iterator** is bound to the **context** object, if one is passed.
		 * Each invocation of **iterator** is called with three arguments:
		 * *(element, index, list)*. If **list** is a JavaScript object,
		 * **iterator**'s arguments will be *(value, key, list)*.
		 *
		 * Example:
		 *     _.each([1, 2, 3], function(num){ alert(num) })
		 *     //=> alerts each number in turn...
		 *     _.each({one : 1, two : 2, three : 3}, function(num, key){ alert(num) })
		 *     //=> alerts each number in turn...
		 *
		 * @param {Array|Object} list An Array or an Object with key/value pairs
		 * @param {Function} iterator Iterator function. The arguments for this function will be *(element, index, list)*
		 * if object is an Array and *(value, key, list)* if it's an Object
		 * @param {Object} [context] The context in which the iterator should be bound to
		 * @returns {void}
		 */
		_.each = platformImpl.each;

		/**
		 * Produces a new array of values by mapping each value in **list** through a
		 * transformation function (**iterator**). If **list** is a JavaScript object, **iterator**'s
		 * arguments will be *(value, key, list)*.
		 *
		 * Example:
		 *
		 *     _.map([1, 2, 3], function(num){ return num * 3 })
		 *     //=> [3, 6, 9]
		 *
		 *     _.map({one : 1, two : 2, three : 3}, function(num, key){ return num * 3 })
		 *     //=> [3, 6, 9]
		 *
		 * @param {Array|Object} list An Array or an Object with key/value pairs
		 * @param {Function} iterator Iterator function. The arguments for this function will be *(element, index, list)*
		 * if object is an Array and *(value, key, list)* if it's an Object
		 * @param {Object} [context] The context in which the iterator should be bound to
		 * @returns {Array} Array with the values of **list** mapped through the **iterator** transformation function
		 */
		_.map = platformImpl.map;

		/**
		 * Returns the last element of an **array**. Passing **n** will return the last n elements of the array.
		 *
		 * Example:
		 *
		 *     _.last([5, 4, 3, 2, 1]);
		 *     //=> 1
		 *
		 * @param {Array} array
		 * @param {Number} [n]
		 * @return {Array|Object}
		 */
		_.last = platformImpl.last;

		/**
		 * Looks through each value in the **list**, returning an array of all the values that pass a
		 * truth test (**iterator**).
		 *
		 * Example:
		 *
		 *     var evens = _.filter([1, 2, 3, 4, 5, 6], function(num){ return num % 2 == 0; });
		 *     //=> [2, 4, 6]
		 *
		 * @param {Array} list
		 * @param {Function} iterator
		 * @param {Object} [context]
		 * @return {Array}
		 */
		_.filter = platformImpl.filter;

		/**
		 * Does the object contain the given key?
		 *
		 * Example:
		 *
		 *     _.has({a: 1, b: 2, c: 3}, "b");
		 *     //=> true
		 *
		 * @param {Object} object
		 * @param {String} key
		 * @return {Boolean}
		 */
		_.has = platformImpl.has;

		/**
		 * Returns *true* if any of the values in the **list** pass the **iterator** truth test.
		 * Short-circuits and stops traversing the list if a *true* element is found.
		 *
		 * Example:
		 *
		 *     _.any([null, 0, 'yes', false], function(value) { return value; });
		 *     //=> true
		 *
		 * @param {Array} object
		 * @param {Function} iterator
		 * @param [context]
		 * @return {Boolean}
		 */
		_.any = platformImpl.any;

		/**
		 * Looks through each value in the **list**, returning the first one that passes a truth test (**iterator**).
		 * The function returns as soon as it finds an acceptable element, and doesn't traverse the entire list.
		 *
		 * Example:
		 *
		 *     var even = _.find([1, 2, 3, 4, 5, 6], function(num){ return num % 2 == 0 })
		 *     //=> 2
		 *
		 * @param {Array}list
		 * @param {Function} iterator
		 * @param {Object} [context]
		 * @return {Object}
		 */
		_.find = platformImpl.find;

		/**
		 * Invokes the given **iterator** function *n* times.
		 *
		 * Example:
		 *
		 *     _.times(3, function(){ genie.grantWish(); });
		 *
		 * @param {Number}n
		 * @param {Function} iterator
		 * @param {Object} [context]
		 */
		_.times = platformImpl.times;

		/**
		 * Copy all of the properties in the **source** objects over to the **destination** object,
		 * and return the **destination** object. It's in-order, so the last source will override
		 * properties of the same name in previous arguments.
		 *
		 * Example:
		 *
		 *     _.extend({name : 'moe'}, {age : 50});
		 *     //=> {name : 'moe', age : 50}
		 *
		 * @param {Object} destination
		 * @param {Object...} sources
		 * @return {Object}
		 */
		_.extend = platformImpl.extend;

		/**
		 * Returns *true* if all of the values in the **list** pass the **iterator** truth test.
		 *
		 * Example:
		 *
		 *     _.all([true, 1, null, 'yes'], function(value) { return value; });
		 *     //=> false
		 *
		 * @param {Array} list
		 * @param {Function} iterator
		 * @param{Object} [context]
		 * @returns {Boolean}
		 */
		_.all = platformImpl.all;

		/**
		 * A function to create flexibly-numbered lists of integers, handy for each and map loops.
		 * Returns a list of integers from **start** to **stop**, incremented (or decremented) by **step**.
		 *
		 * Examples:
		 *
		 *     _.range(10);
		 *     //=> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
		 *     _.range(1, 11);
		 *     //=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
		 *     _.range(0, 30, 5);
		 *     //=> [0, 5, 10, 15, 20, 25]
		 *     _.range(0, -10, -1);
		 *     //=> [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]
		 *     _.range(0, 0);
		 *     => []
		 *
		 * @param {Number} start
		 * @param {Number} stop
		 * @param {Number} [step] defaults to 1 of omitted
		 * @return {Array}
		 */
		_.range = platformImpl.range;

		/**
		 * **reduce** boils down a list of values into a single value.
		 * **memo** is the initial state of the reduction, and each successive step of it should be returned by iterator.
		 *
		 * Example:
		 *
		 *     var sum = _.reduce([1, 2, 3], function(memo, num){ return memo + num }, 0)
		 *     //=> 6
		 *
		 * @param {Array} list An array holding the values over which this functions iterates. Each value will be
		 * passed to the iterator function.
		 * @param {Function} iterator Iterator function which is called with the arguments **(memo, value, index, list)**
		 * @param {Object} [memo] Any object (e.g. a String or Number) that should be passed as initial value
		 * to the iterator function
		 * @param {Object} [context] Context in which the iterator should be called
		 * @return {Object}
		 */
		_.reduce = platformImpl.reduce;

		/**
		 * Bind a **function** to an **object**, meaning that whenever the function is called,
		 * the value of *this* will be the **object**. Optionally, bind **arguments** to the **function**
		 * to pre-fill them, also known as partial application.
		 *
		 * Example:
		 *
		 *     var func = function(greeting){ return greeting + ': ' + this.name };
		 *     func = _.bind(func, {name : 'moe'}, 'hi');
		 *     func();
		 *     //=> 'hi: moe'
		 *
		 * @param {Function} function
		 * @param {Object} object
		 * @param {Object...} [arguments]
		 * @return {Function}
		 */
		_.bind = platformImpl.bind;

		/**
		 * Returns the values in **list** without the elements that the truth test (**iterator**) passes.
		 * The opposite of {@link #filter}.
		 *
		 * Example:
		 *
		 *     var odds = _.reject([1, 2, 3, 4, 5, 6], function(num){ return num % 2 == 0; });
		 *     //=> [1, 3, 5]
		 *
		 * @param {Array} list
		 * @param {Function} iterator
		 * @param {Object} [context]
		 * @return {Array}
		 */
		_.reject = platformImpl.reject;

		/**
		 * Create a shallow-copied clone of the **object**. Any nested objects or arrays will be
		 * copied by reference, not duplicated.
		 *
		 * Example:
		 *
		 *     _.clone({name : 'moe'});
		 *     //=> {name : 'moe'};
		 *
		 * @param {Object} object
		 * @return {Object}
		 */
		_.clone = platformImpl.clone;

		/**
		 * Fill in missing properties in **object** with default values from the **defaults** objects,
		 * and return the object. As soon as the property is filled, further defaults will have no effect.
		 *
		 * Example:
		 *
		 *     var iceCream = {flavor : "chocolate"};
		 *     _.defaults(iceCream, {flavor : "vanilla", sprinkles : "lots"});
		 *     //=> {flavor : "chocolate", sprinkles : "lots"}
		 *
		 *
		 * @param {Object} object
		 * @param {Object...} defaults
		 * @return {Object}
		 */
		_.defaults = platformImpl.defaults;

		/**
		 * Returns the index at which **value** can be found in the **array**, or -1 if value is not present
		 * in the **array**.  If you're working with a large array, and you know that the array is already
		 * sorted, pass *true* for **isSorted** to use a faster binary search.
		 *
		 * Example:
		 *
		 *     _.indexOf([1, 2, 3], 2);
		 *     //=> 1
		 *
		 * @param {Array} array
		 * @param {Object} value
		 * @param {Boolean} [isSorted]
		 * @return {Number}
		 */
		_.indexOf = platformImpl.indexOf;

		/**
		 * Returns true if object is a String.
		 *
		 *     _.isString("moe");
		 *     //=> true
		 *
		 * @param {Object} object
		 * @return {Boolean}
		 */
		_.isString = platformImpl.isString;

		/**
		 * Returns *true* if **object** contains no values.
		 *
		 * Example:
		 *
		 *     _.isEmpty([1, 2, 3]);
		 *     //=> false
		 *     _.isEmpty({});
		 *     //=> true
         *
		 * @param {Object} object
		 * @return {Boolean}
		 */
		_.isEmpty = platformImpl.isEmpty;

		/**
		 * Retrieve all the names of the **object**'s properties.
		 *
		 * Example:
		 *
		 *     _.keys({one : 1, two : 2, three : 3});
		 *     //=> ["one", "two", "three"]
		 *
		 * @param {Object} object
		 * @returns {Array}
		 */
		_.keys = platformImpl.keys;

		/**
		 * Returns true if object is a Function.
		 *
		 * Example:
		 *
		 *     _.isFunction(alert);
		 *     //=> true
		 *
		 * @param {Object} object
		 * @return {Boolean}
		 */
		_.isFunction = platformImpl.isFunction;

		/**
		 * Returns *true* if the **value** is present in the **list**, using === to test equality.
		 *
		 * Example:
		 *
		 *     _.contains([1, 2, 3], 3);
		 *     //=> true
		 *
		 * @param {Array} list
		 * @param {Object} value
		 * @return {Boolean}
		 */
		_.contains = platformImpl.contains;

		/**
		 * Calls the method named by **methodName** on each value in the list. Any extra **arguments**
		 * passed to invoke will be forwarded on to the method invocation.
		 *
		 * Example:
		 *
		 *     _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
		 *     //=> [[1, 5, 7], [1, 2, 3]]
		 *
		 * @param {Array} list
		 * @param {String} methodName
		 * @param {Object...} arguments
		 * @return {Array}
		 */
		_.invoke = platformImpl.invoke;

		/**
		 * Flattens a nested **array** (the nesting can be to any depth). If you pass **shallow**,
		 * the array will only be flattened a single level.
		 *
		 * Examples:
		 *
		 *     _.flatten([1, [2], [3, [[4]]]]);
		 *     //=> [1, 2, 3, 4];
		 *
		 *     _.flatten([1, [2], [3, [[4]]]], true);
		 *     //=> [1, 2, 3, [[4]]];
		 *
		 * @param {Array} array
		 * @param {Boolean} shallow
		 * @return {Array}
		 */
		_.flatten = platformImpl.flatten;

		/**
		 * Return a copy of the **object**, filtered to only have values for the whitelisted keys specified in **keys**.
		 *
		 * Example:
		 *
		 *     _.pick({name : 'moe', age: 50, userid : 'moe1'}, ['name', 'age']);
		 *     //=> {name : 'moe', age : 50}
		 *
		 * @param {Object} object
		 * @param {Array} keys Array containing the keys for the whitelist in **object**
		 * @return {Object}
		 */
		_.pick = platformImpl.pick;

		/**
		 * Computes the union of the passed-in **arrays**: the list of unique items, in order,
		 * that are present in one or more of the **arrays**.
		 *
		 * Example:
		 *
		 *     _.union([1, 2, 3], [101, 2, 1, 10], [2, 1]);
		 *     //=> [1, 2, 3, 101, 10]
		 *
		 * @param {Array...} arrays
		 * @return {Array}
		 */
		_.union = platformImpl.union;

		/**
		 * Returns the values from **array** that are not present in the **other** arrays.
		 *
		 * Example:
		 *
		 *     _.difference([1, 2, 3, 4, 5], [5, 2, 10]);
		 *     //=> [1, 3, 4]
		 *
		 * @param {Array} array
		 * @param {Array...} others
		 * @return {Array}
		 */
		_.difference = platformImpl.difference;

		/**
		 * Return all of the values of the **object**'s properties.
		 *
		 * Example:
		 *
		 *     _.values({one : 1, two : 2, three : 3});
		 *     //=> [1, 2, 3]
		 *
		 * @param {Object} object
		 * @return {Array}
		 */
		_.values = platformImpl.values;

		/**
		 * Produces a duplicate-free version of the **array**, using === to test object equality.
		 * If you know in advance that the array is sorted, passing *true* for **isSorted** will run a much faster
		 * algorithm.
		 *
		 * Example:
		 *     _.uniq([1, 2, 1, 3, 1, 4]);
		 *     //=> [1, 2, 3, 4]
		 *
		 * @param {Array} array
		 * @param {Boolean} [isSorted]
		 * @return {Array}
		 */
		_.unique = platformImpl.unique;

		/**
		 * Returns everything but the last entry of the **array**.
		 * Especially useful on the arguments object. Pass **n** to exclude the last n elements from the result.
		 *
		 * Example:
		 *
		 *     _.initial([5, 4, 3, 2, 1]);
		 *     //=> [5, 4, 3, 2]
		 *
		 * @param {Array} array
		 * @param {Number} [n] Exclude the last n elments from the result
		 * @return {Array}
		 */
		_.initial = platformImpl.initial;

		/**
		 * A convenient version of what is perhaps the most common use-case for {@link #map}:
		 * extracting a list of property values.
		 *
		 * Example:
		 *
		 *     var stooges = [{name : 'moe', age : 40}, {name : 'larry', age : 50}, {name : 'curly', age : 60}];
		 *     _.pluck(stooges, 'name');
		 *     //=> ["moe", "larry", "curly"]
		 *
		 * @param {Array} list Array with associative arrays in it
		 * @param {String|Number} propertyName key that will be used to lookup the value in the elements of **list**
		 * @return {Array}
		 */
		_.pluck = platformImpl.pluck;

		/**
		 * Merges together the values of each of the **arrays** with the values at the corresponding position.
		 * Useful when you have separate data sources that are coordinated through matching array indexes.
		 *
		 * Example:
		 *
		 *     _.zip(['moe', 'larry', 'curly'], [30, 40, 50], [true, false, false]);
		 *     //=> [["moe", 30, true], ["larry", 40, false], ["curly", 50, false]]
		 *
		 * @param {Array...} arrays
		 * @return {Array}
		 */
		_.zip = platformImpl.zip;

		/**
		 * Creates a version of the function that can only be called one time. Repeated calls to the modified function will have no effect, returning the value
		 * from the original call. Useful for initialization functions, instead of having to set a boolean flag and then check it later.
		 *
		 * Example:
		 *
		 *     var initialize = _.once( createApplication )
		 *     initialize()
		 *     initialize()
		 *     // Application is only created once.
		 *
		 * @param {Function} function The callback function to call on the first time.
		 */
		_.once = platformImpl.once;

		/**
		 * Creates a version of the function that will only be run after first being called count times. Useful for
		 * grouping asynchronous responses, where you want to be sure that all the async calls have finished, before
		 * proceeding.
		 *
		 * Example:
		 *
		 *     var lock = _.after( 3, function() { // resuming with doing stuff after third call to "lock" function } )
		 *
		 * @param {Number} count The count after which the callback function is called.
		 * @param {Function} function The callback function to call after the **count** times.
		 */
		_.after = platformImpl.after;

		/**
		 * Computes the list of values that are the intersection of all the arrays. Each value in the result is present in each of the arrays.
		 *
		 * Example:
		 *
		 *     _.intersection([1, 2, 3], [101, 2, 1, 10], [2, 1]);
		 *     //=> [1, 2]
		 *
		 * @param {Array...} arrays
		 * @return {Array}
		 */
		_.intersection = platformImpl.intersection;

		/**
		 * Returns true if object is NaN.
		 * Note: this is not the same as the native isNaN function, which will also return true if the variable is undefined.
		 *
		 * @param {Object} Number
		 */
		_.isNaN = platformImpl.isNaN;

		/**
		 * Returns the same value that is used as the argument. In math: f(x) = x
		 * This function looks useless, but is used throughout Underscore as a default iterator.
		 *
		 *     var moe = {name : 'moe'};
		 *     moe === _.identity(moe);
		 *     //=> true
		 */
		_.identity = platformImpl.identity;

		return _
	}
)

define(
	'spell/client/development/createMessageDispatcher',
	[
		'spell/functions'
	],
	function(
		_
	) {
		'use strict'


		var createMatchingId = function( idToHandler, searchedId ) {
			if( searchedId.charAt( 0 ) === '.' ) {
				searchedId = searchedId.substring( 1 )
			}

			for( var id in idToHandler ) {
				if( searchedId.lastIndexOf( id, 0 ) === 0 ) {
					return id
				}
			}
		}

		var createRemainingId = function( id, matchingId ) {
			return id.substring( matchingId.length + 1 )
		}

		return function( idToHandler ) {
			return function( message, id, processedId ) {
				if( !processedId ) processedId = ''

				var matchingId = createMatchingId( idToHandler, id ),
					handler    = idToHandler[ matchingId ]

				if( !handler ) {
					throw 'Error: No handler for message with id \'' + processedId + ( processedId !== '' ? '.' : '' ) + id + '\' found.'
				}

				var remainingId = createRemainingId( id, matchingId )

				handler( message, remainingId, processedId + matchingId )
			}
		}
	}
)

define(
	'spell/client/development/createDebugMessageHandler',
	[
		'spell/client/development/createMessageDispatcher',
		'spell/client/development/createComponentMessageHandler',
		'spell/client/development/createEntityMessageHandler',
		'spell/client/development/createLibraryMessageHandler',
		'spell/client/development/createApplicationMessageHandler',
		'spell/client/development/createSettingsMessageHandler',
		'spell/client/development/createSystemMessageHandler'
	],
	function(
		createMessageDispatcher,
		createComponentMessageHandler,
		createEntityMessageHandler,
		createLibraryMessageHandler,
		createApplicationMessageHandler,
		createSettingsMessageHandler,
		createSystemMessageHandler
	) {
		'use strict'


		return function( spell, startEngine ) {
			return createMessageDispatcher( {
				'spell.debug.component'   : createComponentMessageHandler( spell ),
				'spell.debug.entity'      : createEntityMessageHandler( spell ),
				'spell.debug.library'     : createLibraryMessageHandler( spell ),
				'spell.debug.application' : createApplicationMessageHandler( spell, startEngine ),
				'spell.debug.settings'    : createSettingsMessageHandler( spell ),
				'spell.debug.system'      : createSystemMessageHandler( spell )
			} )
		}
	}
)

define(
	'spell/math/random/XorShift32',
	function() {
		'use strict'


		/**
		 * XorShift32 is a pseudo random number generator. It generates the next number in a sequence by repeatly applying a sequence of bit operations. You can use it
		 * to generate a sequence of random numbers. Since the algorithm is deterministic the generated sequence depends only on the chosen seed.
		 *
		 * Example:
		 *
		 *     // new instance of XorShift32 with seed 12345
		 *     var prng = new XorShift32( 12345 );
		 *
		 *     // always returns the same pseudo random number sequence depending on the seed
		 *     var number1 = prng.{@link #next}();
		 *     var number2 = prng.{@link #next}();
		 *
		 * @class spell.math.random.XorShift32
		 * @constructor
		 */
		var XorShift32 = function( seed ) {
			this.x = seed
		}

		XorShift32.prototype = {
			/**
			 * Returns the next number in the sequence.
			 *
			 * @return {Number}
			 */
			next : function() {
				var a = this.x,
					b = a

				a <<= 13
				b ^= a

				a >>= 17
				b ^= a

				a <<= 5
				b ^= a


				this.x = b

				return ( b + 2147483648 ) * ( 1 / 4294967296 )
			},

			/**
			 * Returns the next number between min and max in the sequence.
			 *
			 * @param {Number} min The minimum value
			 * @param {Number} max The maximum value
			 * @return {Number}
			 */
			nextBetween : function( min, max ) {
				return ( min + this.next() * ( max - min ) )
			},

			/**
			 * Returns the next integer between min and max in the sequence.
			 *
			 * @param {Number} min The minimum value
			 * @param {Number} max The maximum value
			 * @return {Number}
			 */
			nextIntegerBetween : function( min, max ) {
				return Math.round( this.nextBetween( Math.ceil( min ), Math.floor( max ) ) )
			}
		}

		return XorShift32
	}
)

/*
 * This file is derived from glMatrix 2.1.0. Original Licence follows:
 */

/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */


define(
	'spell/math/vec2',
	[
		'spell/shared/util/platform/Types',
		'spell/math/util'
	],
	function(
		Types,
		mathUtil
	) {
		'use strict'


		/**
		 * 2d vector functions
		 *
		 * @class spell.math.vec2
		 * @singleton
		 * @requires Math
		 * @requires spell.shared.util.platform.Types
		 * @requires spell.math.util
		 */
		var vec2 = {};

		/**
		 * Creates a new, empty vec2
		 *
		 * @returns {vec2} a new 2d vector
		 */
		vec2.create = function() {
		    var out = Types.createFloatArray(2);
		    out[0] = 0;
		    out[1] = 0;
		    return out;
		};

		/**
		 * Creates a new vec2 initialized with values from an existing vector
		 *
		 * @param {vec2} a vector to clone
		 * @returns {vec2} a new 2d vector
		 */
		vec2.clone = function(a) {
		    var out = Types.createFloatArray(2);
		    out[0] = a[0];
		    out[1] = a[1];
		    return out;
		};

		/**
		 * Creates a new vec2 initialized with the given values
		 *
		 * @param {Number} x X component
		 * @param {Number} y Y component
		 * @returns {vec2} a new 2d vector
		 */
		vec2.fromValues = function(x, y) {
		    var out = Types.createFloatArray(2);
		    out[0] = x;
		    out[1] = y;
		    return out;
		};

		/**
		 * Copy the values from one vec2 to another
		 *
		 * @param {vec2} out the result vector
		 * @param {vec2} a the source vector
		 * @returns {vec2} out
		 */
		vec2.copy = function(out, a) {
		    out[0] = a[0];
		    out[1] = a[1];
		    return out;
		};

		/**
		 * Set the components of a vec2 to the given values
		 *
		 * @param {vec2} out the result vector
		 * @param {Number} x X component
		 * @param {Number} y Y component
		 * @returns {vec2} out
		 */
		vec2.set = function(out, x, y) {
		    out[0] = x;
		    out[1] = y;
		    return out;
		};

		/**
		 * Adds two vectors
		 *
		 * @param {vec2} out the result vector
		 * @param {vec2} a the first operand
		 * @param {vec2} b the second operand
		 * @returns {vec2} out
		 */
		vec2.add = function(out, a, b) {
		    out[0] = a[0] + b[0];
		    out[1] = a[1] + b[1];
		    return out;
		};

		/**
		 * Subtracts vector b from vector a
		 *
		 * @param {vec2} out the result vector
		 * @param {vec2} a the first operand
		 * @param {vec2} b the second operand
		 * @returns {vec2} out
		 */
		vec2.subtract = function(out, a, b) {
		    out[0] = a[0] - b[0];
		    out[1] = a[1] - b[1];
		    return out;
		};

		/**
		 * Alias for {@link #subtract}
		 *
		 * @property {Function}
		 */
		vec2.sub = vec2.subtract;

		/**
		 * Multiplies two vectors
		 *
		 * @param {vec2} out the result vector
		 * @param {vec2} a the first operand
		 * @param {vec2} b the second operand
		 * @returns {vec2} out
		 */
		vec2.multiply = function(out, a, b) {
		    out[0] = a[0] * b[0];
		    out[1] = a[1] * b[1];
		    return out;
		};

		/**
		 * Alias for {@link #multiply}
		 *
		 * @property {Function}
		 */
		vec2.mul = vec2.multiply;

		/**
		 * Divides two vectors
		 *
		 * @param {vec2} out the result vector
		 * @param {vec2} a the first operand
		 * @param {vec2} b the second operand
		 * @returns {vec2} out
		 */
		vec2.divide = function(out, a, b) {
		    out[0] = a[0] / b[0];
		    out[1] = a[1] / b[1];
		    return out;
		};

		/**
		 * Alias for {@link #divide}
		 *
		 * @property {Function}
		 */
		vec2.div = vec2.divide;

		/**
		 * Returns the minimum of two vectors
		 *
		 * @param {vec2} out the result vector
		 * @param {vec2} a the first operand
		 * @param {vec2} b the second operand
		 * @returns {vec2} out
		 */
		vec2.min = function(out, a, b) {
		    out[0] = Math.min(a[0], b[0]);
		    out[1] = Math.min(a[1], b[1]);
		    return out;
		};

		/**
		 * Returns the maximum of two vectors
		 *
		 * @param {vec2} out the result vector
		 * @param {vec2} a the first operand
		 * @param {vec2} b the second operand
		 * @returns {vec2} out
		 */
		vec2.max = function(out, a, b) {
		    out[0] = Math.max(a[0], b[0]);
		    out[1] = Math.max(a[1], b[1]);
		    return out;
		};

		/**
		 * Scales a vec2 by a scalar number
		 *
		 * @param {vec2} out the result vector
		 * @param {vec2} a the vector to scale
		 * @param {Number} b amount to scale the vector by
		 * @returns {vec2} out
		 */
		vec2.scale = function(out, a, b) {
		    out[0] = a[0] * b;
		    out[1] = a[1] * b;
		    return out;
		};

		/**
		 * Adds two vectors after scaling the second operand by a scalar value
		 *
		 * @param {vec2} out the result vector
		 * @param {vec2} a the first operand
		 * @param {vec2} b the second operand
		 * @param {Number} scale the amount to scale b by before adding
		 * @returns {vec2} out
		 */
		vec2.scaleAndAdd = function(out, a, b, scale) {
		    out[0] = a[0] + (b[0] * scale);
		    out[1] = a[1] + (b[1] * scale);
		    return out;
		};

		/**
		 * Calculates the euclidian distance between two vectors
		 *
		 * @param {vec2} a the first operand
		 * @param {vec2} b the second operand
		 * @returns {Number} distance between a and b
		 */
		vec2.distance = function(a, b) {
		    var x = b[0] - a[0],
		        y = b[1] - a[1];
		    return Math.sqrt(x*x + y*y);
		};

		/**
		 * Alias for {@link #distance}
		 *
		 * @property {Function}
		 */
		vec2.dist = vec2.distance;

		/**
		 * Calculates the squared euclidian distance between two vectors
		 *
		 * @param {vec2} a the first operand
		 * @param {vec2} b the second operand
		 * @returns {Number} squared distance between a and b
		 */
		vec2.squaredDistance = function(a, b) {
		    var x = b[0] - a[0],
		        y = b[1] - a[1];
		    return x*x + y*y;
		};

		/**
		 * Alias for {@link #squaredDistance}
		 *
		 * @property {Function}
		 */
		vec2.sqrDist = vec2.squaredDistance;

		/**
		 * Calculates the length of a vec2
		 *
		 * @param {vec2} a vector to calculate length of
		 * @returns {Number} length of a
		 */
		vec2.length = function (a) {
		    var x = a[0],
		        y = a[1];
		    return Math.sqrt(x*x + y*y);
		};

		/**
		 * Alias for {@link #length}
		 *
		 * @property {Function}
		 */
		vec2.len = vec2.length;

		/**
		 * Calculates the squared length of a vec2
		 *
		 * @param {vec2} a vector to calculate squared length of
		 * @returns {Number} squared length of a
		 */
		vec2.squaredLength = function (a) {
		    var x = a[0],
		        y = a[1];
		    return x*x + y*y;
		};

		/**
		 * Alias for {@link #squaredLength}
		 *
		 * @property {Function}
		 */
		vec2.sqrLen = vec2.squaredLength;

		/**
		 * Negates the components of a vec2
		 *
		 * @param {vec2} out the result vector
		 * @param {vec2} a vector to negate
		 * @returns {vec2} out
		 */
		vec2.negate = function(out, a) {
		    out[0] = -a[0];
		    out[1] = -a[1];
		    return out;
		};

		/**
		 * Normalize a vec2
		 *
		 * @param {vec2} out the result vector
		 * @param {vec2} a vector to normalize
		 * @returns {vec2} out
		 */
		vec2.normalize = function(out, a) {
		    var x = a[0],
		        y = a[1];
		    var len = x*x + y*y;
		    if (len > 0) {
		        //TODO: evaluate use of glm_invsqrt here?
		        len = 1 / Math.sqrt(len);
		        out[0] = a[0] * len;
		        out[1] = a[1] * len;
		    }
		    return out;
		};

		/**
		 * Calculates the dot product of two vectors
		 *
		 * @param {vec2} a the first operand
		 * @param {vec2} b the second operand
		 * @returns {Number} dot product of a and b
		 */
		vec2.dot = function (a, b) {
		    return a[0] * b[0] + a[1] * b[1];
		};

		/**
		 * Computes the cross product of two vectors
		 * Note that the cross product must by definition produce a 3D vector
		 *
		 * @param {vec3} out the result vector
		 * @param {vec2} a the first operand
		 * @param {vec2} b the second operand
		 * @returns {vec3} out
		 */
		vec2.cross = function(out, a, b) {
		    var z = a[0] * b[1] - a[1] * b[0];
		    out[0] = out[1] = 0;
		    out[2] = z;
		    return out;
		};

		/**
		 * Performs a linear interpolation between two vectors
		 *
		 * @param {vec2} out the result vector
		 * @param {vec2} a the first operand
		 * @param {vec2} b the second operand
		 * @param {Number} t interpolation amount between the two inputs
		 * @returns {vec2} out
		 */
		vec2.lerp = function (out, a, b, t) {
		    var ax = a[0],
		        ay = a[1];
		    out[0] = ax + t * (b[0] - ax);
		    out[1] = ay + t * (b[1] - ay);
		    return out;
		};

		/**
		 * Generates a random vector with the given scale
		 *
		 * @param {vec2} out the result vector
		 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
		 * @returns {vec2} out
		 */
		vec2.random = function (out, scale) {
		    scale = scale || 1.0;
		    var r = mathUtil.random() * 2.0 * Math.PI;
		    out[0] = Math.cos(r) * scale;
		    out[1] = Math.sin(r) * scale;
		    return out;
		};

		/**
		 * Transforms the vec2 with a mat2
		 *
		 * @param {vec2} out the result vector
		 * @param {vec2} a the vector to transform
		 * @param {mat2} m matrix to transform with
		 * @returns {vec2} out
		 */
		vec2.transformMat2 = function(out, a, m) {
		    var x = a[0],
		        y = a[1];
		    out[0] = m[0] * x + m[2] * y;
		    out[1] = m[1] * x + m[3] * y;
		    return out;
		};

		/**
		 * Transforms the vec2 with a mat2d
		 *
		 * @param {vec2} out the result vector
		 * @param {vec2} a the vector to transform
		 * @param {mat2d} m matrix to transform with
		 * @returns {vec2} out
		 */
		vec2.transformMat2d = function(out, a, m) {
		    var x = a[0],
		        y = a[1];
		    out[0] = m[0] * x + m[2] * y + m[4];
		    out[1] = m[1] * x + m[3] * y + m[5];
		    return out;
		};

		/**
		 * Transforms the vec2 with a mat3
		 * 3rd vector component is implicitly '1'
		 *
		 * @param {vec2} out the result vector
		 * @param {vec2} a the vector to transform
		 * @param {mat3} m matrix to transform with
		 * @returns {vec2} out
		 */
		vec2.transformMat3 = function(out, a, m) {
		    var x = a[0],
		        y = a[1];
		    out[0] = m[0] * x + m[3] * y + m[6];
		    out[1] = m[1] * x + m[4] * y + m[7];
		    return out;
		};

		/**
		 * Transforms the vec2 with a mat4
		 * 3rd vector component is implicitly '0'
		 * 4th vector component is implicitly '1'
		 *
		 * @param {vec2} out the result vector
		 * @param {vec2} a the vector to transform
		 * @param {mat4} m matrix to transform with
		 * @returns {vec2} out
		 */
		vec2.transformMat4 = function(out, a, m) {
		    var x = a[0],
		        y = a[1];
		    out[0] = m[0] * x + m[4] * y + m[12];
		    out[1] = m[1] * x + m[5] * y + m[13];
		    return out;
		};

		/**
		 * Perform some operation over an array of vec2s.
		 *
		 * @param {Array} a the array of vectors to iterate over
		 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
		 * @param {Number} offset Number of elements to skip at the beginning of the array
		 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
		 * @param {Function} fn Function to call for each vector in the array
		 * @param {Object} [arg] additional argument to pass to fn
		 * @returns {Array} a
		 * @function
		 */
		vec2.forEach = (function() {
		    var vec = vec2.create();

		    return function(a, stride, offset, count, fn, arg) {
		        var i, l;
		        if(!stride) {
		            stride = 2;
		        }

		        if(!offset) {
		            offset = 0;
		        }

		        if(count) {
		            l = Math.min((count * stride) + offset, a.length);
		        } else {
		            l = a.length;
		        }

		        for(i = offset; i < l; i += stride) {
		            vec[0] = a[i]; vec[1] = a[i+1];
		            fn(vec, vec, arg);
		            a[i] = vec[0]; a[i+1] = vec[1];
		        }

		        return a;
		    };
		})();

		/**
		 * Returns a string representation of a vector
		 *
		 * @param {vec2} vec vector to represent as a string
		 * @returns {String} string representation of the vector
		 */
		vec2.str = function (a) {
		    return 'vec2(' + a[0] + ', ' + a[1] + ')';
		};

		return vec2;
	}
)

/*
 * This file is derived from glMatrix 2.1.0. Original Licence follows:
 */

/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */


define(
	'spell/math/vec4',
	[
		'spell/shared/util/platform/Types',
		'spell/math/util'
	],
	function(
		Types,
		mathUtil
	) {
		'use strict'


		/**
		 * 4d vector functions
		 *
		 * @class spell.math.vec4
		 * @singleton
		 * @requires Math
		 * @requires spell.shared.util.platform.Types
		 * @requires spell.math.util
		 */
		var vec4 = {};

		/**
		 * Creates a new, empty vec4
		 *
		 * @returns {vec4} a new 4d vector
		 */
		vec4.create = function() {
		    var out = Types.createFloatArray(4);
		    out[0] = 0;
		    out[1] = 0;
		    out[2] = 0;
		    out[3] = 0;
		    return out;
		};

		/**
		 * Creates a new vec4 initialized with values from an existing vector
		 *
		 * @param {vec4} a vector to clone
		 * @returns {vec4} a new 4d vector
		 */
		vec4.clone = function(a) {
		    var out = Types.createFloatArray(4);
		    out[0] = a[0];
		    out[1] = a[1];
		    out[2] = a[2];
		    out[3] = a[3];
		    return out;
		};

		/**
		 * Creates a new vec4 initialized with the given values
		 *
		 * @param {Number} x X component
		 * @param {Number} y Y component
		 * @param {Number} z Z component
		 * @param {Number} w W component
		 * @returns {vec4} a new 4d vector
		 */
		vec4.fromValues = function(x, y, z, w) {
		    var out = Types.createFloatArray(4);
		    out[0] = x;
		    out[1] = y;
		    out[2] = z;
		    out[3] = w;
		    return out;
		};

		/**
		 * Copy the values from one vec4 to another
		 *
		 * @param {vec4} out the result vector
		 * @param {vec4} a the source vector
		 * @returns {vec4} out
		 */
		vec4.copy = function(out, a) {
		    out[0] = a[0];
		    out[1] = a[1];
		    out[2] = a[2];
		    out[3] = a[3];
		    return out;
		};

		/**
		 * Set the components of a vec4 to the given values
		 *
		 * @param {vec4} out the result vector
		 * @param {Number} x X component
		 * @param {Number} y Y component
		 * @param {Number} z Z component
		 * @param {Number} w W component
		 * @returns {vec4} out
		 */
		vec4.set = function(out, x, y, z, w) {
		    out[0] = x;
		    out[1] = y;
		    out[2] = z;
		    out[3] = w;
		    return out;
		};

		/**
		 * Adds two vectors
		 *
		 * @param {vec4} out the result vector
		 * @param {vec4} a the first operand
		 * @param {vec4} b the second operand
		 * @returns {vec4} out
		 */
		vec4.add = function(out, a, b) {
		    out[0] = a[0] + b[0];
		    out[1] = a[1] + b[1];
		    out[2] = a[2] + b[2];
		    out[3] = a[3] + b[3];
		    return out;
		};

		/**
		 * Subtracts vector b from vector a
		 *
		 * @param {vec4} out the result vector
		 * @param {vec4} a the first operand
		 * @param {vec4} b the second operand
		 * @returns {vec4} out
		 */
		vec4.subtract = function(out, a, b) {
		    out[0] = a[0] - b[0];
		    out[1] = a[1] - b[1];
		    out[2] = a[2] - b[2];
		    out[3] = a[3] - b[3];
		    return out;
		};

		/**
		 * Alias for {@link #subtract}
		 *
		 * @property {Function}
		 */
		vec4.sub = vec4.subtract;

		/**
		 * Multiplies two vectors
		 *
		 * @param {vec4} out the result vector
		 * @param {vec4} a the first operand
		 * @param {vec4} b the second operand
		 * @returns {vec4} out
		 */
		vec4.multiply = function(out, a, b) {
		    out[0] = a[0] * b[0];
		    out[1] = a[1] * b[1];
		    out[2] = a[2] * b[2];
		    out[3] = a[3] * b[3];
		    return out;
		};

		/**
		 * Alias for {@link #multiply}
		 *
		 * @property {Function}
		 */
		vec4.mul = vec4.multiply;

		/**
		 * Divides two vectors
		 *
		 * @param {vec4} out the result vector
		 * @param {vec4} a the first operand
		 * @param {vec4} b the second operand
		 * @returns {vec4} out
		 */
		vec4.divide = function(out, a, b) {
		    out[0] = a[0] / b[0];
		    out[1] = a[1] / b[1];
		    out[2] = a[2] / b[2];
		    out[3] = a[3] / b[3];
		    return out;
		};

		/**
		 * Alias for {@link #divide}
		 *
		 * @property {Function}
		 */
		vec4.div = vec4.divide;

		/**
		 * Returns the minimum of two vectors
		 *
		 * @param {vec4} out the result vector
		 * @param {vec4} a the first operand
		 * @param {vec4} b the second operand
		 * @returns {vec4} out
		 */
		vec4.min = function(out, a, b) {
		    out[0] = Math.min(a[0], b[0]);
		    out[1] = Math.min(a[1], b[1]);
		    out[2] = Math.min(a[2], b[2]);
		    out[3] = Math.min(a[3], b[3]);
		    return out;
		};

		/**
		 * Returns the maximum of two vectors
		 *
		 * @param {vec4} out the result vector
		 * @param {vec4} a the first operand
		 * @param {vec4} b the second operand
		 * @returns {vec4} out
		 */
		vec4.max = function(out, a, b) {
		    out[0] = Math.max(a[0], b[0]);
		    out[1] = Math.max(a[1], b[1]);
		    out[2] = Math.max(a[2], b[2]);
		    out[3] = Math.max(a[3], b[3]);
		    return out;
		};

		/**
		 * Scales a vec4 by a scalar number
		 *
		 * @param {vec4} out the result vector
		 * @param {vec4} a the vector to scale
		 * @param {Number} b amount to scale the vector by
		 * @returns {vec4} out
		 */
		vec4.scale = function(out, a, b) {
		    out[0] = a[0] * b;
		    out[1] = a[1] * b;
		    out[2] = a[2] * b;
		    out[3] = a[3] * b;
		    return out;
		};

		/**
		 * Adds two vectors after scaling the second operand by a scalar value
		 *
		 * @param {vec4} out the result vector
		 * @param {vec4} a the first operand
		 * @param {vec4} b the second operand
		 * @param {Number} scale the amount to scale b by before adding
		 * @returns {vec4} out
		 */
		vec4.scaleAndAdd = function(out, a, b, scale) {
		    out[0] = a[0] + (b[0] * scale);
		    out[1] = a[1] + (b[1] * scale);
		    out[2] = a[2] + (b[2] * scale);
		    out[3] = a[3] + (b[3] * scale);
		    return out;
		};

		/**
		 * Calculates the euclidian distance between two vectors
		 *
		 * @param {vec4} a the first operand
		 * @param {vec4} b the second operand
		 * @returns {Number} distance between a and b
		 */
		vec4.distance = function(a, b) {
		    var x = b[0] - a[0],
		        y = b[1] - a[1],
		        z = b[2] - a[2],
		        w = b[3] - a[3];
		    return Math.sqrt(x*x + y*y + z*z + w*w);
		};

		/**
		 * Alias for {@link #distance}
		 *
		 * @property {Function}
		 */
		vec4.dist = vec4.distance;

		/**
		 * Calculates the squared euclidian distance between two vectors
		 *
		 * @param {vec4} a the first operand
		 * @param {vec4} b the second operand
		 * @returns {Number} squared distance between a and b
		 */
		vec4.squaredDistance = function(a, b) {
		    var x = b[0] - a[0],
		        y = b[1] - a[1],
		        z = b[2] - a[2],
		        w = b[3] - a[3];
		    return x*x + y*y + z*z + w*w;
		};

		/**
		 * Alias for {@link #squaredDistance}
		 *
		 * @property {Function}
		 */
		vec4.sqrDist = vec4.squaredDistance;

		/**
		 * Calculates the length of a vec4
		 *
		 * @param {vec4} a vector to calculate length of
		 * @returns {Number} length of a
		 */
		vec4.length = function (a) {
		    var x = a[0],
		        y = a[1],
		        z = a[2],
		        w = a[3];
		    return Math.sqrt(x*x + y*y + z*z + w*w);
		};

		/**
		 * Alias for {@link #length}
		 *
		 * @property {Function}
		 */
		vec4.len = vec4.length;

		/**
		 * Calculates the squared length of a vec4
		 *
		 * @param {vec4} a vector to calculate squared length of
		 * @returns {Number} squared length of a
		 */
		vec4.squaredLength = function (a) {
		    var x = a[0],
		        y = a[1],
		        z = a[2],
		        w = a[3];
		    return x*x + y*y + z*z + w*w;
		};

		/**
		 * Alias for {@link #squaredLength}
		 *
		 * @property {Function}
		 */
		vec4.sqrLen = vec4.squaredLength;

		/**
		 * Negates the components of a vec4
		 *
		 * @param {vec4} out the result vector
		 * @param {vec4} a vector to negate
		 * @returns {vec4} out
		 */
		vec4.negate = function(out, a) {
		    out[0] = -a[0];
		    out[1] = -a[1];
		    out[2] = -a[2];
		    out[3] = -a[3];
		    return out;
		};

		/**
		 * Normalize a vec4
		 *
		 * @param {vec4} out the result vector
		 * @param {vec4} a vector to normalize
		 * @returns {vec4} out
		 */
		vec4.normalize = function(out, a) {
		    var x = a[0],
		        y = a[1],
		        z = a[2],
		        w = a[3];
		    var len = x*x + y*y + z*z + w*w;
		    if (len > 0) {
		        len = 1 / Math.sqrt(len);
		        out[0] = a[0] * len;
		        out[1] = a[1] * len;
		        out[2] = a[2] * len;
		        out[3] = a[3] * len;
		    }
		    return out;
		};

		/**
		 * Calculates the dot product of two vectors
		 *
		 * @param {vec4} a the first operand
		 * @param {vec4} b the second operand
		 * @returns {Number} dot product of a and b
		 */
		vec4.dot = function (a, b) {
		    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
		};

		/**
		 * Performs a linear interpolation between two vectors
		 *
		 * @param {vec4} out the result vector
		 * @param {vec4} a the first operand
		 * @param {vec4} b the second operand
		 * @param {Number} t interpolation amount between the two inputs
		 * @returns {vec4} out
		 */
		vec4.lerp = function (out, a, b, t) {
		    var ax = a[0],
		        ay = a[1],
		        az = a[2],
		        aw = a[3];
		    out[0] = ax + t * (b[0] - ax);
		    out[1] = ay + t * (b[1] - ay);
		    out[2] = az + t * (b[2] - az);
		    out[3] = aw + t * (b[3] - aw);
		    return out;
		};

		/**
		 * Generates a random vector with the given scale
		 *
		 * @param {vec4} out the result vector
		 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
		 * @returns {vec4} out
		 */
		vec4.random = function (out, scale) {
		    scale = scale || 1.0;

		    //TODO: This is a pretty awful way of doing this. Find something better.
		    out[0] = mathUtil.random();
		    out[1] = mathUtil.random();
		    out[2] = mathUtil.random();
		    out[3] = mathUtil.random();
		    vec4.normalize(out, out);
		    vec4.scale(out, out, scale);
		    return out;
		};

		/**
		 * Transforms the vec4 with a mat4.
		 *
		 * @param {vec4} out the result vector
		 * @param {vec4} a the vector to transform
		 * @param {mat4} m matrix to transform with
		 * @returns {vec4} out
		 */
		vec4.transformMat4 = function(out, a, m) {
		    var x = a[0], y = a[1], z = a[2], w = a[3];
		    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
		    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
		    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
		    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
		    return out;
		};

		/**
		 * Transforms the vec4 with a quat
		 *
		 * @param {vec4} out the result vector
		 * @param {vec4} a the vector to transform
		 * @param {quat} q quaternion to transform with
		 * @returns {vec4} out
		 */
		vec4.transformQuat = function(out, a, q) {
		    var x = a[0], y = a[1], z = a[2],
		        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

		        // calculate quat * vec
		        ix = qw * x + qy * z - qz * y,
		        iy = qw * y + qz * x - qx * z,
		        iz = qw * z + qx * y - qy * x,
		        iw = -qx * x - qy * y - qz * z;

		    // calculate result * inverse quat
		    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
		    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
		    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
		    return out;
		};

		/**
		 * Perform some operation over an array of vectors.
		 *
		 * @param {Array} a the array of vectors to iterate over
		 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
		 * @param {Number} offset Number of elements to skip at the beginning of the array
		 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
		 * @param {Function} fn Function to call for each vector in the array
		 * @param {Object} [arg] additional argument to pass to fn
		 * @returns {Array} a
		 * @function
		 */
		vec4.forEach = (function() {
		    var vec = vec4.create();

		    return function(a, stride, offset, count, fn, arg) {
		        var i, l;
		        if(!stride) {
		            stride = 4;
		        }

		        if(!offset) {
		            offset = 0;
		        }

		        if(count) {
		            l = Math.min((count * stride) + offset, a.length);
		        } else {
		            l = a.length;
		        }

		        for(i = offset; i < l; i += stride) {
		            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2]; vec[3] = a[i+3];
		            fn(vec, vec, arg);
		            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2]; a[i+3] = vec[3];
		        }

		        return a;
		    };
		})();

		/**
		 * Returns a string representation of a vector
		 *
		 * @param {vec4} vec vector to represent as a string
		 * @returns {String} string representation of the vector
		 */
		vec4.str = function (a) {
		    return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
		};

		return vec4;
	}
)

/*
 * This file is derived from glMatrix 2.1.0. Original Licence follows:
 */

/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */


define(
	'spell/math/vec3',
	[
		'spell/shared/util/platform/Types',
		'spell/math/util'
	],
	function(
		Types,
		mathUtil
	) {
		'use strict'


		/**
		 * 3d vector functions
		 *
		 * @class spell.math.vec3
		 * @singleton
		 * @requires Math
		 * @requires spell.shared.util.platform.Types
		 * @requires spell.math.util
		 */
		var vec3 = {};

		/**
		 * Creates a new, empty vec3
		 *
		 * @returns {vec3} a new 3d vector
		 */
		vec3.create = function() {
		    var out = Types.createFloatArray(3);
		    out[0] = 0;
		    out[1] = 0;
		    out[2] = 0;
		    return out;
		};

		/**
		 * Creates a new vec3 initialized with values from an existing vector
		 *
		 * @param {vec3} a vector to clone
		 * @returns {vec3} a new 3d vector
		 */
		vec3.clone = function(a) {
		    var out = Types.createFloatArray(3);
		    out[0] = a[0];
		    out[1] = a[1];
		    out[2] = a[2];
		    return out;
		};

		/**
		 * Creates a new vec3 initialized with the given values
		 *
		 * @param {Number} x X component
		 * @param {Number} y Y component
		 * @param {Number} z Z component
		 * @returns {vec3} a new 3d vector
		 */
		vec3.fromValues = function(x, y, z) {
		    var out = Types.createFloatArray(3);
		    out[0] = x;
		    out[1] = y;
		    out[2] = z;
		    return out;
		};

		/**
		 * Copy the values from one vec3 to another
		 *
		 * @param {vec3} out the result vector
		 * @param {vec3} a the source vector
		 * @returns {vec3} out
		 */
		vec3.copy = function(out, a) {
		    out[0] = a[0];
		    out[1] = a[1];
		    out[2] = a[2];
		    return out;
		};

		/**
		 * Set the components of a vec3 to the given values
		 *
		 * @param {vec3} out the result vector
		 * @param {Number} x X component
		 * @param {Number} y Y component
		 * @param {Number} z Z component
		 * @returns {vec3} out
		 */
		vec3.set = function(out, x, y, z) {
		    out[0] = x;
		    out[1] = y;
		    out[2] = z;
		    return out;
		};

		/**
		 * Adds two vectors
		 *
		 * @param {vec3} out the result vector
		 * @param {vec3} a the first operand
		 * @param {vec3} b the second operand
		 * @returns {vec3} out
		 */
		vec3.add = function(out, a, b) {
		    out[0] = a[0] + b[0];
		    out[1] = a[1] + b[1];
		    out[2] = a[2] + b[2];
		    return out;
		};

		/**
		 * Subtracts vector b from vector a
		 *
		 * @param {vec3} out the result vector
		 * @param {vec3} a the first operand
		 * @param {vec3} b the second operand
		 * @returns {vec3} out
		 */
		vec3.subtract = function(out, a, b) {
		    out[0] = a[0] - b[0];
		    out[1] = a[1] - b[1];
		    out[2] = a[2] - b[2];
		    return out;
		};

		/**
		 * Alias for {@link #subtract}
		 *
		 * @property {Function}
		 */
		vec3.sub = vec3.subtract;

		/**
		 * Multiplies two vectors
		 *
		 * @param {vec3} out the result vector
		 * @param {vec3} a the first operand
		 * @param {vec3} b the second operand
		 * @returns {vec3} out
		 */
		vec3.multiply = function(out, a, b) {
		    out[0] = a[0] * b[0];
		    out[1] = a[1] * b[1];
		    out[2] = a[2] * b[2];
		    return out;
		};

		/**
		 * Alias for {@link #multiply}
		 *
		 * @property {Function}
		 */
		vec3.mul = vec3.multiply;

		/**
		 * Divides two vectors
		 *
		 * @param {vec3} out the result vector
		 * @param {vec3} a the first operand
		 * @param {vec3} b the second operand
		 * @returns {vec3} out
		 */
		vec3.divide = function(out, a, b) {
		    out[0] = a[0] / b[0];
		    out[1] = a[1] / b[1];
		    out[2] = a[2] / b[2];
		    return out;
		};

		/**
		 * Alias for {@link #divide}
		 *
		 * @property {Function}
		 */
		vec3.div = vec3.divide;

		/**
		 * Returns the minimum of two vectors
		 *
		 * @param {vec3} out the result vector
		 * @param {vec3} a the first operand
		 * @param {vec3} b the second operand
		 * @returns {vec3} out
		 */
		vec3.min = function(out, a, b) {
		    out[0] = Math.min(a[0], b[0]);
		    out[1] = Math.min(a[1], b[1]);
		    out[2] = Math.min(a[2], b[2]);
		    return out;
		};

		/**
		 * Returns the maximum of two vectors
		 *
		 * @param {vec3} out the result vector
		 * @param {vec3} a the first operand
		 * @param {vec3} b the second operand
		 * @returns {vec3} out
		 */
		vec3.max = function(out, a, b) {
		    out[0] = Math.max(a[0], b[0]);
		    out[1] = Math.max(a[1], b[1]);
		    out[2] = Math.max(a[2], b[2]);
		    return out;
		};

		/**
		 * Scales a vec3 by a scalar number
		 *
		 * @param {vec3} out the result vector
		 * @param {vec3} a the vector to scale
		 * @param {Number} b amount to scale the vector by
		 * @returns {vec3} out
		 */
		vec3.scale = function(out, a, b) {
		    out[0] = a[0] * b;
		    out[1] = a[1] * b;
		    out[2] = a[2] * b;
		    return out;
		};

		/**
		 * Adds two vectors after scaling the second operand by a scalar value
		 *
		 * @param {vec3} out the result vector
		 * @param {vec3} a the first operand
		 * @param {vec3} b the second operand
		 * @param {Number} scale the amount to scale b by before adding
		 * @returns {vec3} out
		 */
		vec3.scaleAndAdd = function(out, a, b, scale) {
		    out[0] = a[0] + (b[0] * scale);
		    out[1] = a[1] + (b[1] * scale);
		    out[2] = a[2] + (b[2] * scale);
		    return out;
		};

		/**
		 * Calculates the euclidian distance between two vectors
		 *
		 * @param {vec3} a the first operand
		 * @param {vec3} b the second operand
		 * @returns {Number} distance between a and b
		 */
		vec3.distance = function(a, b) {
		    var x = b[0] - a[0],
		        y = b[1] - a[1],
		        z = b[2] - a[2];
		    return Math.sqrt(x*x + y*y + z*z);
		};

		/**
		 * Alias for {@link #distance}
		 *
		 * @property {Function}
		 */
		vec3.dist = vec3.distance;

		/**
		 * Calculates the squared euclidian distance between two vectors
		 *
		 * @param {vec3} a the first operand
		 * @param {vec3} b the second operand
		 * @returns {Number} squared distance between a and b
		 */
		vec3.squaredDistance = function(a, b) {
		    var x = b[0] - a[0],
		        y = b[1] - a[1],
		        z = b[2] - a[2];
		    return x*x + y*y + z*z;
		};

		/**
		 * Alias for {@link #squaredDistance}
		 *
		 * @property {Function}
		 */
		vec3.sqrDist = vec3.squaredDistance;

		/**
		 * Calculates the length of a vec3
		 *
		 * @param {vec3} a vector to calculate length of
		 * @returns {Number} length of a
		 */
		vec3.length = function (a) {
		    var x = a[0],
		        y = a[1],
		        z = a[2];
		    return Math.sqrt(x*x + y*y + z*z);
		};

		/**
		 * Alias for {@link #length}
		 *
		 * @property {Function}
		 */
		vec3.len = vec3.length;

		/**
		 * Calculates the squared length of a vec3
		 *
		 * @param {vec3} a vector to calculate squared length of
		 * @returns {Number} squared length of a
		 */
		vec3.squaredLength = function (a) {
		    var x = a[0],
		        y = a[1],
		        z = a[2];
		    return x*x + y*y + z*z;
		};

		/**
		 * Alias for {@link #squaredLength}
		 *
		 * @property {Function}
		 */
		vec3.sqrLen = vec3.squaredLength;

		/**
		 * Negates the components of a vec3
		 *
		 * @param {vec3} out the result vector
		 * @param {vec3} a vector to negate
		 * @returns {vec3} out
		 */
		vec3.negate = function(out, a) {
		    out[0] = -a[0];
		    out[1] = -a[1];
		    out[2] = -a[2];
		    return out;
		};

		/**
		 * Normalize a vec3
		 *
		 * @param {vec3} out the result vector
		 * @param {vec3} a vector to normalize
		 * @returns {vec3} out
		 */
		vec3.normalize = function(out, a) {
		    var x = a[0],
		        y = a[1],
		        z = a[2];
		    var len = x*x + y*y + z*z;
		    if (len > 0) {
		        //TODO: evaluate use of glm_invsqrt here?
		        len = 1 / Math.sqrt(len);
		        out[0] = a[0] * len;
		        out[1] = a[1] * len;
		        out[2] = a[2] * len;
		    }
		    return out;
		};

		/**
		 * Calculates the dot product of two vectors
		 *
		 * @param {vec3} a the first operand
		 * @param {vec3} b the second operand
		 * @returns {Number} dot product of a and b
		 */
		vec3.dot = function (a, b) {
		    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
		};

		/**
		 * Computes the cross product of two vectors
		 *
		 * @param {vec3} out the result vector
		 * @param {vec3} a the first operand
		 * @param {vec3} b the second operand
		 * @returns {vec3} out
		 */
		vec3.cross = function(out, a, b) {
		    var ax = a[0], ay = a[1], az = a[2],
		        bx = b[0], by = b[1], bz = b[2];

		    out[0] = ay * bz - az * by;
		    out[1] = az * bx - ax * bz;
		    out[2] = ax * by - ay * bx;
		    return out;
		};

		/**
		 * Performs a linear interpolation between two vectors
		 *
		 * @param {vec3} out the result vector
		 * @param {vec3} a the first operand
		 * @param {vec3} b the second operand
		 * @param {Number} t interpolation amount between the two inputs
		 * @returns {vec3} out
		 */
		vec3.lerp = function (out, a, b, t) {
		    var ax = a[0],
		        ay = a[1],
		        az = a[2];
		    out[0] = ax + t * (b[0] - ax);
		    out[1] = ay + t * (b[1] - ay);
		    out[2] = az + t * (b[2] - az);
		    return out;
		};

		/**
		 * Generates a random vector with the given scale
		 *
		 * @param {vec3} out the result vector
		 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
		 * @returns {vec3} out
		 */
		vec3.random = function (out, scale) {
		    scale = scale || 1.0;

		    var r = mathUtil.random() * 2.0 * Math.PI;
		    var z = (mathUtil.random() * 2.0) - 1.0;
		    var zScale = Math.sqrt(1.0-z*z) * scale;

		    out[0] = Math.cos(r) * zScale;
		    out[1] = Math.sin(r) * zScale;
		    out[2] = z * scale;
		    return out;
		};

		/**
		 * Transforms the vec3 with a mat4.
		 * 4th vector component is implicitly '1'
		 *
		 * @param {vec3} out the result vector
		 * @param {vec3} a the vector to transform
		 * @param {mat4} m matrix to transform with
		 * @returns {vec3} out
		 */
		vec3.transformMat4 = function(out, a, m) {
		    var x = a[0], y = a[1], z = a[2];
		    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12];
		    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13];
		    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14];
		    return out;
		};

		/**
		 * Transforms the vec3 with a mat3.
		 *
		 * @param {vec3} out the result vector
		 * @param {vec3} a the vector to transform
		 * @param {mat4} m the 3x3 matrix to transform with
		 * @returns {vec3} out
		 */
		vec3.transformMat3 = function(out, a, m) {
		    var x = a[0], y = a[1], z = a[2];
		    out[0] = x * m[0] + y * m[3] + z * m[6];
		    out[1] = x * m[1] + y * m[4] + z * m[7];
		    out[2] = x * m[2] + y * m[5] + z * m[8];
		    return out;
		};

		/**
		 * Transforms the vec3 with a quat
		 *
		 * @param {vec3} out the result vector
		 * @param {vec3} a the vector to transform
		 * @param {quat} q quaternion to transform with
		 * @returns {vec3} out
		 */
		vec3.transformQuat = function(out, a, q) {
		    // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

		    var x = a[0], y = a[1], z = a[2],
		        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

		        // calculate quat * vec
		        ix = qw * x + qy * z - qz * y,
		        iy = qw * y + qz * x - qx * z,
		        iz = qw * z + qx * y - qy * x,
		        iw = -qx * x - qy * y - qz * z;

		    // calculate result * inverse quat
		    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
		    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
		    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
		    return out;
		};

		/**
		 * Perform some operation over an array of vec3s.
		 *
		 * @param {Array} a the array of vectors to iterate over
		 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
		 * @param {Number} offset Number of elements to skip at the beginning of the array
		 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
		 * @param {Function} fn Function to call for each vector in the array
		 * @param {Object} [arg] additional argument to pass to fn
		 * @returns {Array} a
		 * @function
		 */
		vec3.forEach = (function() {
		    var vec = vec3.create();

		    return function(a, stride, offset, count, fn, arg) {
		        var i, l;
		        if(!stride) {
		            stride = 3;
		        }

		        if(!offset) {
		            offset = 0;
		        }

		        if(count) {
		            l = Math.min((count * stride) + offset, a.length);
		        } else {
		            l = a.length;
		        }

		        for(i = offset; i < l; i += stride) {
		            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2];
		            fn(vec, vec, arg);
		            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2];
		        }

		        return a;
		    };
		})();

		/**
		 * Returns a string representation of a vector
		 *
		 * @param {vec3} vec vector to represent as a string
		 * @returns {String} string representation of the vector
		 */
		vec3.str = function (a) {
		    return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
		};

		return vec3;
	}
)

/*
 * This file is derived from glMatrix 2.1.0. Original Licence follows:
 */

/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */


define(
	'spell/math/quat',
	[
		'spell/shared/util/platform/Types',
		'spell/math/vec3',
		'spell/math/vec4',
		'spell/math/mat3'
	],
	function(
		Types,
		vec3,
		vec4,
		mat3
	) {
		'use strict'

		/**
		 * quaternion functions
		 *
		 * @class spell.math.quat
		 * @singleton
		 * @requires Math
		 * @requires spell.shared.util.platform.Types
		 * @requires spell.math.vec3
		 * @requires spell.math.vec4
		 * @requires spell.math.mat3
		 */
		var quat = {};

		/**
		 * Creates a new identity quat
		 *
		 * @returns {quat} a new quaternion
		 */
		quat.create = function() {
		    var out = Types.createFloatArray(4);
		    out[0] = 0;
		    out[1] = 0;
		    out[2] = 0;
		    out[3] = 1;
		    return out;
		};

		/**
		 * Sets a quaternion to represent the shortest rotation from one
		 * vector to another.
		 *
		 * Both vectors are assumed to be unit length.
		 *
		 * @param {quat} out the receiving quaternion.
		 * @param {vec3} a the initial vector
		 * @param {vec3} b the destination vector
		 * @returns {quat} out
		 */
		quat.rotationTo = (function() {
		    var tmpvec3 = vec3.create();
		    var xUnitVec3 = vec3.fromValues(1,0,0);
		    var yUnitVec3 = vec3.fromValues(0,1,0);

		    return function(out, a, b) {
		        var dot = vec3.dot(a, b);
		        if (dot < -0.999999) {
		            vec3.cross(tmpvec3, xUnitVec3, a);
		            if (vec3.length(tmpvec3) < 0.000001)
		                vec3.cross(tmpvec3, yUnitVec3, a);
		            vec3.normalize(tmpvec3, tmpvec3);
		            quat.setAxisAngle(out, tmpvec3, Math.PI);
		            return out;
		        } else if (dot > 0.999999) {
		            out[0] = 0;
		            out[1] = 0;
		            out[2] = 0;
		            out[3] = 1;
		            return out;
		        } else {
		            vec3.cross(tmpvec3, a, b);
		            out[0] = tmpvec3[0];
		            out[1] = tmpvec3[1];
		            out[2] = tmpvec3[2];
		            out[3] = 1 + dot;
		            return quat.normalize(out, out);
		        }
		    };
		})();

		/**
		 * Sets the specified quaternion with values corresponding to the given
		 * axes. Each axis is a vec3 and is expected to be unit length and
		 * perpendicular to all other specified axes.
		 *
		 * @param {vec3} view  the vector representing the viewing direction
		 * @param {vec3} right the vector representing the local "right" direction
		 * @param {vec3} up    the vector representing the local "up" direction
		 * @returns {quat} out
		 */
		quat.setAxes = (function() {
		    var matr = mat3.create();

		    return function(out, view, right, up) {
		        matr[0] = right[0];
		        matr[3] = right[1];
		        matr[6] = right[2];

		        matr[1] = up[0];
		        matr[4] = up[1];
		        matr[7] = up[2];

		        matr[2] = view[0];
		        matr[5] = view[1];
		        matr[8] = view[2];

		        return quat.normalize(out, quat.fromMat3(out, matr));
		    };
		})();

		/**
		 * Creates a new quat initialized with values from an existing quaternion
		 *
		 * @param {quat} a quaternion to clone
		 * @returns {quat} a new quaternion
		 * @function
		 */
		quat.clone = vec4.clone;

		/**
		 * Creates a new quat initialized with the given values
		 *
		 * @param {Number} x X component
		 * @param {Number} y Y component
		 * @param {Number} z Z component
		 * @param {Number} w W component
		 * @returns {quat} a new quaternion
		 * @function
		 */
		quat.fromValues = vec4.fromValues;

		/**
		 * Copy the values from one quat to another
		 *
		 * @param {quat} out the receiving quaternion
		 * @param {quat} a the source quaternion
		 * @returns {quat} out
		 * @function
		 */
		quat.copy = vec4.copy;

		/**
		 * Set the components of a quat to the given values
		 *
		 * @param {quat} out the receiving quaternion
		 * @param {Number} x X component
		 * @param {Number} y Y component
		 * @param {Number} z Z component
		 * @param {Number} w W component
		 * @returns {quat} out
		 * @function
		 */
		quat.set = vec4.set;

		/**
		 * Set a quat to the identity quaternion
		 *
		 * @param {quat} out the receiving quaternion
		 * @returns {quat} out
		 */
		quat.identity = function(out) {
		    out[0] = 0;
		    out[1] = 0;
		    out[2] = 0;
		    out[3] = 1;
		    return out;
		};

		/**
		 * Sets a quat from the given angle and rotation axis,
		 * then returns it.
		 *
		 * @param {quat} out the receiving quaternion
		 * @param {vec3} axis the axis around which to rotate
		 * @param {Number} rad the angle in radians
		 * @returns {quat} out
		 **/
		quat.setAxisAngle = function(out, axis, rad) {
		    rad = rad * 0.5;
		    var s = Math.sin(rad);
		    out[0] = s * axis[0];
		    out[1] = s * axis[1];
		    out[2] = s * axis[2];
		    out[3] = Math.cos(rad);
		    return out;
		};

		/**
		 * Adds two quaternions
		 *
		 * @param {quat} out the receiving quaternion
		 * @param {quat} a the first operand
		 * @param {quat} b the second operand
		 * @returns {quat} out
		 * @function
		 */
		quat.add = vec4.add;

		/**
		 * Multiplies two quaternions
		 *
		 * @param {quat} out the receiving quaternion
		 * @param {quat} a the first operand
		 * @param {quat} b the second operand
		 * @returns {quat} out
		 */
		quat.multiply = function(out, a, b) {
		    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
		        bx = b[0], by = b[1], bz = b[2], bw = b[3];

		    out[0] = ax * bw + aw * bx + ay * bz - az * by;
		    out[1] = ay * bw + aw * by + az * bx - ax * bz;
		    out[2] = az * bw + aw * bz + ax * by - ay * bx;
		    out[3] = aw * bw - ax * bx - ay * by - az * bz;
		    return out;
		};

		/**
		 * Alias for {@link #multiply}
		 *
		 * @property {Function}
		 */
		quat.mul = quat.multiply;

		/**
		 * Scales a quat by a scalar number
		 *
		 * @param {quat} out the receiving vector
		 * @param {quat} a the vector to scale
		 * @param {Number} b amount to scale the vector by
		 * @returns {quat} out
		 * @function
		 */
		quat.scale = vec4.scale;

		/**
		 * Rotates a quaternion by the given angle about the X axis
		 *
		 * @param {quat} out quat receiving operation result
		 * @param {quat} a quat to rotate
		 * @param {number} rad angle (in radians) to rotate
		 * @returns {quat} out
		 */
		quat.rotateX = function (out, a, rad) {
		    rad *= 0.5;

		    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
		        bx = Math.sin(rad), bw = Math.cos(rad);

		    out[0] = ax * bw + aw * bx;
		    out[1] = ay * bw + az * bx;
		    out[2] = az * bw - ay * bx;
		    out[3] = aw * bw - ax * bx;
		    return out;
		};

		/**
		 * Rotates a quaternion by the given angle about the Y axis
		 *
		 * @param {quat} out quat receiving operation result
		 * @param {quat} a quat to rotate
		 * @param {number} rad angle (in radians) to rotate
		 * @returns {quat} out
		 */
		quat.rotateY = function (out, a, rad) {
		    rad *= 0.5;

		    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
		        by = Math.sin(rad), bw = Math.cos(rad);

		    out[0] = ax * bw - az * by;
		    out[1] = ay * bw + aw * by;
		    out[2] = az * bw + ax * by;
		    out[3] = aw * bw - ay * by;
		    return out;
		};

		/**
		 * Rotates a quaternion by the given angle about the Z axis
		 *
		 * @param {quat} out quat receiving operation result
		 * @param {quat} a quat to rotate
		 * @param {number} rad angle (in radians) to rotate
		 * @returns {quat} out
		 */
		quat.rotateZ = function (out, a, rad) {
		    rad *= 0.5;

		    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
		        bz = Math.sin(rad), bw = Math.cos(rad);

		    out[0] = ax * bw + ay * bz;
		    out[1] = ay * bw - ax * bz;
		    out[2] = az * bw + aw * bz;
		    out[3] = aw * bw - az * bz;
		    return out;
		};

		/**
		 * Calculates the W component of a quat from the X, Y, and Z components.
		 * Assumes that quaternion is 1 unit in length.
		 * Any existing W component will be ignored.
		 *
		 * @param {quat} out the receiving quaternion
		 * @param {quat} a quat to calculate W component of
		 * @returns {quat} out
		 */
		quat.calculateW = function (out, a) {
		    var x = a[0], y = a[1], z = a[2];

		    out[0] = x;
		    out[1] = y;
		    out[2] = z;
		    out[3] = -Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
		    return out;
		};

		/**
		 * Calculates the dot product of two quaternions
		 *
		 * @param {quat} a the first operand
		 * @param {quat} b the second operand
		 * @returns {Number} dot product of a and b
		 * @function
		 */
		quat.dot = vec4.dot;

		/**
		 * Performs a linear interpolation between two quaternions
		 *
		 * @param {quat} out the receiving quaternion
		 * @param {quat} a the first operand
		 * @param {quat} b the second operand
		 * @param {Number} t interpolation amount between the two inputs
		 * @returns {quat} out
		 * @function
		 */
		quat.lerp = vec4.lerp;

		/**
		 * Performs a spherical linear interpolation between two quat
		 *
		 * @param {quat} out the receiving quaternion
		 * @param {quat} a the first operand
		 * @param {quat} b the second operand
		 * @param {Number} t interpolation amount between the two inputs
		 * @returns {quat} out
		 */
		quat.slerp = function (out, a, b, t) {
		    // benchmarks:
		    //    http://jsperf.com/quaternion-slerp-implementations

		    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
		        bx = b[0], by = b[1], bz = b[2], bw = b[3];

		    var        omega, cosom, sinom, scale0, scale1;

		    // calc cosine
		    cosom = ax * bx + ay * by + az * bz + aw * bw;
		    // adjust signs (if necessary)
		    if ( cosom < 0.0 ) {
		        cosom = -cosom;
		        bx = - bx;
		        by = - by;
		        bz = - bz;
		        bw = - bw;
		    }
		    // calculate coefficients
		    if ( (1.0 - cosom) > 0.000001 ) {
		        // standard case (slerp)
		        omega  = Math.acos(cosom);
		        sinom  = Math.sin(omega);
		        scale0 = Math.sin((1.0 - t) * omega) / sinom;
		        scale1 = Math.sin(t * omega) / sinom;
		    } else {
		        // "from" and "to" quaternions are very close
		        //  ... so we can do a linear interpolation
		        scale0 = 1.0 - t;
		        scale1 = t;
		    }
		    // calculate final values
		    out[0] = scale0 * ax + scale1 * bx;
		    out[1] = scale0 * ay + scale1 * by;
		    out[2] = scale0 * az + scale1 * bz;
		    out[3] = scale0 * aw + scale1 * bw;

		    return out;
		};

		/**
		 * Calculates the inverse of a quat
		 *
		 * @param {quat} out the receiving quaternion
		 * @param {quat} a quat to calculate inverse of
		 * @returns {quat} out
		 */
		quat.invert = function(out, a) {
		    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
		        dot = a0*a0 + a1*a1 + a2*a2 + a3*a3,
		        invDot = dot ? 1.0/dot : 0;

		    // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

		    out[0] = -a0*invDot;
		    out[1] = -a1*invDot;
		    out[2] = -a2*invDot;
		    out[3] = a3*invDot;
		    return out;
		};

		/**
		 * Calculates the conjugate of a quat
		 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
		 *
		 * @param {quat} out the receiving quaternion
		 * @param {quat} a quat to calculate conjugate of
		 * @returns {quat} out
		 */
		quat.conjugate = function (out, a) {
		    out[0] = -a[0];
		    out[1] = -a[1];
		    out[2] = -a[2];
		    out[3] = a[3];
		    return out;
		};

		/**
		 * Alias for {@link spell.math.vec4#length}
		 *
		 * @property {Function}
		 */
		quat.length = vec4.length;

		/**
		 * Alias for {@link #length}
		 *
		 * @property {Function}
		 */
		quat.len = quat.length;

		/**
		 * Calculates the squared length of a quat
		 *
		 * @param {quat} a vector to calculate squared length of
		 * @returns {Number} squared length of a
		 * @function
		 */
		quat.squaredLength = vec4.squaredLength;

		/**
		 * Alias for {@link #squaredLength}
		 *
		 * @property {Function}
		 */
		quat.sqrLen = quat.squaredLength;

		/**
		 * Normalize a quat
		 *
		 * @param {quat} out the receiving quaternion
		 * @param {quat} a quaternion to normalize
		 * @returns {quat} out
		 * @function
		 */
		quat.normalize = vec4.normalize;

		/**
		 * Creates a quaternion from the given 3x3 rotation matrix.
		 *
		 * NOTE: The resultant quaternion is not normalized, so you should be sure
		 * to renormalize the quaternion yourself where necessary.
		 *
		 * @param {quat} out the receiving quaternion
		 * @param {mat3} m rotation matrix
		 * @returns {quat} out
		 * @function
		 */
		quat.fromMat3 = (function() {
		    // benchmarks:
		    //    http://jsperf.com/typed-array-access-speed
		    //    http://jsperf.com/conversion-of-3x3-matrix-to-quaternion

		    var s_iNext = Types.Int8Array.fromValues( [ 1, 2, 0 ] )

		    return function(out, m) {
		        // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
		        // article "Quaternion Calculus and Fast Animation".
		        var fTrace = m[0] + m[4] + m[8];
		        var fRoot;

		        if ( fTrace > 0.0 ) {
		            // |w| > 1/2, may as well choose w > 1/2
		            fRoot = Math.sqrt(fTrace + 1.0);  // 2w
		            out[3] = 0.5 * fRoot;
		            fRoot = 0.5/fRoot;  // 1/(4w)
		            out[0] = (m[7]-m[5])*fRoot;
		            out[1] = (m[2]-m[6])*fRoot;
		            out[2] = (m[3]-m[1])*fRoot;
		        } else {
		            // |w| <= 1/2
		            var i = 0;
		            if ( m[4] > m[0] )
		              i = 1;
		            if ( m[8] > m[i*3+i] )
		              i = 2;
		            var j = s_iNext[i];
		            var k = s_iNext[j];

		            fRoot = Math.sqrt(m[i*3+i]-m[j*3+j]-m[k*3+k] + 1.0);
		            out[i] = 0.5 * fRoot;
		            fRoot = 0.5 / fRoot;
		            out[3] = (m[k*3+j] - m[j*3+k]) * fRoot;
		            out[j] = (m[j*3+i] + m[i*3+j]) * fRoot;
		            out[k] = (m[k*3+i] + m[i*3+k]) * fRoot;
		        }

		        return out;
		    };
		})();

		/**
		 * Returns a string representation of a quatenion
		 *
		 * @param {quat} vec vector to represent as a string
		 * @returns {String} string representation of the vector
		 */
		quat.str = function (a) {
		    return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
		};

		return quat;
	}
)

/**
 * Utility math functions.
 *
 * @singleton
 * @class spell.math.util
 */
define(
	'spell/math/util',
	[
		'spell/shared/util/platform/Types'
	],
	function(
		Types
	) {
		'use strict'


		var util = {}

		util.FLOAT_EPSILON = 0.000001

		util.random = Math.random

		if( Types.hasFloatArraySupport() ) {
			var y = Types.createFloatArray( 1 )
			var i = Types.Int32Array.create( y.buffer )

			/**
			 * Fast way to calculate the inverse square root. See http://jsperf.com/inverse-square-root/5.
			 * If typed arrays are not available, a slower implementation will be used.
			 *
			 * @private
			 */
			util.invsqrt = function( x ) {
				var x2 = x * 0.5
				y[ 0 ] = x
				var threehalfs = 1.5

				i[ 0 ] = 0x5f3759df - ( i[ 0 ] >> 1 )

				var x3 = y[ 0 ]

				return x3 * ( threehalfs - ( x2 * x3 * x3 ) )
			};

		} else {
			/**
			 * Returns the inverse square root of the value x.
			 *
			 * @param {Number} x
			 * @returns {Number}
			 */
			util.invsqrt = function( x ) {
				return 1.0 / Math.sqrt( x )
			};
		}

		/**
		 * Clamps the value into the range specified by lowerBound and upperBound.
		 *
		 * @param {Number} value
		 * @param {Number} lowerBound
		 * @param {Number} upperBound
		 * @return {Number}
		 */
		util.clamp = function( value, lowerBound, upperBound ) {
			if( value < lowerBound ) return lowerBound
			if( value > upperBound ) return upperBound

			return value
		};

		/**
		 * Returns true when the value lies within in the interval specified by lowerBound and upperBound.
		 *
		 * @param value
		 * @param lowerBound
		 * @param upperBound
		 * @return {Boolean}
		 */
		util.isInInterval = function( value, lowerBound, upperBound ) {
			return ( value >= lowerBound && value <= upperBound )
		};

		/**
		 * Returns the modulo of dividend and divisor. The result is always positive (i.e. a positive member of the quotient ring defined by dividend % divisor).
		 *
		 * @param {Number} dividend
		 * @param {Number} divisor
		 * @return {Number}
		 */
		util.modulo = function( dividend, divisor ) {
			var tmp = dividend % divisor

			return tmp < 0 ?
				( tmp + divisor ) % divisor :
				tmp
		};

		/**
		 * Returns the sign of the supplied value x.
		 *
		 * Example:
		 *
		 *     util.sign( 2 ) // -> 1
		 *     util.sign( -5 ) // -> -1
		 *
		 * @param {Number} x
		 * @return {Number}
		 */
		util.sign = function( x ) {
			return x >= 0 ? 1 : -1
		};

		/**
		 * Rounds the value to multiples of resolution.
		 *
		 * Example:
		 *
		 *     util.roundToResolution( 5, 0.6 ) // -> 4.8
		 *     util.roundToResolution( 1233, 10 ) // -> 1230
		 *
		 * @param {Number} value
		 * @param {Number} resolution
		 * @return {Number}
		 */
		util.roundToResolution = function( value, resolution ) {
			if( !resolution ) resolution = 0.5

			var rest = value % resolution

   			return value - rest + ( rest > ( resolution / 2 ) ? resolution : 0 )
		};

		/**
		 * Checks whether a point is contained in a (rotated) rectangle or not.
		 *
		 * @param {vec2} point point to check
		 * @param {vec2} rectOrigin point the original from the rectangle (in the middle)
		 * @param {Number} rectWidth width of the rectangle
		 * @param {Number} rectHeight height of the rectangle
		 * @param {Number} rectRotation rotation in radians
		 * @return {Boolean}
		 */
		util.isPointInRect = function( point, rectOrigin, rectWidth, rectHeight, rectRotation ) {
			var tmp     = rectRotation, // Math.PI / 180
				c       = Math.cos( tmp ),
				s       = Math.sin( tmp ),
				leftX   = rectOrigin[ 0 ] - rectWidth / 2,
				rightX  = rectOrigin[ 0 ] + rectWidth / 2,
				topY    = rectOrigin[ 1 ] - rectHeight / 2,
				bottomY = rectOrigin[ 1 ] + rectHeight / 2

			// unrotate the point depending on the rotation of the rectangle
			var rotatedX = rectOrigin[ 0 ] + c * ( point[ 0 ] - rectOrigin[ 0 ] ) - s * ( point[ 1 ] - rectOrigin[ 1 ] ),
				rotatedY = rectOrigin[ 1 ] + s * ( point[ 0 ] - rectOrigin[ 0 ] ) + c * ( point[ 1 ] - rectOrigin[ 1 ] )

			return leftX <= rotatedX && rotatedX <= rightX && topY <= rotatedY && rotatedY <= bottomY
		};

		/**
		 * Returns an orthographic projection matrix specified by the four clippings.
		 *
		 * @param {mat3} out the result mat3 matrix
		 * @param {Number} left the left clipping
		 * @param {Number} right the right clipping
		 * @param {Number} bottom the bottom clipping
		 * @param {Number} top the top clipping
		 * @return {mat3}
		 */
		util.mat3Ortho = function( out, left, right, bottom, top ) {
			var rl = ( right - left ),
				tb = ( top - bottom )

			out[ 0 ] = 2 / rl
			out[ 1 ] = 0
			out[ 2 ] = 0
			out[ 3 ] = 0
			out[ 4 ] = 2 / tb
			out[ 5 ] = 0
			out[ 6 ] = -( left + right ) / rl
			out[ 7 ] = -( top + bottom ) / tb
			out[ 8 ] = 1

			return out
		};

		/**
		 * A triangle wave function. The output range is -1 to 1.
		 *
		 * @param {Number} t
		 * @param {Number} a
		 * @return {Number}
		 */
		util.triangle = function( t, a ) {
			if( a == 0 ) return 0

			var ta = t / a

			return 2 * Math.abs( 2 * ( ta - Math.floor( ta + 0.5 ) ) ) - 1
		}

		return util
	}
)

/*
 * This file is derived from glMatrix 2.1.0. Original Licence follows:
 */

/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */


define(
	'spell/math/mat4',
	[
		'spell/shared/util/platform/Types',
		'spell/math/util'
	],
	function(
		Types,
		mathUtil
	) {
		'use strict'


		/**
		 * 4x4 matrix functions
		 *
		 * @class spell.math.mat4
		 * @singleton
		 * @requires Math
		 * @requires spell.shared.util.platform.Types
		 * @requires spell.math.util
		 */
		var mat4 = {};

		/**
		 * Creates a new identity mat4
		 *
		 * @returns {mat4} a new 4x4 matrix
		 */
		mat4.create = function() {
		    var out = Types.createFloatArray(16);
		    out[0] = 1;
		    out[1] = 0;
		    out[2] = 0;
		    out[3] = 0;
		    out[4] = 0;
		    out[5] = 1;
		    out[6] = 0;
		    out[7] = 0;
		    out[8] = 0;
		    out[9] = 0;
		    out[10] = 1;
		    out[11] = 0;
		    out[12] = 0;
		    out[13] = 0;
		    out[14] = 0;
		    out[15] = 1;
		    return out;
		};

		/**
		 * Creates a new mat4 initialized with values from an existing matrix
		 *
		 * @param {mat4} a matrix to clone
		 * @returns {mat4} a new 4x4 matrix
		 */
		mat4.clone = function(a) {
		    var out = Types.createFloatArray(16);
		    out[0] = a[0];
		    out[1] = a[1];
		    out[2] = a[2];
		    out[3] = a[3];
		    out[4] = a[4];
		    out[5] = a[5];
		    out[6] = a[6];
		    out[7] = a[7];
		    out[8] = a[8];
		    out[9] = a[9];
		    out[10] = a[10];
		    out[11] = a[11];
		    out[12] = a[12];
		    out[13] = a[13];
		    out[14] = a[14];
		    out[15] = a[15];
		    return out;
		};

		/**
		 * Copy the values from one mat4 to another
		 *
		 * @param {mat4} out the receiving matrix
		 * @param {mat4} a the source matrix
		 * @returns {mat4} out
		 */
		mat4.copy = function(out, a) {
		    out[0] = a[0];
		    out[1] = a[1];
		    out[2] = a[2];
		    out[3] = a[3];
		    out[4] = a[4];
		    out[5] = a[5];
		    out[6] = a[6];
		    out[7] = a[7];
		    out[8] = a[8];
		    out[9] = a[9];
		    out[10] = a[10];
		    out[11] = a[11];
		    out[12] = a[12];
		    out[13] = a[13];
		    out[14] = a[14];
		    out[15] = a[15];
		    return out;
		};

		/**
		 * Set a mat4 to the identity matrix
		 *
		 * @param {mat4} out the receiving matrix
		 * @returns {mat4} out
		 */
		mat4.identity = function(out) {
		    out[0] = 1;
		    out[1] = 0;
		    out[2] = 0;
		    out[3] = 0;
		    out[4] = 0;
		    out[5] = 1;
		    out[6] = 0;
		    out[7] = 0;
		    out[8] = 0;
		    out[9] = 0;
		    out[10] = 1;
		    out[11] = 0;
		    out[12] = 0;
		    out[13] = 0;
		    out[14] = 0;
		    out[15] = 1;
		    return out;
		};

		/**
		 * Transpose the values of a mat4
		 *
		 * @param {mat4} out the receiving matrix
		 * @param {mat4} a the source matrix
		 * @returns {mat4} out
		 */
		mat4.transpose = function(out, a) {
		    // If we are transposing ourselves we can skip a few steps but have to cache some values
		    if (out === a) {
		        var a01 = a[1], a02 = a[2], a03 = a[3],
		            a12 = a[6], a13 = a[7],
		            a23 = a[11];

		        out[1] = a[4];
		        out[2] = a[8];
		        out[3] = a[12];
		        out[4] = a01;
		        out[6] = a[9];
		        out[7] = a[13];
		        out[8] = a02;
		        out[9] = a12;
		        out[11] = a[14];
		        out[12] = a03;
		        out[13] = a13;
		        out[14] = a23;
		    } else {
		        out[0] = a[0];
		        out[1] = a[4];
		        out[2] = a[8];
		        out[3] = a[12];
		        out[4] = a[1];
		        out[5] = a[5];
		        out[6] = a[9];
		        out[7] = a[13];
		        out[8] = a[2];
		        out[9] = a[6];
		        out[10] = a[10];
		        out[11] = a[14];
		        out[12] = a[3];
		        out[13] = a[7];
		        out[14] = a[11];
		        out[15] = a[15];
		    }

		    return out;
		};

		/**
		 * Inverts a mat4
		 *
		 * @param {mat4} out the receiving matrix
		 * @param {mat4} a the source matrix
		 * @returns {mat4} out
		 */
		mat4.invert = function(out, a) {
		    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
		        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
		        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
		        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

		        b00 = a00 * a11 - a01 * a10,
		        b01 = a00 * a12 - a02 * a10,
		        b02 = a00 * a13 - a03 * a10,
		        b03 = a01 * a12 - a02 * a11,
		        b04 = a01 * a13 - a03 * a11,
		        b05 = a02 * a13 - a03 * a12,
		        b06 = a20 * a31 - a21 * a30,
		        b07 = a20 * a32 - a22 * a30,
		        b08 = a20 * a33 - a23 * a30,
		        b09 = a21 * a32 - a22 * a31,
		        b10 = a21 * a33 - a23 * a31,
		        b11 = a22 * a33 - a23 * a32,

		        // Calculate the determinant
		        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

		    if (!det) {
		        return null;
		    }
		    det = 1.0 / det;

		    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
		    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
		    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
		    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
		    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
		    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
		    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
		    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
		    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
		    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
		    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
		    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
		    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
		    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
		    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
		    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

		    return out;
		};

		/**
		 * Calculates the adjugate of a mat4
		 *
		 * @param {mat4} out the receiving matrix
		 * @param {mat4} a the source matrix
		 * @returns {mat4} out
		 */
		mat4.adjoint = function(out, a) {
		    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
		        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
		        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
		        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

		    out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
		    out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
		    out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
		    out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
		    out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
		    out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
		    out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
		    out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
		    out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
		    out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
		    out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
		    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
		    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
		    out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
		    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
		    out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
		    return out;
		};

		/**
		 * Calculates the determinant of a mat4
		 *
		 * @param {mat4} a the source matrix
		 * @returns {Number} determinant of a
		 */
		mat4.determinant = function (a) {
		    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
		        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
		        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
		        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

		        b00 = a00 * a11 - a01 * a10,
		        b01 = a00 * a12 - a02 * a10,
		        b02 = a00 * a13 - a03 * a10,
		        b03 = a01 * a12 - a02 * a11,
		        b04 = a01 * a13 - a03 * a11,
		        b05 = a02 * a13 - a03 * a12,
		        b06 = a20 * a31 - a21 * a30,
		        b07 = a20 * a32 - a22 * a30,
		        b08 = a20 * a33 - a23 * a30,
		        b09 = a21 * a32 - a22 * a31,
		        b10 = a21 * a33 - a23 * a31,
		        b11 = a22 * a33 - a23 * a32;

		    // Calculate the determinant
		    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
		};

		/**
		 * Multiplies two matrixes
		 *
		 * @param {mat4} out the receiving matrix
		 * @param {mat4} a the first operand
		 * @param {mat4} b the second operand
		 * @returns {mat4} out
		 */
		mat4.multiply = function (out, a, b) {
		    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
		        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
		        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
		        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

		    // Cache only the current line of the second matrix
		    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
		    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
		    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
		    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
		    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

		    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
		    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
		    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
		    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
		    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

		    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
		    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
		    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
		    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
		    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

		    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
		    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
		    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
		    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
		    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
		    return out;
		};

		/**
		 * Alias for {@link #multiply}
		 *
		 * @property {Function}
		 */
		mat4.mul = mat4.multiply;

		/**
		 * Translate a mat4 by the given vector
		 *
		 * @param {mat4} out the receiving matrix
		 * @param {mat4} a the matrix to translate
		 * @param {vec3} v vector to translate by
		 * @returns {mat4} out
		 */
		mat4.translate = function (out, a, v) {
		    var x = v[0], y = v[1], z = v[2],
		        a00, a01, a02, a03,
		        a10, a11, a12, a13,
		        a20, a21, a22, a23;

		    if (a === out) {
		        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
		        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
		        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
		        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
		    } else {
		        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
		        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
		        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

		        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
		        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
		        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

		        out[12] = a00 * x + a10 * y + a20 * z + a[12];
		        out[13] = a01 * x + a11 * y + a21 * z + a[13];
		        out[14] = a02 * x + a12 * y + a22 * z + a[14];
		        out[15] = a03 * x + a13 * y + a23 * z + a[15];
		    }

		    return out;
		};

		/**
		 * Scales the mat4 by the dimensions in the given vec3
		 *
		 * @param {mat4} out the receiving matrix
		 * @param {mat4} a the matrix to scale
		 * @param {vec3} v the vec3 to scale the matrix by
		 * @returns {mat4} out
		 **/
		mat4.scale = function(out, a, v) {
		    var x = v[0], y = v[1], z = v[2];

		    out[0] = a[0] * x;
		    out[1] = a[1] * x;
		    out[2] = a[2] * x;
		    out[3] = a[3] * x;
		    out[4] = a[4] * y;
		    out[5] = a[5] * y;
		    out[6] = a[6] * y;
		    out[7] = a[7] * y;
		    out[8] = a[8] * z;
		    out[9] = a[9] * z;
		    out[10] = a[10] * z;
		    out[11] = a[11] * z;
		    out[12] = a[12];
		    out[13] = a[13];
		    out[14] = a[14];
		    out[15] = a[15];
		    return out;
		};

		/**
		 * Rotates a mat4 by the given angle
		 *
		 * @param {mat4} out the receiving matrix
		 * @param {mat4} a the matrix to rotate
		 * @param {Number} rad the angle to rotate the matrix by
		 * @param {vec3} axis the axis to rotate around
		 * @returns {mat4} out
		 */
		mat4.rotate = function (out, a, rad, axis) {
		    var x = axis[0], y = axis[1], z = axis[2],
		        len = Math.sqrt(x * x + y * y + z * z),
		        s, c, t,
		        a00, a01, a02, a03,
		        a10, a11, a12, a13,
		        a20, a21, a22, a23,
		        b00, b01, b02,
		        b10, b11, b12,
		        b20, b21, b22;

		    if (Math.abs(len) < mathUtil.FLOAT_EPSILON) { return null; }

		    len = 1 / len;
		    x *= len;
		    y *= len;
		    z *= len;

		    s = Math.sin(rad);
		    c = Math.cos(rad);
		    t = 1 - c;

		    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
		    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
		    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

		    // Construct the elements of the rotation matrix
		    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
		    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
		    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

		    // Perform rotation-specific matrix multiplication
		    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
		    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
		    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
		    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
		    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
		    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
		    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
		    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
		    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
		    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
		    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
		    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

		    if (a !== out) { // If the source and destination differ, copy the unchanged last row
		        out[12] = a[12];
		        out[13] = a[13];
		        out[14] = a[14];
		        out[15] = a[15];
		    }
		    return out;
		};

		/**
		 * Rotates a matrix by the given angle around the X axis
		 *
		 * @param {mat4} out the receiving matrix
		 * @param {mat4} a the matrix to rotate
		 * @param {Number} rad the angle to rotate the matrix by
		 * @returns {mat4} out
		 */
		mat4.rotateX = function (out, a, rad) {
		    var s = Math.sin(rad),
		        c = Math.cos(rad),
		        a10 = a[4],
		        a11 = a[5],
		        a12 = a[6],
		        a13 = a[7],
		        a20 = a[8],
		        a21 = a[9],
		        a22 = a[10],
		        a23 = a[11];

		    if (a !== out) { // If the source and destination differ, copy the unchanged rows
		        out[0]  = a[0];
		        out[1]  = a[1];
		        out[2]  = a[2];
		        out[3]  = a[3];
		        out[12] = a[12];
		        out[13] = a[13];
		        out[14] = a[14];
		        out[15] = a[15];
		    }

		    // Perform axis-specific matrix multiplication
		    out[4] = a10 * c + a20 * s;
		    out[5] = a11 * c + a21 * s;
		    out[6] = a12 * c + a22 * s;
		    out[7] = a13 * c + a23 * s;
		    out[8] = a20 * c - a10 * s;
		    out[9] = a21 * c - a11 * s;
		    out[10] = a22 * c - a12 * s;
		    out[11] = a23 * c - a13 * s;
		    return out;
		};

		/**
		 * Rotates a matrix by the given angle around the Y axis
		 *
		 * @param {mat4} out the receiving matrix
		 * @param {mat4} a the matrix to rotate
		 * @param {Number} rad the angle to rotate the matrix by
		 * @returns {mat4} out
		 */
		mat4.rotateY = function (out, a, rad) {
		    var s = Math.sin(rad),
		        c = Math.cos(rad),
		        a00 = a[0],
		        a01 = a[1],
		        a02 = a[2],
		        a03 = a[3],
		        a20 = a[8],
		        a21 = a[9],
		        a22 = a[10],
		        a23 = a[11];

		    if (a !== out) { // If the source and destination differ, copy the unchanged rows
		        out[4]  = a[4];
		        out[5]  = a[5];
		        out[6]  = a[6];
		        out[7]  = a[7];
		        out[12] = a[12];
		        out[13] = a[13];
		        out[14] = a[14];
		        out[15] = a[15];
		    }

		    // Perform axis-specific matrix multiplication
		    out[0] = a00 * c - a20 * s;
		    out[1] = a01 * c - a21 * s;
		    out[2] = a02 * c - a22 * s;
		    out[3] = a03 * c - a23 * s;
		    out[8] = a00 * s + a20 * c;
		    out[9] = a01 * s + a21 * c;
		    out[10] = a02 * s + a22 * c;
		    out[11] = a03 * s + a23 * c;
		    return out;
		};

		/**
		 * Rotates a matrix by the given angle around the Z axis
		 *
		 * @param {mat4} out the receiving matrix
		 * @param {mat4} a the matrix to rotate
		 * @param {Number} rad the angle to rotate the matrix by
		 * @returns {mat4} out
		 */
		mat4.rotateZ = function (out, a, rad) {
		    var s = Math.sin(rad),
		        c = Math.cos(rad),
		        a00 = a[0],
		        a01 = a[1],
		        a02 = a[2],
		        a03 = a[3],
		        a10 = a[4],
		        a11 = a[5],
		        a12 = a[6],
		        a13 = a[7];

		    if (a !== out) { // If the source and destination differ, copy the unchanged last row
		        out[8]  = a[8];
		        out[9]  = a[9];
		        out[10] = a[10];
		        out[11] = a[11];
		        out[12] = a[12];
		        out[13] = a[13];
		        out[14] = a[14];
		        out[15] = a[15];
		    }

		    // Perform axis-specific matrix multiplication
		    out[0] = a00 * c + a10 * s;
		    out[1] = a01 * c + a11 * s;
		    out[2] = a02 * c + a12 * s;
		    out[3] = a03 * c + a13 * s;
		    out[4] = a10 * c - a00 * s;
		    out[5] = a11 * c - a01 * s;
		    out[6] = a12 * c - a02 * s;
		    out[7] = a13 * c - a03 * s;
		    return out;
		};

		/**
		 * Creates a matrix from a quaternion rotation and vector translation
		 * This is equivalent to (but much faster than):
		 *
		 *     mat4.identity(dest);
		 *     mat4.translate(dest, vec);
		 *     var quatMat = mat4.create();
		 *     quat4.toMat4(quat, quatMat);
		 *     mat4.multiply(dest, quatMat);
		 *
		 * @param {mat4} out mat4 receiving operation result
		 * @param {quat4} q Rotation quaternion
		 * @param {vec3} v Translation vector
		 * @returns {mat4} out
		 */
		mat4.fromRotationTranslation = function (out, q, v) {
		    // Quaternion math
		    var x = q[0], y = q[1], z = q[2], w = q[3],
		        x2 = x + x,
		        y2 = y + y,
		        z2 = z + z,

		        xx = x * x2,
		        xy = x * y2,
		        xz = x * z2,
		        yy = y * y2,
		        yz = y * z2,
		        zz = z * z2,
		        wx = w * x2,
		        wy = w * y2,
		        wz = w * z2;

		    out[0] = 1 - (yy + zz);
		    out[1] = xy + wz;
		    out[2] = xz - wy;
		    out[3] = 0;
		    out[4] = xy - wz;
		    out[5] = 1 - (xx + zz);
		    out[6] = yz + wx;
		    out[7] = 0;
		    out[8] = xz + wy;
		    out[9] = yz - wx;
		    out[10] = 1 - (xx + yy);
		    out[11] = 0;
		    out[12] = v[0];
		    out[13] = v[1];
		    out[14] = v[2];
		    out[15] = 1;

		    return out;
		};

		/**
		* Calculates a 4x4 matrix from the given quaternion
		*
		* @param {mat4} out mat4 receiving operation result
		* @param {quat} q Quaternion to create matrix from
		*
		* @returns {mat4} out
		*/
		mat4.fromQuat = function (out, q) {
		    var x = q[0], y = q[1], z = q[2], w = q[3],
		        x2 = x + x,
		        y2 = y + y,
		        z2 = z + z,

		        xx = x * x2,
		        xy = x * y2,
		        xz = x * z2,
		        yy = y * y2,
		        yz = y * z2,
		        zz = z * z2,
		        wx = w * x2,
		        wy = w * y2,
		        wz = w * z2;

		    out[0] = 1 - (yy + zz);
		    out[1] = xy + wz;
		    out[2] = xz - wy;
		    out[3] = 0;

		    out[4] = xy - wz;
		    out[5] = 1 - (xx + zz);
		    out[6] = yz + wx;
		    out[7] = 0;

		    out[8] = xz + wy;
		    out[9] = yz - wx;
		    out[10] = 1 - (xx + yy);
		    out[11] = 0;

		    out[12] = 0;
		    out[13] = 0;
		    out[14] = 0;
		    out[15] = 1;

		    return out;
		};

		/**
		 * Generates a frustum matrix with the given bounds
		 *
		 * @param {mat4} out mat4 frustum matrix will be written into
		 * @param {Number} left Left bound of the frustum
		 * @param {Number} right Right bound of the frustum
		 * @param {Number} bottom Bottom bound of the frustum
		 * @param {Number} top Top bound of the frustum
		 * @param {Number} near Near bound of the frustum
		 * @param {Number} far Far bound of the frustum
		 * @returns {mat4} out
		 */
		mat4.frustum = function (out, left, right, bottom, top, near, far) {
		    var rl = 1 / (right - left),
		        tb = 1 / (top - bottom),
		        nf = 1 / (near - far);
		    out[0] = (near * 2) * rl;
		    out[1] = 0;
		    out[2] = 0;
		    out[3] = 0;
		    out[4] = 0;
		    out[5] = (near * 2) * tb;
		    out[6] = 0;
		    out[7] = 0;
		    out[8] = (right + left) * rl;
		    out[9] = (top + bottom) * tb;
		    out[10] = (far + near) * nf;
		    out[11] = -1;
		    out[12] = 0;
		    out[13] = 0;
		    out[14] = (far * near * 2) * nf;
		    out[15] = 0;
		    return out;
		};

		/**
		 * Generates a perspective projection matrix with the given bounds
		 *
		 * @param {mat4} out mat4 frustum matrix will be written into
		 * @param {number} fovy Vertical field of view in radians
		 * @param {number} aspect Aspect ratio. typically viewport width/height
		 * @param {number} near Near bound of the frustum
		 * @param {number} far Far bound of the frustum
		 * @returns {mat4} out
		 */
		mat4.perspective = function (out, fovy, aspect, near, far) {
		    var f = 1.0 / Math.tan(fovy / 2),
		        nf = 1 / (near - far);
		    out[0] = f / aspect;
		    out[1] = 0;
		    out[2] = 0;
		    out[3] = 0;
		    out[4] = 0;
		    out[5] = f;
		    out[6] = 0;
		    out[7] = 0;
		    out[8] = 0;
		    out[9] = 0;
		    out[10] = (far + near) * nf;
		    out[11] = -1;
		    out[12] = 0;
		    out[13] = 0;
		    out[14] = (2 * far * near) * nf;
		    out[15] = 0;
		    return out;
		};

		/**
		 * Generates a orthogonal projection matrix with the given bounds
		 *
		 * @param {mat4} out mat4 frustum matrix will be written into
		 * @param {number} left Left bound of the frustum
		 * @param {number} right Right bound of the frustum
		 * @param {number} bottom Bottom bound of the frustum
		 * @param {number} top Top bound of the frustum
		 * @param {number} near Near bound of the frustum
		 * @param {number} far Far bound of the frustum
		 * @returns {mat4} out
		 */
		mat4.ortho = function (out, left, right, bottom, top, near, far) {
		    var lr = 1 / (left - right),
		        bt = 1 / (bottom - top),
		        nf = 1 / (near - far);
		    out[0] = -2 * lr;
		    out[1] = 0;
		    out[2] = 0;
		    out[3] = 0;
		    out[4] = 0;
		    out[5] = -2 * bt;
		    out[6] = 0;
		    out[7] = 0;
		    out[8] = 0;
		    out[9] = 0;
		    out[10] = 2 * nf;
		    out[11] = 0;
		    out[12] = (left + right) * lr;
		    out[13] = (top + bottom) * bt;
		    out[14] = (far + near) * nf;
		    out[15] = 1;
		    return out;
		};

		/**
		 * Generates a look-at matrix with the given eye position, focal point, and up axis
		 *
		 * @param {mat4} out mat4 frustum matrix will be written into
		 * @param {vec3} eye Position of the viewer
		 * @param {vec3} center Point the viewer is looking at
		 * @param {vec3} up vec3 pointing up
		 * @returns {mat4} out
		 */
		mat4.lookAt = function (out, eye, center, up) {
		    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
		        eyex = eye[0],
		        eyey = eye[1],
		        eyez = eye[2],
		        upx = up[0],
		        upy = up[1],
		        upz = up[2],
		        centerx = center[0],
		        centery = center[1],
		        centerz = center[2];

		    if (Math.abs(eyex - centerx) < mathUtil.FLOAT_EPSILON &&
		        Math.abs(eyey - centery) < mathUtil.FLOAT_EPSILON &&
		        Math.abs(eyez - centerz) < mathUtil.FLOAT_EPSILON ) {
		        return mat4.identity(out);
		    }

		    z0 = eyex - centerx;
		    z1 = eyey - centery;
		    z2 = eyez - centerz;

		    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
		    z0 *= len;
		    z1 *= len;
		    z2 *= len;

		    x0 = upy * z2 - upz * z1;
		    x1 = upz * z0 - upx * z2;
		    x2 = upx * z1 - upy * z0;
		    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
		    if (!len) {
		        x0 = 0;
		        x1 = 0;
		        x2 = 0;
		    } else {
		        len = 1 / len;
		        x0 *= len;
		        x1 *= len;
		        x2 *= len;
		    }

		    y0 = z1 * x2 - z2 * x1;
		    y1 = z2 * x0 - z0 * x2;
		    y2 = z0 * x1 - z1 * x0;

		    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
		    if (!len) {
		        y0 = 0;
		        y1 = 0;
		        y2 = 0;
		    } else {
		        len = 1 / len;
		        y0 *= len;
		        y1 *= len;
		        y2 *= len;
		    }

		    out[0] = x0;
		    out[1] = y0;
		    out[2] = z0;
		    out[3] = 0;
		    out[4] = x1;
		    out[5] = y1;
		    out[6] = z1;
		    out[7] = 0;
		    out[8] = x2;
		    out[9] = y2;
		    out[10] = z2;
		    out[11] = 0;
		    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
		    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
		    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
		    out[15] = 1;

		    return out;
		};

		/**
		 * Returns a string representation of a mat4
		 *
		 * @param {mat4} mat matrix to represent as a string
		 * @returns {String} string representation of the matrix
		 */
		mat4.str = function (a) {
		    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
		                    a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
		                    a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' +
		                    a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
		};

		return mat4;
	}
)

/*
 * This file is derived from glMatrix 2.1.0. Original Licence follows:
 */

/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */


define(
	'spell/math/mat3',
	[
		'spell/shared/util/platform/Types'
	],
	function(
		Types
	) {
		'use strict'


		/**
		 * 3x3 matrix functions
		 *
		 * @class spell.math.mat3
		 * @singleton
		 * @requires Math
		 * @requires spell.shared.util.platform.Types
		 */
		var mat3 = {};

		/**
		 * Creates a new identity mat3
		 *
		 * @returns {mat3} a new 3x3 matrix
		 */
		mat3.create = function() {
		    var out = Types.createFloatArray(9);
		    out[0] = 1;
		    out[1] = 0;
		    out[2] = 0;
		    out[3] = 0;
		    out[4] = 1;
		    out[5] = 0;
		    out[6] = 0;
		    out[7] = 0;
		    out[8] = 1;
		    return out;
		};

		/**
		 * Copies the upper-left 3x3 values into the given mat3.
		 *
		 * @param {mat3} out the receiving 3x3 matrix
		 * @param {mat4} a   the source 4x4 matrix
		 * @returns {mat3} out
		 */
		mat3.fromMat4 = function(out, a) {
		    out[0] = a[0];
		    out[1] = a[1];
		    out[2] = a[2];
		    out[3] = a[4];
		    out[4] = a[5];
		    out[5] = a[6];
		    out[6] = a[8];
		    out[7] = a[9];
		    out[8] = a[10];
		    return out;
		};

		/**
		 * Creates a new mat3 initialized with values from an existing matrix
		 *
		 * @param {mat3} a matrix to clone
		 * @returns {mat3} a new 3x3 matrix
		 */
		mat3.clone = function(a) {
		    var out = Types.createFloatArray(9);
		    out[0] = a[0];
		    out[1] = a[1];
		    out[2] = a[2];
		    out[3] = a[3];
		    out[4] = a[4];
		    out[5] = a[5];
		    out[6] = a[6];
		    out[7] = a[7];
		    out[8] = a[8];
		    return out;
		};

		/**
		 * Copy the values from one mat3 to another
		 *
		 * @param {mat3} out the receiving matrix
		 * @param {mat3} a the source matrix
		 * @returns {mat3} out
		 */
		mat3.copy = function(out, a) {
		    out[0] = a[0];
		    out[1] = a[1];
		    out[2] = a[2];
		    out[3] = a[3];
		    out[4] = a[4];
		    out[5] = a[5];
		    out[6] = a[6];
		    out[7] = a[7];
		    out[8] = a[8];
		    return out;
		};

		/**
		 * Set a mat3 to the identity matrix
		 *
		 * @param {mat3} out the receiving matrix
		 * @returns {mat3} out
		 */
		mat3.identity = function(out) {
		    out[0] = 1;
		    out[1] = 0;
		    out[2] = 0;
		    out[3] = 0;
		    out[4] = 1;
		    out[5] = 0;
		    out[6] = 0;
		    out[7] = 0;
		    out[8] = 1;
		    return out;
		};

		/**
		 * Transpose the values of a mat3
		 *
		 * @param {mat3} out the receiving matrix
		 * @param {mat3} a the source matrix
		 * @returns {mat3} out
		 */
		mat3.transpose = function(out, a) {
		    // If we are transposing ourselves we can skip a few steps but have to cache some values
		    if (out === a) {
		        var a01 = a[1], a02 = a[2], a12 = a[5];
		        out[1] = a[3];
		        out[2] = a[6];
		        out[3] = a01;
		        out[5] = a[7];
		        out[6] = a02;
		        out[7] = a12;
		    } else {
		        out[0] = a[0];
		        out[1] = a[3];
		        out[2] = a[6];
		        out[3] = a[1];
		        out[4] = a[4];
		        out[5] = a[7];
		        out[6] = a[2];
		        out[7] = a[5];
		        out[8] = a[8];
		    }

		    return out;
		};

		/**
		 * Inverts a mat3
		 *
		 * @param {mat3} out the receiving matrix
		 * @param {mat3} a the source matrix
		 * @returns {mat3} out
		 */
		mat3.invert = function(out, a) {
		    var a00 = a[0], a01 = a[1], a02 = a[2],
		        a10 = a[3], a11 = a[4], a12 = a[5],
		        a20 = a[6], a21 = a[7], a22 = a[8],

		        b01 = a22 * a11 - a12 * a21,
		        b11 = -a22 * a10 + a12 * a20,
		        b21 = a21 * a10 - a11 * a20,

		        // Calculate the determinant
		        det = a00 * b01 + a01 * b11 + a02 * b21;

		    if (!det) {
		        return null;
		    }
		    det = 1.0 / det;

		    out[0] = b01 * det;
		    out[1] = (-a22 * a01 + a02 * a21) * det;
		    out[2] = (a12 * a01 - a02 * a11) * det;
		    out[3] = b11 * det;
		    out[4] = (a22 * a00 - a02 * a20) * det;
		    out[5] = (-a12 * a00 + a02 * a10) * det;
		    out[6] = b21 * det;
		    out[7] = (-a21 * a00 + a01 * a20) * det;
		    out[8] = (a11 * a00 - a01 * a10) * det;
		    return out;
		};

		/**
		 * Calculates the adjugate of a mat3
		 *
		 * @param {mat3} out the receiving matrix
		 * @param {mat3} a the source matrix
		 * @returns {mat3} out
		 */
		mat3.adjoint = function(out, a) {
		    var a00 = a[0], a01 = a[1], a02 = a[2],
		        a10 = a[3], a11 = a[4], a12 = a[5],
		        a20 = a[6], a21 = a[7], a22 = a[8];

		    out[0] = (a11 * a22 - a12 * a21);
		    out[1] = (a02 * a21 - a01 * a22);
		    out[2] = (a01 * a12 - a02 * a11);
		    out[3] = (a12 * a20 - a10 * a22);
		    out[4] = (a00 * a22 - a02 * a20);
		    out[5] = (a02 * a10 - a00 * a12);
		    out[6] = (a10 * a21 - a11 * a20);
		    out[7] = (a01 * a20 - a00 * a21);
		    out[8] = (a00 * a11 - a01 * a10);
		    return out;
		};

		/**
		 * Calculates the determinant of a mat3
		 *
		 * @param {mat3} a the source matrix
		 * @returns {Number} determinant of a
		 */
		mat3.determinant = function (a) {
		    var a00 = a[0], a01 = a[1], a02 = a[2],
		        a10 = a[3], a11 = a[4], a12 = a[5],
		        a20 = a[6], a21 = a[7], a22 = a[8];

		    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
		};

		/**
		 * Multiplies two matrixes
		 *
		 * @param {mat3} out the receiving matrix
		 * @param {mat3} a the first operand
		 * @param {mat3} b the second operand
		 * @returns {mat3} out
		 */
		mat3.multiply = function (out, a, b) {
		    var a00 = a[0], a01 = a[1], a02 = a[2],
		        a10 = a[3], a11 = a[4], a12 = a[5],
		        a20 = a[6], a21 = a[7], a22 = a[8],

		        b00 = b[0], b01 = b[1], b02 = b[2],
		        b10 = b[3], b11 = b[4], b12 = b[5],
		        b20 = b[6], b21 = b[7], b22 = b[8];

		    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
		    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
		    out[2] = b00 * a02 + b01 * a12 + b02 * a22;

		    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
		    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
		    out[5] = b10 * a02 + b11 * a12 + b12 * a22;

		    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
		    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
		    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
		    return out;
		};

		/**
		 * Alias for {@link #multiply}
		 *
		 * @property {Function}
		 */
		mat3.mul = mat3.multiply;

		/**
		 * Translate a mat3 by the given vector
		 *
		 * @param {mat3} out the receiving matrix
		 * @param {mat3} a the matrix to translate
		 * @param {vec2} v vector to translate by
		 * @returns {mat3} out
		 */
		mat3.translate = function(out, a, v) {
		    var a00 = a[0], a01 = a[1], a02 = a[2],
		        a10 = a[3], a11 = a[4], a12 = a[5],
		        a20 = a[6], a21 = a[7], a22 = a[8],
		        x = v[0], y = v[1];

		    out[0] = a00;
		    out[1] = a01;
		    out[2] = a02;

		    out[3] = a10;
		    out[4] = a11;
		    out[5] = a12;

		    out[6] = x * a00 + y * a10 + a20;
		    out[7] = x * a01 + y * a11 + a21;
		    out[8] = x * a02 + y * a12 + a22;
		    return out;
		};

		/**
		 * Rotates a mat3 by the given angle
		 *
		 * @param {mat3} out the receiving matrix
		 * @param {mat3} a the matrix to rotate
		 * @param {Number} rad the angle to rotate the matrix by
		 * @returns {mat3} out
		 */
		mat3.rotate = function (out, a, rad) {
		    var a00 = a[0], a01 = a[1], a02 = a[2],
		        a10 = a[3], a11 = a[4], a12 = a[5],
		        a20 = a[6], a21 = a[7], a22 = a[8],

		        s = Math.sin(rad),
		        c = Math.cos(rad);

		    out[0] = c * a00 + s * a10;
		    out[1] = c * a01 + s * a11;
		    out[2] = c * a02 + s * a12;

		    out[3] = c * a10 - s * a00;
		    out[4] = c * a11 - s * a01;
		    out[5] = c * a12 - s * a02;

		    out[6] = a20;
		    out[7] = a21;
		    out[8] = a22;
		    return out;
		};

		/**
		 * Scales the mat3 by the dimensions in the given vec2
		 *
		 * @param {mat3} out the receiving matrix
		 * @param {mat3} a the matrix to rotate
		 * @param {vec2} v the vec2 to scale the matrix by
		 * @returns {mat3} out
		 **/
		mat3.scale = function(out, a, v) {
		    var x = v[0], y = v[1];

		    out[0] = x * a[0];
		    out[1] = x * a[1];
		    out[2] = x * a[2];

		    out[3] = y * a[3];
		    out[4] = y * a[4];
		    out[5] = y * a[5];

		    out[6] = a[6];
		    out[7] = a[7];
		    out[8] = a[8];
		    return out;
		};

		/**
		 * Copies the values from a mat2d into a mat3
		 *
		 * @param {mat3} out the receiving matrix
		 * @param {mat2d} a the matrix to copy
		 * @returns {mat3} out
		 **/
		mat3.fromMat2d = function(out, a) {
		    out[0] = a[0];
		    out[1] = a[1];
		    out[2] = 0;

		    out[3] = a[2];
		    out[4] = a[3];
		    out[5] = 0;

		    out[6] = a[4];
		    out[7] = a[5];
		    out[8] = 1;
		    return out;
		};

		/**
		* Calculates a 3x3 matrix from the given quaternion
		*
		* @param {mat3} out mat3 receiving operation result
		* @param {quat} q Quaternion to create matrix from
		*
		* @returns {mat3} out
		*/
		mat3.fromQuat = function (out, q) {
		    var x = q[0], y = q[1], z = q[2], w = q[3],
		        x2 = x + x,
		        y2 = y + y,
		        z2 = z + z,

		        xx = x * x2,
		        xy = x * y2,
		        xz = x * z2,
		        yy = y * y2,
		        yz = y * z2,
		        zz = z * z2,
		        wx = w * x2,
		        wy = w * y2,
		        wz = w * z2;

		    out[0] = 1 - (yy + zz);
		    out[3] = xy + wz;
		    out[6] = xz - wy;

		    out[1] = xy - wz;
		    out[4] = 1 - (xx + zz);
		    out[7] = yz + wx;

		    out[2] = xz + wy;
		    out[5] = yz - wx;
		    out[8] = 1 - (xx + yy);

		    return out;
		};

		/**
		* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
		*
		* @param {mat3} out mat3 receiving operation result
		* @param {mat4} a Mat4 to derive the normal matrix from
		*
		* @returns {mat3} out
		*/
		mat3.normalFromMat4 = function (out, a) {
		    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
		        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
		        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
		        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

		        b00 = a00 * a11 - a01 * a10,
		        b01 = a00 * a12 - a02 * a10,
		        b02 = a00 * a13 - a03 * a10,
		        b03 = a01 * a12 - a02 * a11,
		        b04 = a01 * a13 - a03 * a11,
		        b05 = a02 * a13 - a03 * a12,
		        b06 = a20 * a31 - a21 * a30,
		        b07 = a20 * a32 - a22 * a30,
		        b08 = a20 * a33 - a23 * a30,
		        b09 = a21 * a32 - a22 * a31,
		        b10 = a21 * a33 - a23 * a31,
		        b11 = a22 * a33 - a23 * a32,

		        // Calculate the determinant
		        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

		    if (!det) {
		        return null;
		    }
		    det = 1.0 / det;

		    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
		    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
		    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

		    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
		    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
		    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

		    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
		    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
		    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

		    return out;
		};

		/**
		 * Returns a string representation of a mat3
		 *
		 * @param {mat3} mat matrix to represent as a string
		 * @returns {String} string representation of the matrix
		 */
		mat3.str = function (a) {
		    return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' +
		                    a[3] + ', ' + a[4] + ', ' + a[5] + ', ' +
		                    a[6] + ', ' + a[7] + ', ' + a[8] + ')';
		};

		return mat3;
	}
)

/*
 * This file is derived from glMatrix 2.1.0. Original Licence follows:
 */

/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */


define(
	'spell/math/mat2d',
	[
		'spell/shared/util/platform/Types'
	],
	function(
		Types
	) {
		'use strict'


		/**
		 * 3x2 matrix functions
		 *
		 * A mat2d contains six elements defined as:
		 * <pre>
		 * [a, b,
		 *  c, d,
		 *  tx,ty]
		 * </pre>
		 * This is a short form for the 3x3 matrix:
		 * <pre>
		 * [a, b, 0
		 *  c, d, 0
		 *  tx,ty,1]
		 * </pre>
		 * The last column is ignored so the array is shorter and operations are faster.
		 *
		 * @class spell.math.mat2d
		 * @singleton
		 * @requires Math
		 * @requires spell.shared.util.platform.Types
		 */
		var mat2d = {};

		/**
		 * Creates a new identity mat2d
		 *
		 * @returns {mat2d} a new 2x3 matrix
		 */
		mat2d.create = function() {
		    var out = Types.createFloatArray(6);
		    out[0] = 1;
		    out[1] = 0;
		    out[2] = 0;
		    out[3] = 1;
		    out[4] = 0;
		    out[5] = 0;
		    return out;
		};

		/**
		 * Creates a new mat2d initialized with values from an existing matrix
		 *
		 * @param {mat2d} a matrix to clone
		 * @returns {mat2d} a new 2x3 matrix
		 */
		mat2d.clone = function(a) {
		    var out = Types.createFloatArray(6);
		    out[0] = a[0];
		    out[1] = a[1];
		    out[2] = a[2];
		    out[3] = a[3];
		    out[4] = a[4];
		    out[5] = a[5];
		    return out;
		};

		/**
		 * Copy the values from one mat2d to another
		 *
		 * @param {mat2d} out the receiving matrix
		 * @param {mat2d} a the source matrix
		 * @returns {mat2d} out
		 */
		mat2d.copy = function(out, a) {
		    out[0] = a[0];
		    out[1] = a[1];
		    out[2] = a[2];
		    out[3] = a[3];
		    out[4] = a[4];
		    out[5] = a[5];
		    return out;
		};

		/**
		 * Set a mat2d to the identity matrix
		 *
		 * @param {mat2d} out the receiving matrix
		 * @returns {mat2d} out
		 */
		mat2d.identity = function(out) {
		    out[0] = 1;
		    out[1] = 0;
		    out[2] = 0;
		    out[3] = 1;
		    out[4] = 0;
		    out[5] = 0;
		    return out;
		};

		/**
		 * Inverts a mat2d
		 *
		 * @param {mat2d} out the receiving matrix
		 * @param {mat2d} a the source matrix
		 * @returns {mat2d} out
		 */
		mat2d.invert = function(out, a) {
		    var aa = a[0], ab = a[1], ac = a[2], ad = a[3],
		        atx = a[4], aty = a[5];

		    var det = aa * ad - ab * ac;
		    if(!det){
		        return null;
		    }
		    det = 1.0 / det;

		    out[0] = ad * det;
		    out[1] = -ab * det;
		    out[2] = -ac * det;
		    out[3] = aa * det;
		    out[4] = (ac * aty - ad * atx) * det;
		    out[5] = (ab * atx - aa * aty) * det;
		    return out;
		};

		/**
		 * Calculates the determinant of a mat2d
		 *
		 * @param {mat2d} a the source matrix
		 * @returns {Number} determinant of a
		 */
		mat2d.determinant = function (a) {
		    return a[0] * a[3] - a[1] * a[2];
		};

		/**
		 * Multiplies two matrixes
		 *
		 * @param {mat2d} out the receiving matrix
		 * @param {mat2d} a the first operand
		 * @param {mat2d} b the second operand
		 * @returns {mat2d} out
		 */
		mat2d.multiply = function (out, a, b) {
		    var aa = a[0], ab = a[1], ac = a[2], ad = a[3],
		        atx = a[4], aty = a[5],
		        ba = b[0], bb = b[1], bc = b[2], bd = b[3],
		        btx = b[4], bty = b[5];

		    out[0] = aa*ba + ab*bc;
		    out[1] = aa*bb + ab*bd;
		    out[2] = ac*ba + ad*bc;
		    out[3] = ac*bb + ad*bd;
		    out[4] = ba*atx + bc*aty + btx;
		    out[5] = bb*atx + bd*aty + bty;
		    return out;
		};

		/**
		 * Alias for {@link #multiply}
		 *
		 * @property {Function}
		 */
		mat2d.mul = mat2d.multiply;


		/**
		 * Rotates a mat2d by the given angle
		 *
		 * @param {mat2d} out the receiving matrix
		 * @param {mat2d} a the matrix to rotate
		 * @param {Number} rad the angle to rotate the matrix by
		 * @returns {mat2d} out
		 */
		mat2d.rotate = function (out, a, rad) {
		    var aa = a[0],
		        ab = a[1],
		        ac = a[2],
		        ad = a[3],
		        atx = a[4],
		        aty = a[5],
		        st = Math.sin(rad),
		        ct = Math.cos(rad);

		    out[0] = aa*ct + ab*st;
		    out[1] = -aa*st + ab*ct;
		    out[2] = ac*ct + ad*st;
		    out[3] = -ac*st + ct*ad;
		    out[4] = ct*atx + st*aty;
		    out[5] = ct*aty - st*atx;
		    return out;
		};

		/**
		 * Scales the mat2d by the dimensions in the given vec2
		 *
		 * @param {mat2d} out the receiving matrix
		 * @param {mat2d} a the matrix to translate
		 * @param {vec2} v the vec2 to scale the matrix by
		 * @returns {mat2d} out
		 **/
		mat2d.scale = function(out, a, v) {
		    var vx = v[0], vy = v[1];
		    out[0] = a[0] * vx;
		    out[1] = a[1] * vy;
		    out[2] = a[2] * vx;
		    out[3] = a[3] * vy;
		    out[4] = a[4] * vx;
		    out[5] = a[5] * vy;
		    return out;
		};

		/**
		 * Translates the mat2d by the dimensions in the given vec2
		 *
		 * @param {mat2d} out the receiving matrix
		 * @param {mat2d} a the matrix to translate
		 * @param {vec2} v the vec2 to translate the matrix by
		 * @returns {mat2d} out
		 **/
		mat2d.translate = function(out, a, v) {
		    out[0] = a[0];
		    out[1] = a[1];
		    out[2] = a[2];
		    out[3] = a[3];
		    out[4] = a[4] + v[0];
		    out[5] = a[5] + v[1];
		    return out;
		};

		/**
		 * Returns a string representation of a mat2d
		 *
		 * @param {mat2d} a matrix to represent as a string
		 * @returns {String} string representation of the matrix
		 */
		mat2d.str = function (a) {
		    return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' +
		                    a[3] + ', ' + a[4] + ', ' + a[5] + ')';
		};

		return mat2d;
	}
)

/**
 * @class spell.shared.util.platform.Types
 */
define(
	'spell/shared/util/platform/Types',
	[
		'spell/shared/util/platform/private/nativeType/createFloatArray',
		'spell/shared/util/platform/private/nativeType/hasFloatArraySupport',
		'spell/shared/util/platform/private/nativeType/Int8Array',
		'spell/shared/util/platform/private/nativeType/Int32Array',
		'spell/shared/util/platform/private/Time'
	],
	function(
		createFloatArray,
		hasFloatArraySupport,
		Int8Array,
		Int32Array,
		Time
	) {
		'use strict'


		return {
			createFloatArray     : createFloatArray,
			hasFloatArraySupport : hasFloatArraySupport,
			Int8Array            : Int8Array,
			Int32Array           : Int32Array,
			Time                 : Time
		}
	}
)

/*
 * This file is derived from glMatrix 2.1.0. Original Licence follows:
 */

/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */


define(
	'spell/math/mat2',
	[
		'spell/shared/util/platform/Types'
	],
	function(
		Types
	) {
		'use strict'


		/**
		 * 2x2 matrix functions
		 *
		 * @class spell.math.mat2
		 * @singleton
		 * @requires Math
		 * @requires spell.shared.util.platform.Types
		 */
		var mat2 = {};

		/**
		 * Creates a new identity mat2
		 *
		 * @returns {mat2} a new 2x2 matrix
		 */
		mat2.create = function() {
		    var out = Types.createFloatArray(4);
		    out[0] = 1;
		    out[1] = 0;
		    out[2] = 0;
		    out[3] = 1;
		    return out;
		};

		/**
		 * Creates a new mat2 initialized with values from an existing matrix
		 *
		 * @param {mat2} a matrix to clone
		 * @returns {mat2} a new 2x2 matrix
		 */
		mat2.clone = function(a) {
		    var out = Types.createFloatArray(4);
		    out[0] = a[0];
		    out[1] = a[1];
		    out[2] = a[2];
		    out[3] = a[3];
		    return out;
		};

		/**
		 * Copy the values from one mat2 to another
		 *
		 * @param {mat2} out the receiving matrix
		 * @param {mat2} a the source matrix
		 * @returns {mat2} out
		 */
		mat2.copy = function(out, a) {
		    out[0] = a[0];
		    out[1] = a[1];
		    out[2] = a[2];
		    out[3] = a[3];
		    return out;
		};

		/**
		 * Set a mat2 to the identity matrix
		 *
		 * @param {mat2} out the receiving matrix
		 * @returns {mat2} out
		 */
		mat2.identity = function(out) {
		    out[0] = 1;
		    out[1] = 0;
		    out[2] = 0;
		    out[3] = 1;
		    return out;
		};

		/**
		 * Transpose the values of a mat2
		 *
		 * @param {mat2} out the receiving matrix
		 * @param {mat2} a the source matrix
		 * @returns {mat2} out
		 */
		mat2.transpose = function(out, a) {
		    // If we are transposing ourselves we can skip a few steps but have to cache some values
		    if (out === a) {
		        var a1 = a[1];
		        out[1] = a[2];
		        out[2] = a1;
		    } else {
		        out[0] = a[0];
		        out[1] = a[2];
		        out[2] = a[1];
		        out[3] = a[3];
		    }

		    return out;
		};

		/**
		 * Inverts a mat2
		 *
		 * @param {mat2} out the receiving matrix
		 * @param {mat2} a the source matrix
		 * @returns {mat2} out
		 */
		mat2.invert = function(out, a) {
		    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],

		        // Calculate the determinant
		        det = a0 * a3 - a2 * a1;

		    if (!det) {
		        return null;
		    }
		    det = 1.0 / det;

		    out[0] =  a3 * det;
		    out[1] = -a1 * det;
		    out[2] = -a2 * det;
		    out[3] =  a0 * det;

		    return out;
		};

		/**
		 * Calculates the adjugate of a mat2
		 *
		 * @param {mat2} out the receiving matrix
		 * @param {mat2} a the source matrix
		 * @returns {mat2} out
		 */
		mat2.adjoint = function(out, a) {
		    // Caching this value is nessecary if out == a
		    var a0 = a[0];
		    out[0] =  a[3];
		    out[1] = -a[1];
		    out[2] = -a[2];
		    out[3] =  a0;

		    return out;
		};

		/**
		 * Calculates the determinant of a mat2
		 *
		 * @param {mat2} a the source matrix
		 * @returns {Number} determinant of a
		 */
		mat2.determinant = function (a) {
		    return a[0] * a[3] - a[2] * a[1];
		};

		/**
		 * Multiplies two mat2's
		 *
		 * @param {mat2} out the receiving matrix
		 * @param {mat2} a the first operand
		 * @param {mat2} b the second operand
		 * @returns {mat2} out
		 */
		mat2.multiply = function (out, a, b) {
		    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
		    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
		    out[0] = a0 * b0 + a1 * b2;
		    out[1] = a0 * b1 + a1 * b3;
		    out[2] = a2 * b0 + a3 * b2;
		    out[3] = a2 * b1 + a3 * b3;
		    return out;
		};

		/**
		 * Alias for {@link #multiply}
		 *
		 * @property {Function}
		 */
		mat2.mul = mat2.multiply;

		/**
		 * Rotates a mat2 by the given angle
		 *
		 * @param {mat2} out the receiving matrix
		 * @param {mat2} a the matrix to rotate
		 * @param {Number} rad the angle to rotate the matrix by
		 * @returns {mat2} out
		 */
		mat2.rotate = function (out, a, rad) {
		    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
		        s = Math.sin(rad),
		        c = Math.cos(rad);
		    out[0] = a0 *  c + a1 * s;
		    out[1] = a0 * -s + a1 * c;
		    out[2] = a2 *  c + a3 * s;
		    out[3] = a2 * -s + a3 * c;
		    return out;
		};

		/**
		 * Scales the mat2 by the dimensions in the given vec2
		 *
		 * @param {mat2} out the receiving matrix
		 * @param {mat2} a the matrix to rotate
		 * @param {vec2} v the vec2 to scale the matrix by
		 * @returns {mat2} out
		 **/
		mat2.scale = function(out, a, v) {
		    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
		        v0 = v[0], v1 = v[1];
		    out[0] = a0 * v0;
		    out[1] = a1 * v1;
		    out[2] = a2 * v0;
		    out[3] = a3 * v1;
		    return out;
		};

		/**
		 * Returns a string representation of a mat2
		 *
		 * @param {mat2} mat matrix to represent as a string
		 * @returns {String} string representation of the matrix
		 */
		mat2.str = function (a) {
		    return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
		};

		return mat2;
	}
)

define(
	'spell/client/createSpell',
    [
		'spell/math/mat2',
		'spell/math/mat2d',
		'spell/math/mat3',
		'spell/math/mat4',
		'spell/math/quat',
		'spell/math/util',
		'spell/math/vec2',
		'spell/math/vec3',
		'spell/math/vec4',
		'spell/math/random/XorShift32'
    ],
	function(
		mat2,
		mat2d,
		mat3,
		mat4,
		quat,
		util,
		vec2,
		vec3,
		vec4,
		XorShift32
    ) {
		'use strict'


		return function() {
			return {
				math : {
					random : {
						XorShift32 : XorShift32
					},
					mat2 : mat2,
					mat2d : mat2d,
					mat3 : mat3,
					mat4 : mat4,
					quat : quat,
					vec2 : vec2,
					vec3 : vec3,
					vec4 : vec4
				}
			}
		}
	}
)

define(
	'spell/client/main',
	[
		'spell/client/createSpell',
		'spell/client/development/createDebugMessageHandler',
		'spell/client/isDebug',
		'spell/client/staticInclude',
		'spell/client/setApplicationModule',
		'spell/client/showSplashScreen',
		'spell/shared/util/createMainLoop',
		'spell/EntityManager',
		'spell/SceneManager',
		'spell/AssetManager',
		'spell/ConfigurationManager',
		'spell/EventManager',
		'spell/InputManager',
		'spell/LibraryManager',
		'spell/shared/util/createModuleLoader',
		'spell/PluginManager',
		'spell/StatisticsManager',
		'spell/Console',
		'spell/shared/util/physics/createBox2dContext',
		'spell/shared/util/platform/PlatformKit',
		'spell/shared/util/platform/initDebugEnvironment',
        'spell/shared/util/translate',

		'spell/functions'
	],
	function(
		createSpell,
		createDebugMessageHandler,
		isDebug,
		staticInclude,
		setApplicationModule,
		showSplashScreen,
		createMainLoop,
		EntityManager,
		SceneManager,
		AssetManager,
		ConfigurationManager,
		EventManager,
		InputManager,
		LibraryManager,
		createModuleLoader,
		PluginManager,
		StatisticsManager,
		Console,
		createBox2dContext,
		PlatformKit,
		initDebugEnvironment,
        translate,

		_,

		// configuration parameters passed in from stage zero loader
		stageZeroConfig
	) {
		'use strict'


		var preStart = function( applicationModule, cacheContent ) {
			PlatformKit.init( this.spell, _.bind( start, this, applicationModule, cacheContent ) )
		}

		var start = function( applicationModule, cacheContent ) {
			var spell                = this.spell,
				eventManager         = spell.eventManager,
				configurationManager = spell.configurationManager,
				isModeDeployed       = spell.loaderConfig.mode === 'deployed',
				libraryManager       = new LibraryManager( eventManager, configurationManager.getValue( 'libraryUrl' ), isModeDeployed )

			setApplicationModule(
                spell,
                configurationManager,
				PlatformKit.platformDetails.getTarget(),
                applicationModule,
                spell.loaderConfig
            )

			spell.console.setSendMessageToEditor( this.sendMessageToEditor )

			if( cacheContent ) {
				libraryManager.addToCache( cacheContent )
			}

			// creating rendering context
			var renderingContext = PlatformKit.RenderingFactory.createContext2d(
				spell.eventManager,
				configurationManager.getValue( 'id' ),
				configurationManager.getValue( 'currentScreenSize' )[ 0 ],
				configurationManager.getValue( 'currentScreenSize' )[ 1 ],
				configurationManager.getValue( 'renderingBackEnd' )
			)

			spell.console.debug( 'created rendering context (' + renderingContext.getConfiguration().type + ')' )


			// creating audio context
			var audioContext = PlatformKit.AudioFactory.createAudioContext(
				configurationManager.getValue( 'audioBackEnd' )
			)

			spell.console.debug( 'created audio context (' + audioContext.getConfiguration().type + ')' )


			libraryManager.init( audioContext, renderingContext )


			var assetManager = new AssetManager( libraryManager )

			var isModeDevelopment = configurationManager.getValue( 'mode' ) !== 'deployed'

			var moduleLoader = createModuleLoader( libraryManager, isModeDevelopment, configurationManager.getValue( 'libraryUrl' ) )

			var entityManager = new EntityManager( spell, configurationManager, assetManager, spell.eventManager, libraryManager, moduleLoader )

			var sceneManager = new SceneManager(
				spell,
				entityManager,
				spell.statisticsManager,
				libraryManager,
				spell.mainLoop,
				this.sendMessageToEditor,
				isModeDevelopment
			)

			var translatePartial = _.bind(
				translate,
				null,
				libraryManager,
				configurationManager.getValue( 'currentLanguage' )
			)

			var inputManager = new InputManager( configurationManager, renderingContext )
			inputManager.init()

			spell.audioContext         = audioContext
			spell.assetManager         = assetManager
			spell.configurationManager = configurationManager
			spell.moduleLoader         = moduleLoader
			spell.entityManager        = entityManager
			spell.box2dContext         = createBox2dContext()
			spell.box2dWorlds          = {}
			spell.renderingContext     = renderingContext
			spell.sceneManager         = sceneManager
			spell.sendMessageToEditor  = this.sendMessageToEditor
			spell.translate            = translatePartial
			spell.inputManager         = inputManager
			spell.environment          = PlatformKit.createEnvironment( configurationManager, eventManager )
			spell.env                  = spell.environment
			spell.libraryManager       = libraryManager

			spell.console.debug( 'client started' )

			var run = function() {
				spell.sceneManager.startScene( spell.applicationModule.startScene, undefined, !isModeDevelopment )
				spell.mainLoop.run()
			}

			if( applicationModule.environment &&
				applicationModule.environment.forceSplashScreen ) {

				showSplashScreen( spell, run )

			} else {
				run()
			}
		}

		var init = function( loaderConfig ) {
			var spell                = createSpell(),
				console              = new Console(),
				eventManager         = new EventManager(),
				configurationManager = new ConfigurationManager( eventManager ),
				statisticsManager    = new StatisticsManager(),
				mainLoop             = createMainLoop( eventManager, statisticsManager, isDebug ),
				isModeDeployed       = loaderConfig.mode === 'deployed'

			statisticsManager.init()

			spell.applicationModule    = undefined
			spell.configurationManager = configurationManager
			spell.eventManager         = eventManager
			spell.loaderConfig         = loaderConfig
			spell.console              = console
			spell.mainLoop             = mainLoop
			spell.registerTimer        = PlatformKit.registerTimer
			spell.scenes               = {}
			spell.statisticsManager    = statisticsManager
			spell.storage              = PlatformKit.createPersistentStorage()
			spell.pluginManager        = new PluginManager()

			this.spell = spell

			if( !isModeDeployed ) {
				console.setLogLevel( console.LOG_LEVEL_DEBUG )
				initDebugEnvironment( console )

				this.debugMessageHandler = createDebugMessageHandler(
					spell,
					_.bind( this.start, this )
				)
			}
		}


		var main = function() {
			this.spell
			this.debugMessageHandler
			this.sendMessageToEditor

			init.call( this, stageZeroConfig )
		}

		main.prototype = {
			start : preStart,

			/*
			 * This callback is called when the engine instance sends message to the editing environment.
			 *
			 * @param {Function} fn
			 */
			setSendMessageToEditor : function( fn ) {
				this.sendMessageToEditor = fn
			},

			/*
			 * This method is used to send debug messages to the engine instance.
			 *
			 * @param {Object} message
			 */
			sendDebugMessage : function( message ) {
				this.debugMessageHandler( message.payload, message.type )
			}
		}

		return new main()
	}
)

define(
	'spell/shared/util/platform/private/storage/PersistentStorage',
	[
		'spell/shared/util/platform/private/storage/CookieStorage',
		'spell/shared/util/platform/private/storage/LocalStorage'
	],
	function(
		CookieStorage,
		LocalStorage
	) {
		'use strict'


		var hasLocalStorage = function() {
			return 'localStorage' in window && window[ 'localStorage' ] !== null
		}

		var PersistentStorage = function() {
			this.storage = hasLocalStorage() ? new LocalStorage() : new CookieStorage()
		}

		PersistentStorage.prototype = {
			set: function( key, value ) {
				this.storage.set( key, value )
			},
			get: function( key ) {
				return this.storage.get( key )
			},
			clear: function( key ) {
				this.storage.clear( key )
			}
		}

		return PersistentStorage
	}
)

define(
	'spell/shared/util/platform/private/storage/LocalStorage',
	[
		'spell/shared/util/platform/private/storage/decodeValue',
		'spell/shared/util/platform/private/storage/encodeValue'
	],
	function(
		decodeValue,
		encodeValue
	) {
		'use strict'


		var PREFIX = 'SpellJS-'

		var LocalStorage = function() {
			this.store = window.localStorage
		}

		LocalStorage.prototype = {
			clear : function( name ) {
				this.store.removeItem( PREFIX + name )
			},
			set : function( name, value ) {
				if( value === undefined ||
					value === null ) {

					return
				}

				this.store.setItem( PREFIX + name, encodeValue( value ) )
			},
			get : function( name ) {
				return decodeValue( this.store.getItem( PREFIX + name ) )
			}
		}

		return LocalStorage
	}
)

define(
	'spell/shared/util/platform/private/storage/encodeValue',
	[
		'spell/functions'
	],
	function(
		_
	) {
		'use strict'

		var encodeValue = function( value ){
			var flat = '',
				i = 0,
				enc,
				len,
				key;

			if (value == null) {
				return 'e:1';
			} else if(typeof value == 'number') {
				enc = 'n:' + value;
			} else if(typeof value == 'boolean') {
				enc = 'b:' + (value ? '1' : '0');
			} else if(_.isArray(value)) {
				for (len = value.length; i < len; i++) {
					flat += encodeValue(value[i]);
					if (i != len - 1) {
						flat += '^';
					}
				}
				enc = 'a:' + flat;
			} else if (typeof value == 'object') {
				for (key in value) {
					if (typeof value[key] != 'function' && value[key] !== undefined) {
						flat += key + '=' + encodeValue(value[key]) + '^';
					}
				}
				enc = 'o:' + flat.substring(0, flat.length-1);
			} else {
				enc = 's:' + value;
			}
			return escape(enc);
		}

		return encodeValue
	}
)

define(
	'spell/shared/util/platform/private/storage/decodeValue',
	[
		'spell/functions'
	],
	function(
		_
	) {
		'use strict'

		var decodeValue = function( value ){
			// a -> Array
			// n -> Number
			// b -> Boolean
			// s -> String
			// o -> Object
			// -> Empty (null)

			var	re = /^(a|n|b|s|o|e)\:(.*)$/,
				matches = re.exec(unescape(value)),
				all,
				type,
				keyValue,
				values,
				vLen,
				v;

			if(!matches || !matches[1]){
				return; // non state
			}

			type = matches[1];
			value = matches[2];
			switch (type) {
				case 'e':
					return null;
				case 'n':
					return parseFloat(value);
				case 'b':
					return (value == '1');
				case 'a':
					all = [];
					if(value != ''){
						values = value.split('^');
						vLen   = values.length;

						for (v = 0; v < vLen; v++) {
							value = values[v];
							all.push(decodeValue(value));
						}
					}
					return all;
				case 'o':
					all = {};
					if(value != ''){
						values = value.split('^');
						vLen   = values.length;

						for (v = 0; v < vLen; v++) {
							value = values[v];
							keyValue         = value.split('=');
							all[keyValue[0]] = decodeValue(keyValue[1]);
						}
					}
					return all;
				default:
					return value;
			}
		}

		return decodeValue
	}
)

define(
	'spell/shared/util/platform/private/storage/CookieStorage',
	[
		'spell/shared/util/platform/private/storage/decodeValue',
		'spell/shared/util/platform/private/storage/encodeValue'
	],
	function(
		decodeValue,
		encodeValue
	) {
		'use strict'


		var PREFIX  = "SpellJS-"

		var CookieStorage = function() {
			var me = this

			me.path    = "/"
			me.expires = new Date(new Date().getTime()+(1000*60*60*24*7)) //7 days
			me.domain  = null
			me.secure  = false
			me.state   = me.readCookies()
		}

		CookieStorage.prototype = {
			clear : function( name ) {
				this.clearCookie( name )
			},
			set : function( name, value ) {
				var me = this

				me.clear( name )

				if( value === undefined ||
					value === null ) {

					return
				}

				me.setCookie( name, value )
			},
			get : function( name ) {
				return decodeValue( this.state[ PREFIX + name ] )
			},
			readCookies : function() {
				var cookies = {},
					c = document.cookie + ";",
					re = /\s?(.*?)=(.*?);/g,
					len = PREFIX.length,
					matches,
					name,
					value

				while((matches = re.exec(c)) != null) {
					name = matches[1]
					value = matches[2]
					if (name && name.substring(0, len) == PREFIX){
						cookies[name.substr(len)] = decodeValue(value)
					}
				}
				return cookies
			},
			// private
			setCookie : function ( name, value ) {
				var me     = this,
					prefix = PREFIX + name

				document.cookie = prefix + "=" + encodeValue(value) +
					((me.expires == null) ? "" : ("; expires=" + me.expires.toGMTString())) +
					((me.path == null) ? "" : ("; path=" + me.path)) +
					((me.domain == null) ? "" : ("; domain=" + me.domain)) +
					((me.secure == true) ? "; secure" : "")

				me.state[ prefix ] = value
			},
			clearCookie : function( name ) {
				var me     = this,
					prefix = PREFIX + name

				document.cookie = prefix + "=null; expires=Thu, 01-Jan-70 00:00:01 GMT" +
					((me.path == null) ? "" : ("; path=" + me.path)) +
					((me.domain == null) ? "" : ("; domain=" + me.domain)) +
					((me.secure == true) ? "; secure" : "")

				delete me.state[ prefix ]
			}
		}

		return CookieStorage
	}
)

define(
	'spell/shared/util/platform/private/platformDetails',
	[
		'spell/shared/util/platform/private/input/support',
		'spell/shared/util/platform/private/environment/isHtml5Ejecta',
		'spell/shared/util/platform/private/environment/isHtml5GameClosure',
		'spell/shared/util/platform/private/environment/isHtml5Tizen',
		'spell/shared/util/platform/private/environment/isHtml5WinPhone',
		'spell/shared/util/platform/private/environment/isHtml5WinStore',
		'spell/shared/util/platform/private/jsonCoder'
	],
	function(
		support,
		isHtml5Ejecta,
		isHtml5GameClosure,
		isHtml5Tizen,
		isHtml5WinPhone,
		isHtml5WinStore,
		jsonCoder
	) {
		'use strict'


		if( isHtml5GameClosure ) {
			var gameClosureDeviceInfo = jsonCoder.decode( NATIVE.device.native_info )
		}

		return {
			hasPlentyRAM : function() {
                return !isHtml5Ejecta
            },
			hasTouchSupport : function() {
				return support.hasWebkitTouchApi() ||
					support.hasPointerTouchApi()
			},
			hasDeviceOrientationSupport : support.hasDeviceOrientationApi,
			getOS : function() {
				if( isHtml5Ejecta ) {
					return 'iOS ' + navigator.userAgent.match( /([\.\d]+)\)$/ )[ 1 ]

				} else if( isHtml5GameClosure ) {
					return 'Android ' + gameClosureDeviceInfo.versionRelease

				} else {
					return navigator.platform
				}
			},
			getPlatformAdapter : function() {
				if( isHtml5Ejecta ) return 'ejecta'
				if( isHtml5GameClosure ) return 'gameclosure'

				return 'html5'
			},
			getPlatform : function() {
				return navigator.userAgent
			},
			getTarget : function() {
				if( isHtml5Ejecta ) return 'ios'
				if( isHtml5GameClosure ) return 'android'
				if( isHtml5Tizen ) return 'tizen'
				if( isHtml5WinPhone ) return 'winphone'
				if( isHtml5WinStore ) return 'winstore'

				return 'web'
			},
			getDevice : function() {
				if( isHtml5Ejecta ) return navigator.userAgent.match( /\((.*);/ )[ 1 ]
				if( isHtml5GameClosure ) return gameClosureDeviceInfo.model + ', ' + gameClosureDeviceInfo.manufacturer

				return 'unknown'
			},
			getScreenHeight: function() {
				return screen.height
			},
			getScreenWidth: function() {
				return screen.width
			},
			isMobileDevice: function() {
				return isHtml5Ejecta || isHtml5GameClosure
			}
		}
	}
)

define(
	'spell/shared/util/platform/private/openURL',
	[
		'spell/shared/util/platform/private/environment/isHtml5Ejecta',
		'spell/shared/util/platform/private/environment/isHtml5Tizen',
		'spell/shared/util/platform/private/environment/isHtml5WinPhone'
	],
	function(
		isHtml5Ejecta,
	    isHtml5Tizen,
		isHtml5WinPhone
	) {
		'use strict'


		return function( url, message ) {
			if( isHtml5WinPhone ) {
				window.external.notify( 'openUrl;' + url )

			} else if( isHtml5Ejecta ) {
				ejecta.openURL( url, message )

			} else if( isHtml5Tizen ) {
				var appControl = new tizen.ApplicationControl(
					'http://tizen.org/appcontrol/operation/view',
					url
				)

				tizen.application.launchAppControl(
					appControl,
					null,
					function() { },
					function( e ) { }
				)

			} else {
				window.open( url, '_blank' )
			}
		}
	}
)

define(
	'spell/shared/util/platform/private/network/performHttpRequest',
	[
		'spell/functions'
	],
	function(
		_
	) {
		'use strict'


		var createParameters = function( parameters ) {
			return _.map(
				parameters,
				function( value, key ) {
					return key + '=' + encodeURIComponent( value )
				}

			).join( '&' )
		}

		var createRequest = function() {
			return typeof XDomainRequest === 'undefined' ? new XMLHttpRequest() : new XDomainRequest()
		}

		var createCorsRequest = function( method, url, data, onLoad, onError ) {
			var request = createRequest()

			if( onLoad ) {
				request.onreadystatechange = function() {
					if( this.readyState == 4 &&
						this.status == 200 ) {

						onLoad( this.responseText )
					}
				}
			}

			if( _.size( data ) > 0 &&
				method == 'GET' ) {

				url += '?' + createParameters( data )
			}

			if( onError ) {
				request.onerror = function( event ) {
					onError( 'Error while accessing ' + url + '.' )
				}
			}

			request.open( method, url, true )

			return request
		}

		/**
		 * Performs a http request. The host specified in the url must allow CORS requests (html5 and flash). Otherwise
		 * an uncatchable error will be thrown.
		 *
		 * @param method
		 * @param url
		 * @param data
		 * @param onLoad
		 * @param onError
		 */
		var performHttpRequest = function( method, url, data, onLoad, onError ) {
			if( !method ) {
				throw 'method is undefined.'
			}

			if( method !== 'GET' &&
				method !== 'POST' ) {

				throw 'The provided method is not supported.'
			}

			if( !url ) {
				throw 'url is undefined.'
			}

			var request = createCorsRequest( method, url, data, onLoad, onError )

			if( method === 'POST' ) {
				if( request.setRequestHeader ) {
					request.setRequestHeader( 'Content-Type', 'application/x-www-form-urlencoded' )
				}

				request.send( createParameters( data ) )

			} else {
				request.send()
			}
		}

		return performHttpRequest
	}
)

define(
	'spell/shared/util/platform/private/network/createSocket',
	function() {
		'use strict'


		return function( host ) {
			var WebSocket = window.MozWebSocket || window.WebSocket,
				socket    = new WebSocket( 'ws://' + host + '/', 'socketrocket-0.1')

			return {
				send : function( message ) {
					socket.send( message )
				},
				setOnMessage : function( callback ) {
					socket.onmessage = function( event ) {
						callback( event.data )
					}
				},
				setOnConnected : function( callback ) {
					socket.onopen = function( event ) {
						callback( event.data )
					}
				}
			}
		}
	}
)

define(
	'spell/shared/util/platform/private/ModuleLoader',
	function() {
		'use strict'


		/**
		 * The global needjs public functions are wrapped into this amd module in order to prevent a dependency on global namespace.
		 */

		var createDependentModules = typeof window === 'undefined' ?
			function() {} :
			window.createDependentModules

		return {
			createDependentModules : createDependentModules,
			require                : require,
			define                 : define
		}
	}
)

define(
	'spell/shared/util/platform/private/log',
	[
		'spell/functions'
	],
	function(
		_
	) {
		'use strict'


		return function( text ) {
			if( console.originalLog ) {
				console.originalLog( text )

			} else {
				console.log( text )
			}
		}
	}
)

define(
	'spell/shared/util/platform/private/loader/TextLoader',
	[
		'spell/functions'
	],
	function(
		_
	) {
		'use strict'


		var onLoad = function( request ) {
			if( this.loaded === true ) return

			this.loaded = true

			var response = request.response || request.responseText

			if( request.status !== 200 &&
				request.status !== 0 ) {

				onError.call( this, response )

				return
			}

			this.onLoadCallback( this.postProcess ? this.postProcess( response ) : response )
		}

		var onError = function( event ) {
			this.onErrorCallback( event )
		}

		var onReadyStateChange = function( request ) {
			/*
			 * readyState === 4 means 'DONE'; see https://developer.mozilla.org/en/DOM/XMLHttpRequest
			 */
			if( request.readyState !== 4 ) return

			onLoad.call( this, request )
		}


		var TextLoader = function( postProcess, url, onLoadCallback, onErrorCallback, onTimedOutCallback ) {
			this.postProcess     = postProcess
			this.url             = url
			this.onLoadCallback  = onLoadCallback
			this.onErrorCallback = onErrorCallback
			this.loaded          = false
		}

		TextLoader.prototype = {
			start : function() {
				var request = new XMLHttpRequest()

				request.onload             = _.bind( onLoad, this, request )
				request.onreadystatechange = _.bind( onReadyStateChange, this, request )
				request.onerror            = _.bind( onError, this )

				request.open( 'GET', this.url, true )
				request.send()
			}
		}

		return TextLoader
	}
)

define(
	'spell/shared/util/platform/private/loader/SoundLoader',
	[
		'spell/functions'
	],
	function(
		_
	) {
		'use strict'


		var onLoad = function( buffer ) {
			if( this.loaded === true ) return
			this.loaded = true

			// TODO: free SoundLoader retained js objects

			this.onLoadCallback( this.audioContext.createSound( buffer ) )
		}


		var SoundLoader = function( audioContext, asset, url, onLoadCallback, onErrorCallback, onTimedOutCallback ) {
			this.audioContext    = audioContext
			this.asset           = asset
			this.url             = url
			this.onLoadCallback  = onLoadCallback
			this.onErrorCallback = onErrorCallback
			this.loaded          = false
		}

		SoundLoader.prototype = {
			start : function() {
				this.audioContext.loadBuffer(
					this.url,
					this.asset,
					_.bind( onLoad, this )
				)
			}
		}

		return SoundLoader
	}
)

define(
	'spell/shared/util/platform/private/loader/ImageLoader',
	[
		'spell/functions'
	],
	function(
		_
	) {
		'use strict'


		var free = function( image ) {
			image.onload = null
			image.onreadystatechange = null
			image.onerror = null
		}

		var onLoad = function( image ) {
			if( this.loaded === true ) return
			this.loaded = true

			free( image )
			this.onLoadCallback( this.renderingContext.createTexture( image ) )
		}

		var onError = function( image, event ) {
			free( image )
			this.onErrorCallback( event )
		}

		var onReadyStateChange = function( image ) {
			if( image.readyState === 'complete' ) {
				image.onload( image )
			}
		}


		var ImageLoader = function( renderingContext, url, onLoadCallback, onErrorCallback, onTimedOutCallback ) {
			this.renderingContext = renderingContext
			this.url              = url
			this.onLoadCallback   = onLoadCallback
			this.onErrorCallback  = onErrorCallback
			this.loaded           = false
		}

		ImageLoader.prototype = {
			start : function() {
				var image = new Image()

				image.onload             = _.bind( onLoad, this, image )
				image.onreadystatechange = _.bind( onReadyStateChange, this, image )
				image.onerror            = _.bind( onError, this, image )
				image.src                = this.url
			}
		}

		return ImageLoader
	}
)

define(
	'spell/shared/util/platform/private/jsonCoder',
	[
		'spell/functions'
	],
	function(
		_
	) {
		'use strict'


		/**
		 * Creates a string encoded json data structure out of a json data structure.
		 */
		var encode = _.bind( JSON.stringify, JSON )

		/**
		 * Creates a json data structure out of a string encoded json data structure.
		 */
		var decode = _.bind( JSON.parse, JSON )

		return {
			encode : encode,
			decode : decode
		}
	}
)

define(
	'spell/shared/util/platform/private/Input',
	[
		'spell/shared/util/platform/private/input/deviceOrientationHandler',
		'spell/shared/util/platform/private/input/keyHandler',
		'spell/shared/util/platform/private/input/pointerHandler',
		'spell/shared/util/platform/private/input/mousewheelHandler'
	],
	function(
		deviceOrientationHandler,
		keyHandler,
		pointerHandler,
		mousewheelHandler
	) {
		'use strict'


		var preventDefaultHandler = function( event ) {
			event.preventDefault()
		}

		var setListener = function( callback ) {
			// disable context menu on right click
			document.addEventListener( 'contextmenu', preventDefaultHandler, true )

			deviceOrientationHandler.registerListener( window, callback )
			keyHandler.registerListener( document, callback )
			mousewheelHandler.registerListener( document, callback )
			pointerHandler.registerListener( document, this.container, this.configurationManager, callback )
		}

		var removeListener = function() {
			deviceOrientationHandler.removeListener( window )
			keyHandler.removeListener( document )
			mousewheelHandler.removeListener( document )
			pointerHandler.removeListener( document )
		}

		var Input = function( configurationManager, renderingContext ) {
			this.configurationManager = configurationManager
			this.container            = renderingContext.getCanvasElement()
		}

		Input.prototype = {
			setInputEventListener : setListener,
			removeInputEventListener : removeListener
		}

		return Input
	}
)

define(
	'spell/shared/util/platform/private/input/support',
	[
		'spell/functions',
		'spell/shared/util/platform/private/input/deviceOrientationHandler',
		'spell/shared/util/platform/private/environment/isHtml5Ejecta',
		'spell/shared/util/platform/private/environment/isHtml5GameClosure',
		'spell/shared/util/platform/private/registerTimer'
	],
	function(
		_,
		deviceOrientationHandler,
		isHtml5Ejecta,
		isHtml5GameClosure,
		registerTimer
	) {
		'use strict'


		var DEVICE_ORIENTATION_PROBING_TIMEOUT = 50

		var isBrokenDeviceOrientationApi = true

		return {
			hasPointerApi : function() {
				return window.navigator.pointerEnabled
			},
			hasMicrosoftPointerApi : function() {
				return window.navigator.msPointerEnabled
			},
			hasPointerTouchApi : function() {
				return ( 'msMaxTouchPoints' in window.navigator && window.navigator.msMaxTouchPoints > 0 ) ||
					( 'maxTouchPoints' in window.navigator && window.navigator.maxTouchPoints > 0 )
			},
			hasWebkitTouchApi : function() {
				return ( 'ontouchstart' in window ) || // webkit
					( window.DocumentTouch && document instanceof DocumentTouch ) || // Firefox Mobile
					isHtml5Ejecta
			},
			hasDeviceOrientationApi : function() {
				return isHtml5GameClosure ||
					( window.DeviceMotionEvent !== undefined && !isBrokenDeviceOrientationApi )
			},
			hasNativeClickEvent : function() {
				return !( isHtml5Ejecta || isHtml5GameClosure )
			},
			init : function( spell, next ) {
				if( !isHtml5GameClosure && window.DeviceMotionEvent ) {
					var doneProbing = _.once( function() {
						deviceOrientationHandler.removeListener( window )

						next()
					} )

					var probeDeviceOrientationApi = function( event ) {
						if( isBrokenDeviceOrientationApi &&
							event.gamma !== 0 ) {

							isBrokenDeviceOrientationApi = false
						}
					}

					registerTimer( doneProbing, DEVICE_ORIENTATION_PROBING_TIMEOUT )

					deviceOrientationHandler.registerListener( window, probeDeviceOrientationApi )

				} else {
					next()
				}
			}
		}
	}
)

/**
 * This function handles DOM Level 3 mouse events and pointer events
 * see http://www.w3.org/TR/DOM-Level-3-Events/
 * http://www.w3.org/Submission/pointer-events/#list-of-pointer-events
 *
 * Touch Events:
 * http://developer.apple.com/library/safari/#documentation/UserExperience/Reference/TouchEventClassReference/TouchEvent/TouchEvent.html#//apple_ref/doc/uid/TP40009358
 * https://dvcs.w3.org/hg/webevents/raw-file/tip/touchevents.html
 *
 *
 * interface Event {
 *      const unsigned short              NONE            = 0;
 *      const unsigned short              CAPTURING_PHASE = 1;
 *      const unsigned short              AT_TARGET       = 2;
 *      const unsigned short              BUBBLING_PHASE  = 3;
 *
 *      readonly attribute DOMString      type;
 *      readonly attribute EventTarget?   target;
 *      readonly attribute EventTarget?   currentTarget;
 *      readonly attribute unsigned short eventPhase;
 *      readonly attribute boolean        bubbles;
 *      readonly attribute boolean        cancelable;
 *      readonly attribute DOMTimeStamp   timeStamp;
 *      void                              stopPropagation();
 *      void                              preventDefault();
 *      void                              initEvent(DOMString eventTypeArg, boolean canBubbleArg, boolean cancelableArg);
 *
 *      void                              stopImmediatePropagation();
 *      readonly attribute boolean        defaultPrevented;
 *      readonly attribute boolean        isTrusted;
 * };
 *
 * interface UIEvent : Event {
 *      readonly attribute views::AbstractView  view;
 *      readonly attribute long             detail;
 * };
 *
 * interface MouseEvent : UIEvent {
 *      readonly attribute long           screenX;
 *      readonly attribute long           screenY;
 *      readonly attribute long           clientX;
 *      readonly attribute long           clientY;
 *      readonly attribute boolean        ctrlKey;
 *      readonly attribute boolean        shiftKey;
 *      readonly attribute boolean        altKey;
 *      readonly attribute boolean        metaKey;
 *      readonly attribute unsigned short button;
 *      readonly attribute unsigned short buttons;
 *      readonly attribute EventTarget?   relatedTarget;
 *      boolean                           getModifierState(DOMString keyArg);
 * };
 *
 * interface TouchEvent : UIEvent {
 *      readonly attribute TouchList   touches;
 *      readonly attribute TouchList   targetTouches;
 *      readonly attribute TouchList   changedTouches;
 *      readonly attribute boolean     altKey;
 *      readonly attribute boolean     metaKey;
 *      readonly attribute boolean     ctrlKey;
 *      readonly attribute boolean     shiftKey;
 *      readonly attribute EventTarget relatedTarget
 * };
 *
 * interface PointerEvent : MouseEvent {
 *      const unsigned short POINTER_TYPE_UNAVAILABLE = 0x00000001;
 *      const unsigned short POINTER_TYPE_TOUCH = 0x00000002;
 *      const unsigned short POINTER_TYPE_PEN = 0x00000003;
 *      const unsigned short POINTER_TYPE_MOUSE = 0x00000004;
 *      readonly attribute long               pointerId;
 *      readonly attribute long               width;
 *      readonly attribute long               height;
 *      readonly attribute float              pressure;
 *      readonly attribute long               tiltX;
 *      readonly attribute long               tiltY;
 *      readonly attribute long               pointerType;
 *      readonly attribute unsigned long long hwTimestamp;
 *      readonly attribute boolean            isPrimary;
 * };
 */
define(
	'spell/shared/util/platform/private/input/pointerHandler',
	[
		'spell/shared/util/platform/private/input/support',

		'spell/functions'
	],
	function(
		supportedInputApi,

		_
	) {
		'use strict'


		var nativeHandler = null
		var nativeClickHandler = null

		var registeredEvents = [ ]
		var eventMappings = {
			pointermove     : 'pointerMove',
			pointerup       : 'pointerUp',
			pointerdown     : 'pointerDown',
			pointercancel   : 'pointerCancel',

			MSPointerMove   : 'pointerMove',
			MSPointerUp     : 'pointerUp',
			MSPointerDown   : 'pointerDown',
			MSPointerCancel : 'pointerCancel',

			touchstart      : 'pointerDown',
			touchmove       : 'pointerMove',
			touchend        : 'pointerUp',
			touchcancel     : 'pointerCancel',

			mousemove       : 'pointerMove',
			mousedown       : 'pointerDown',
			mouseup         : 'pointerUp'
		}

		var emitSpellPointerEvent = function( callback, eventType, pointerId, button, positionX, positionY ) {
			callback( {
				type      : eventType,
				pointerId : pointerId,
				button    : button, // 0=left button, 1=middle button if present, 2=right button
				position  : [ positionX, positionY ] // position of the pointer in screen coordinates (origin top left!)
			} )

			if( !supportedInputApi.hasNativeClickEvent() &&
				eventType === 'pointerDown' ) {

				callback( {
					type      : 'click',
					pointerId : 0,
					button    : 0, // 0=left button, 1=middle button if present, 2=right button
					position  : [ positionX, positionY ] // position of the pointer in screen coordinates (origin top left!)
				} )
			}
		}

		function getOffset( element ) {
			if( !element.getBoundingClientRect ) {
				return [ 0, 0 ]
			}

			var box = element.getBoundingClientRect()

			var body    = document.body
			var docElem = document.documentElement

			var scrollTop  = window.pageYOffset || docElem.scrollTop || body.scrollTop
			var scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft

			var clientTop  = docElem.clientTop || body.clientTop || 0
			var clientLeft = docElem.clientLeft || body.clientLeft || 0

			var top  = box.top + scrollTop - clientTop
			var left = box.left + scrollLeft - clientLeft

			return [ Math.round( left ), Math.round( top ) ]
		}

		var nativeTouchHandlerImpl = function( callback, eventMappings, container, configurationManager, event ) {
			var eventType  = event.type,
				button     = 0,
				screenSize = configurationManager.getValue( 'currentScreenSize' ),
				offset     = getOffset( container )

			// only preventDefault on touchmove, otherwise no click event is triggered in mobile Safari
			if( eventType == 'touchmove' ) {
				event.preventDefault()
			}

			if( eventMappings[ eventType ] ) {
				eventType = eventMappings[ eventType ]
			}

			for( var i = 0, length = event.changedTouches.length; i < length; i++ ) {
				var touch     = event.changedTouches[ i ],
					pointerId = touch.identifier,
					positionX = touch.pageX - offset[ 0 ],
					positionY = touch.pageY - offset[ 1 ]

				// if the event missed the display it gets ignored
				if( positionX < 0 || positionX > screenSize[ 0 ] ||
					positionY < 0 || positionY > screenSize [ 1 ] ) {

					continue
				}

				emitSpellPointerEvent( callback, eventType, pointerId, button, positionX, positionY )
			}
		}

		var nativePointerHandlerImpl = function( callback, eventMappings, container, configurationManager, event ) {
			var eventType  = event.type,
				button     = event.button,
				pointerId  = typeof event.pointerId != "undefined" ? event.pointerId :  1,
				screenSize = configurationManager.getValue( 'currentScreenSize' ),
				offset     = getOffset( container ),
				positionX  = event.pageX - offset[ 0 ],
				positionY  = event.pageY - offset[ 1 ]

			// if the event missed the display it gets ignored
			if( positionX < 0 || positionX > screenSize[ 0 ] ||
				positionY < 0 || positionY > screenSize [ 1 ] ) {

				return
			}

			if( button > 0 ) {
				// only prevent default for non left click buttons
				event.preventDefault()
			}

			if( eventMappings[ eventType ] ) {
				eventType = eventMappings[ eventType ]
			}


			emitSpellPointerEvent( callback, eventType, pointerId, button, positionX, positionY )
		}

		var nativeClickHandlerImpl = function( callback, eventMappings, container, configurationManager, event ) {
			var eventType  = event.type,
				screenSize = configurationManager.getValue( 'currentScreenSize' ),
				offset     = getOffset( container ),
				positionX  = event.pageX - offset[ 0 ],
				positionY  = event.pageY - offset[ 1 ]

			// if the event missed the display it gets ignored
			if( positionX < 0 || positionX > screenSize[ 0 ] ||
				positionY < 0 || positionY > screenSize [ 1 ] ) {

				return false
			}

			emitSpellPointerEvent( callback, eventType, 0, 0, positionX, positionY )
		}

		var registerListener = function( el, container, configurationManager, callback ) {
			if( supportedInputApi.hasPointerApi() ) {
				nativeHandler = _.bind( nativePointerHandlerImpl, this, callback, eventMappings, container, configurationManager )
				registeredEvents = [
					'pointermove', 'pointerup', 'pointerdown', 'pointercancel'
				]

			} else if( supportedInputApi.hasMicrosoftPointerApi() ) {
				nativeHandler = _.bind( nativePointerHandlerImpl, this, callback, eventMappings, container, configurationManager )
				registeredEvents = [
					'MSPointerMove', 'MSPointerUp', 'MSPointerDown', 'MSPointerCancel'
				]

			} else if( supportedInputApi.hasWebkitTouchApi() ) {
				nativeHandler = _.bind( nativeTouchHandlerImpl, this, callback, eventMappings, container, configurationManager )
				registeredEvents = [
					'touchstart', 'touchmove', 'touchend', 'touchcancel'
				]

			} else {
				// use generic mouse events as input source
				nativeHandler = _.bind( nativePointerHandlerImpl, this, callback, eventMappings, container, configurationManager )
				registeredEvents = [
					'mousemove', 'mousedown', 'mouseup'
				]
			}

			for( var i in registeredEvents ) {
				el.addEventListener( registeredEvents[i ], nativeHandler, true )
			}

			nativeClickHandler = _.bind( nativeClickHandlerImpl, this, callback, eventMappings, container, configurationManager )
			el.addEventListener( 'click', nativeClickHandler, true )
		}

		var removeListener = function( el ) {
			if( nativeHandler !== null ) {
				for( var i in registeredEvents ) {
					el.removeEventListener( registeredEvents[i ], nativeHandler )
				}
				registeredEvents.length = 0
				nativeHandler = null
			}

			el.removeEventListener( 'click', nativeClickHandler )
			nativeClickHandler = null
		}

		return {
			registerListener : registerListener,
			removeListener : removeListener
		}
	}
)

/**
 * WheelEvents
 *
 * interface WheelEvent : MouseEvent {
 *      // DeltaModeCode
 *      const unsigned long              DOM_DELTA_PIXEL = 0x00;
 *      const unsigned long              DOM_DELTA_LINE  = 0x01;
 *      const unsigned long              DOM_DELTA_PAGE  = 0x02;
 *
 *      readonly attribute double         deltaX;
 *      readonly attribute double         deltaY;
 *      readonly attribute double         deltaZ;
 *      readonly attribute unsigned long deltaMode;
 *  };
 */
define(
	'spell/shared/util/platform/private/input/mousewheelHandler',
	[
		'spell/functions'
	],
	function(
		_
	) {
		'use strict'


		var nativeHandler

		var nativeHandlerImpl = function( callback, event ) {
			event.preventDefault()

			var delta     = event.wheelDelta ? event.wheelDelta : event.detail * -1,
				direction = delta > 0 ? 1 : -1

			callback( {
				type : 'mouseWheel',
				direction : direction
			} )
		}

		var registerListener = function( el, callback ) {
			nativeHandler = _.bind( nativeHandlerImpl, this, callback )

			el.addEventListener( 'mousewheel', nativeHandler, true )
			el.addEventListener( 'DOMMouseScroll', nativeHandler, true )
		}

		var removeListener = function( el ) {
			if( nativeHandler ) {
				el.removeEventLister( 'mousewheel', nativeHandler )
				el.removeEventLister( 'DOMMouseScroll', nativeHandler )

				nativeHandler = undefined
			}
		}

		return {
			registerListener : registerListener,
			removeListener : removeListener
		}
	}
)

/**
 * http://www.w3.org/TR/DOM-Level-3-Events/#key-algorithm
 * http://www.w3.org/TR/DOM-Level-3-Events/#keys-keyvalues
 * http://www.w3.org/TR/DOM-Level-3-Events/#key-values
 *
 * interface Event {
 *      const unsigned short              NONE            = 0;
 *      const unsigned short              CAPTURING_PHASE = 1;
 *      const unsigned short              AT_TARGET       = 2;
 *      const unsigned short              BUBBLING_PHASE  = 3;
 *
 *      readonly attribute DOMString      type;
 *      readonly attribute EventTarget?   target;
 *      readonly attribute EventTarget?   currentTarget;
 *      readonly attribute unsigned short eventPhase;
 *      readonly attribute boolean        bubbles;
 *      readonly attribute boolean        cancelable;
 *      readonly attribute DOMTimeStamp   timeStamp;
 *      void                              stopPropagation();
 *      void                              preventDefault();
 *      void                              initEvent(DOMString eventTypeArg, boolean canBubbleArg, boolean cancelableArg);
 *
 *      void                              stopImmediatePropagation();
 *      readonly attribute boolean        defaultPrevented;
 *      readonly attribute boolean        isTrusted;
 * };
 *
 * interface UIEvent : Event {
 *      readonly attribute views::AbstractView  view;
 *      readonly attribute long             detail;
 * };
 *
 * interface KeyboardEvent : UIEvent {
 *      // KeyLocationCode
 *      const unsigned long       DOM_KEY_LOCATION_STANDARD      = 0x00;
 *      const unsigned long       DOM_KEY_LOCATION_LEFT          = 0x01;
 *      const unsigned long       DOM_KEY_LOCATION_RIGHT         = 0x02;
 *      const unsigned long       DOM_KEY_LOCATION_NUMPAD        = 0x03;
 *
 *      readonly attribute DOMString       keyIdentifier;
 *      readonly attribute unsigned long   keyLocation;
 *      readonly attribute boolean         ctrlKey;
 *      readonly attribute boolean         shiftKey;
 *      readonly attribute boolean         altKey;
 *      readonly attribute boolean         metaKey;
 *
 *      boolean            getModifierState(in DOMString keyIdentifierArg);
 *
 *      void               initKeyboardEvent(in DOMString typeArg,
 *                                     in boolean canBubbleArg,
 *                                     in boolean cancelableArg,
 *                                     in views::AbstractView viewArg,
 *                                     in DOMString keyIdentifierArg,
 *                                     in unsigned long keyLocationArg,
 *                                     in DOMString modifiersListArg);
 *
 *      void               initKeyboardEventNS(in DOMString namespaceURIArg,
 *                                        in DOMString typeArg,
 *                                        in boolean canBubbleArg,
 *                                        in boolean cancelableArg,
 *                                        in views::AbstractView viewArg,
 *                                        in DOMString keyIdentifierArg,
 *                                        in unsigned long keyLocationArg,
 *                                        in DOMString modifiersListArg);
 * };
 */

define(
	'spell/shared/util/platform/private/input/keyHandler',
	[
		'spell/shared/util/platform/private/environment/isHtml5GameClosure',
		'spell/shared/util/platform/private/environment/isHtml5Tizen',
		'spell/shared/util/platform/private/environment/isHtml5WinPhone',
		'spell/shared/util/input/keyCodes',
		'spell/functions'
	],
	function(
		isHtml5GameClosure,
		isHtml5Tizen,
		isHtml5WinPhone,
		keyCodes,
		_
	) {
		'use strict'


		var nativeHandler

		var KeyEvent = function( keyCode, type ) {
			this.keyCode = keyCode
			this.type = type === 'keydown' ? 'keyDown' : 'keyUp'
		}

		var nativeHandlerImpl = function( callback, event ) {
			event.preventDefault()

			var keyCode         = event.keyCode,
				keyIdentifier   = event.keyIdentifier

			if( isHtml5Tizen ) {
				if( keyIdentifier == 'XF86Send') { //menu button
					keyCode = keyCodes.MENU

				} else if( keyIdentifier == 'XF86Phone' ) { //home button
					keyCode = keyCodes.HOME

				} else if ( keyIdentifier == 'XF86Stop' ) { //back button
					keyCode = keyCodes.BACK

				} else if ( keyIdentifier == 'XF86PowerOff' ) { //power button
					keyCode = keyCodes.POWER
				}
			}

			if( keyCode ) {
				callback( new KeyEvent( keyCode, event.type ) )
			}
		}

		var registerListener = function( el, callback ) {
			if( !el ||
				!callback ) {

				return
			}

			if( isHtml5GameClosure ) {
				NATIVE.events.registerHandler(
					'keyEvent',
					function( event ) {
						callback( new KeyEvent( event.keyCode, event.type ) )
					}
				)
			} else if( isHtml5WinPhone ) {
				window.backButtonPressed = function( keyCode, type ) {
					callback(new KeyEvent(parseInt( keyCode,10), type))
				}
			}


			nativeHandler = _.bind( nativeHandlerImpl, this, callback )

			el.addEventListener( 'keyup', nativeHandler, true )
			el.addEventListener( 'keydown', nativeHandler, true )

			if( isHtml5Tizen ) {
				el.addEventListener( 'tizenhwkey', nativeHandler, true )
			}
		}

		var removeListener = function( el ) {
			if( nativeHandler !== null ) {
				el.removeEventLister( 'keyup', nativeHandler )
				el.removeEventLister( 'keydown', nativeHandler )

				if( isHtml5Tizen ) {
					el.removeEventLister( 'tizenhwkey', nativeHandler )
				}
			}

			nativeHandler = null
		}

		return {
			registerListener : registerListener,
			removeListener : removeListener
		}
	}
)

/**
 * See http://www.w3.org/TR/orientation-event/#deviceorientation for details.
 *
 * interface DeviceOrientationEvent : Event {
 *    readonly attribute double? alpha;
 *    readonly attribute double? beta;
 *    readonly attribute double? gamma;
 *    readonly attribute boolean absolute;
 *
 *    void initDeviceOrientationEvent(in DOMString type,
 *       in boolean bubbles,
 *       in boolean cancelable,
 *       in double? alpha,
 *       in double? beta,
 *       in double? gamma,
 *       in boolean absolute
 *    );
 * }
 *
 * interface DeviceAcceleration {
 *    readonly attribute double? x;
 *    readonly attribute double? y;
 *    readonly attribute double? z;
 * }
 *
 *interface DeviceRotationRate {
 *    readonly attribute double? alpha;
 *    readonly attribute double? beta;
 *    readonly attribute double? gamma;
 *}
 *
 *interface DeviceMotionEvent : Event {
 *    readonly attribute DeviceAcceleration? acceleration;
 *    readonly attribute DeviceAcceleration? accelerationIncludingGravity;
 *    readonly attribute DeviceRotationRate? rotationRate;
 *    readonly attribute double? interval;
 *
 *    void initAccelerometerEvent(
 *        in DOMString type,
 *        in boolean bubbles,
 *        in boolean cancelable,
 *        in DeviceAcceleration? acceleration,
 *        in DeviceAcceleration? accelerationIncludingGravity,
 *        in DeviceRotationRate? rotationRate,
 *        in double? interval
 *    );
 *}
 */

define(
	'spell/shared/util/platform/private/input/deviceOrientationHandler',
	[
		'spell/functions',
		'spell/shared/util/platform/private/environment/isHtml5GameClosure',
		'spell/shared/util/platform/private/environment/isHtml5Tizen'
	],
	function(
		_,
		isHtml5GameClosure,
		isHtml5Tizen
	) {
		'use strict'


		var TO_DEGREE_FACTOR = 180 / Math.PI

		var nativeHandler

		var DeviceOrientationEvent = function( alpha, beta, gamma ) {
			this.type = 'deviceOrientation'
			this.alpha = alpha
			this.beta = beta
			this.gamma = gamma
		}

		var nativeHandlerImpl = function( callback, event ) {
			event.preventDefault()

			callback( new DeviceOrientationEvent( event.alpha, event.beta, event.gamma ) )
		}

		return {
			registerListener : function( el, callback ) {
				if( isHtml5GameClosure ) {
					nativeHandler = function( event ) {
						callback( new DeviceOrientationEvent(
							event.alpha * TO_DEGREE_FACTOR,
							event.beta * TO_DEGREE_FACTOR,
							event.gamma * TO_DEGREE_FACTOR
						) )
					}

					NATIVE.events.registerHandler( 'deviceorientation', nativeHandler )

				} else if( isHtml5Tizen ) {
					nativeHandler = function( event ) {
						callback( new DeviceOrientationEvent( event.alpha, event.beta, -event.gamma ) )
					}

					el.addEventListener( 'deviceorientation', nativeHandler, true )

				} else {
					nativeHandler = _.bind( nativeHandlerImpl, this, callback )

					el.addEventListener( 'deviceorientation', nativeHandler, true )
				}
			},
			removeListener : function( el ) {
				if( !nativeHandler ) return

				if( isHtml5GameClosure ) {
					NATIVE.events.unregisterHandler( 'deviceorientation', nativeHandler )

				} else {
					el.removeEventListener( 'deviceorientation', nativeHandler, true )
				}

				nativeHandler = undefined
			}
		}
	}
)

define(
	'spell/shared/util/platform/private/initDebugEnvironment',
	function() {
		'use strict'


		return function( spellConsole ) {
			// rewiring console.log
			console.originalLog = console.log

			console.log = function() {
				if( console.originalLog ) {
					// trigger a warning for using console.log once and then allow console.log usage
					console.log = console.originalLog
					delete console.originalLog

					var warning = 'console.log can be used only during development because it is not cross-platform save. Be sure to remove this call when you finished your debugging. Use spell.console to enable cross-platform logging.'
					spellConsole.warn( warning )
					console.warn( warning )

					console.log.apply( this, arguments )
				}
			}

			// putting global error handler in place
			if( window ) {
				window.onerror = function( message, url, line ) {
					spellConsole.error( '"' + message + '" in ' + url + ':' + line )

					return true
				}
			}
		}
	}
)

define(
	'spell/shared/util/platform/private/graphics/initViewport',
	[
		'spell/shared/util/platform/private/getAvailableScreenSize',

		'spell/functions'
	],
	function(
		getAvailableScreenSize,

		_
	) {
        'use strict'


		var getViewportMetaTag = function() {
			var metaTags = document.getElementsByTagName( 'meta' )

			for( var i = 0, n = metaTags.length, metaTag; i < n; i++ ) {
				metaTag = metaTags[ i ]

				if( metaTag.name === 'viewport' ) return metaTag
			}
		}

		var updateViewportMetaTag = function( initialScale, maximumScale ) {
			var viewportMetaTag = getViewportMetaTag()
			if( !viewportMetaTag ) return

			viewportMetaTag.setAttribute(
				'content',
				'width=device-width, user-scalable=0, initial-scale=' + initialScale + ', maximum-scale=' + maximumScale + ''
			)
		}

		var deviceClasses = [
			{
				userAgentKeywords : [ 'iPhone', 'iPod', 'Tizen' ],
				initialScale : 0.5,
				maximumScale : 0.5
			},
			{
				userAgentKeywords : [ 'iPad' ],
				initialScale : 1.0,
				maximumScale : 1.0
			}
		]

		var getDeviceClass = function( userAgent ) {
			return _.find(
				deviceClasses,
				function( deviceClass ) {
					return _.any(
						deviceClass.userAgentKeywords,
						function( keyword ) {
							return userAgent.match( new RegExp( keyword, 'i' ) )
						}
					)
				}
			)
		}

		/**
		 * Initializes the browser viewport
		 *
		 * @param eventManager the event manager
		 * @param id the id of the spell container div
		 */
		return function( eventManager, id ) {
			var processResize = function() {
				if( window.scrollTo ) {
					window.scrollTo( 0, 0 )
				}

				eventManager.publish(
					eventManager.EVENT.AVAILABLE_SCREEN_SIZE_CHANGED,
					[ getAvailableScreenSize( id ) ]
				)
			}

			var processOrientationChange = function() {
				var orientation    = window.orientation,
					orienationMode = orientation === 0 ?
						'portrait' :
						orientation === -90 ?
							'landscapeRotatedRight' :
							'landscapeRotatedLeft'

				eventManager.publish(
					eventManager.EVENT.DEVICE_ORIENTATION_CHANGED,
					[ orienationMode ]
				)

				processResize()
			}

			var deviceClass = getDeviceClass( navigator.userAgent )

			if( deviceClass ) {
				updateViewportMetaTag( deviceClass.initialScale, deviceClass.maximumScale )
			}

			window.addEventListener( 'orientationchange', processOrientationChange, true )
			window.addEventListener( 'resize', processResize, true )

			processOrientationChange()
		}
	}
)

define(
	'spell/data/algorithm/RLE',
	function() {
		'use strict'


		return {
			encode : function( data ) {
				var count     = 0,
					lastValue = data[ 0 ],
					result    = []

				for( var i = 0, value, n = data.length; i < n; i++ ) {
					value = data[ i ]

					if( value != lastValue ) {
						result.push( count )
						result.push( lastValue )

						lastValue = value
						count = 1

					} else {
						count++
					}
				}

				if( count > 0 ) {
					result.push( count )
					result.push( lastValue )
				}

				return result
			},
			decode : function( data ) {
				var result = []

				for( var i = 0, count, value, n = data.length; i < n; i += 2 ) {
					count = data[ i ]
					value = data[ i + 1 ]

					for( var j = 0; j < count; j++ ) {
						result.push( value )
					}
				}

				return result
			}
		}
	}
)

define(
	'spell/shared/util/platform/private/graphics/createSplashScreenImage',
	[
		'spell/shared/util/platform/private/environment/isHtml5GameClosure',
		'spell/data/algorithm/RLE'
	],
	function(
		isHtml5GameClosure,
		RLE
	) {
		'use strict'


		var putDataRGBInImageData = function( imageData, dataRGB, numPixels ) {
			var data = imageData.data

			for( var i = 0, srcOffset, dstOffset, n = numPixels; i < n; i++ ) {
				srcOffset = i * 3
				dstOffset = i * 4

				data[ dstOffset ]     = dataRGB[ srcOffset ]
				data[ dstOffset + 1 ] = dataRGB[ srcOffset + 1 ]
				data[ dstOffset + 2 ] = dataRGB[ srcOffset + 2 ]
				data[ dstOffset + 3 ] = 255
			}
		}

		return function() {
			if( isHtml5GameClosure ) {
				return
			}

			// dataRLE is a run-length encoded uint8 array in RGB format containing the splash texture data.
			var dataRLE = [69369,0,3,19,3,21,18,0,3,19,3,21,738,0,3,38,3,42,18,0,3,38,3,42,738,0,3,38,3,42,18,0,3,38,3,42,588,0,3,38,3,32,3,28,3,39,3,31,3,4,6,0,3,1,3,25,3,38,3,39,3,26,3,1,3,0,3,31,3,42,3,12,3,0,3,38,3,42,3,37,3,0,3,13,3,42,3,30,3,0,3,1,3,25,3,38,3,39,3,26,3,2,3,0,3,38,3,32,3,29,3,42,3,0,3,1,3,25,3,38,3,39,3,26,3,2,6,0,3,25,3,39,3,31,3,39,3,42,18,0,3,38,3,42,3,27,3,39,3,31,3,3,3,0,3,38,3,42,3,4,3,0,3,21,3,42,3,20,552,0,3,38,3,42,6,25,3,42,3,27,6,0,3,23,3,42,3,25,3,24,3,42,3,23,3,0,3,22,3,42,3,18,3,5,3,42,3,34,3,42,3,4,3,19,3,42,3,21,3,0,3,22,3,42,3,20,3,19,3,42,3,24,3,0,3,38,3,42,3,38,3,36,3,0,3,22,3,42,3,20,3,19,3,42,3,24,3,0,3,22,3,42,3,29,3,24,3,41,3,42,18,0,3,38,3,42,3,24,3,26,3,42,3,26,3,0,3,22,3,42,3,16,3,0,3,30,3,42,3,7,552,0,3,38,3,42,6,0,3,41,3,36,6,0,3,35,3,41,6,0,3,41,3,35,3,0,3,13,3,42,3,23,3,14,3,42,3,17,3,42,3,13,3,25,3,42,3,12,3,0,3,35,3,40,6,0,3,40,3,35,3,0,3,38,3,42,9,0,3,35,3,40,6,0,3,40,3,35,3,0,3,34,3,42,3,1,3,0,3,38,3,42,18,0,3,38,3,42,3,0,3,2,3,42,3,35,3,0,3,5,3,42,3,28,3,0,3,40,3,36,555,0,3,38,3,42,6,0,3,39,3,40,6,0,3,40,3,39,6,0,3,39,3,40,3,0,3,3,3,42,3,28,3,23,3,40,3,2,3,41,3,22,3,30,3,42,3,2,3,0,3,40,3,42,9,39,3,38,3,0,3,38,3,42,9,0,3,40,3,42,9,39,3,38,3,0,3,40,3,39,6,0,3,38,3,42,18,0,3,38,3,42,6,0,3,39,3,40,6,0,3,30,3,39,3,9,3,42,3,23,555,0,3,38,3,42,3,0,3,1,3,42,3,34,6,0,3,35,3,42,6,1,3,42,3,35,6,0,3,36,3,33,3,31,3,32,3,0,3,34,3,29,6,35,6,0,3,34,3,40,3,1,12,0,3,38,3,42,9,0,3,34,3,40,3,1,12,0,3,35,3,41,6,0,3,38,3,42,18,0,3,38,3,42,3,0,3,2,3,42,3,34,6,0,3,13,3,42,3,29,3,42,3,10,555,0,3,38,3,42,3,20,3,26,3,42,3,23,6,0,3,23,3,42,6,26,3,42,3,23,6,0,3,27,6,38,3,24,3,0,3,25,3,37,3,40,3,26,6,0,3,22,3,42,3,33,3,24,3,30,3,19,3,0,3,38,3,42,9,0,3,22,3,42,3,33,3,24,3,30,3,19,3,0,3,25,3,42,3,27,3,24,3,41,3,42,18,0,3,38,3,42,3,16,3,27,3,42,3,22,9,0,3,38,3,42,3,38,558,0,3,38,6,42,3,39,3,27,3,1,6,0,3,1,3,26,6,39,3,26,3,1,6,0,3,18,6,42,3,15,3,0,3,16,6,42,3,17,9,0,3,24,3,38,3,40,3,35,3,15,3,0,3,38,3,42,12,0,3,24,3,38,3,40,3,35,3,15,3,0,3,3,3,30,3,39,3,31,3,33,3,42,18,0,3,27,3,35,3,40,3,39,3,25,12,0,3,22,3,42,3,25,558,0,3,38,3,42,195,0,3,20,3,42,3,12,558,0,3,38,3,42,189,0,3,22,3,24,3,39,3,38,3,1,558,0,3,38,3,42,189,0,3,25,3,39,3,34,3,12,1809,0,3,48,3,74,762,0,3,74,3,186,27,0,3,48,3,111,729,0,3,8,3,240,3,9,24,0,3,182,3,104,732,0,3,195,3,74,21,0,3,74,3,206,3,2,732,0,3,119,3,134,18,0,3,6,3,219,3,72,735,0,3,59,3,210,18,0,3,120,3,180,294,0,3,50,3,101,3,119,3,118,6,119,3,102,3,50,174,0,3,187,12,255,3,118,18,0,3,187,12,255,3,118,30,0,1,17,1,12,1,9,1,68,1,51,1,36,1,67,1,51,1,36,1,68,1,51,1,36,1,68,1,51,1,36,1,68,1,51,1,36,1,68,1,51,1,36,1,68,1,51,1,36,1,17,1,12,1,8,33,0,1,67,1,46,1,27,1,118,1,81,1,47,1,118,1,80,1,46,1,119,1,79,1,44,1,119,1,78,1,42,1,119,1,77,1,41,1,119,1,77,1,39,1,67,1,43,1,21,1,16,1,10,1,5,75,0,3,3,3,20,18,0,3,90,3,35,285,0,3,17,3,119,3,238,24,255,3,238,3,119,168,0,3,186,12,255,3,119,18,0,3,186,12,255,3,119,30,0,1,68,1,50,1,34,1,255,1,190,1,131,1,255,1,190,1,131,1,255,1,189,1,130,1,255,1,190,1,131,1,255,1,190,1,131,1,255,1,189,1,130,1,255,1,189,1,130,1,68,1,50,1,34,24,0,1,67,1,47,1,29,1,169,1,118,1,70,1,255,1,176,1,104,1,255,1,174,1,101,1,255,1,172,1,98,1,255,1,170,1,94,1,255,1,169,1,91,1,255,1,167,1,88,1,255,1,165,1,84,1,255,1,164,1,81,1,255,1,162,1,78,1,255,1,160,1,74,1,221,1,136,1,61,1,135,1,83,1,35,1,16,1,10,1,4,42,0,3,14,333,0,3,50,3,238,33,255,3,187,168,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,30,0,1,67,1,49,1,32,1,255,1,186,1,124,1,255,1,187,1,125,1,255,1,186,1,124,1,255,1,187,1,125,1,255,1,186,1,124,1,255,1,186,1,123,1,255,1,186,1,123,1,68,1,49,1,32,18,0,1,17,1,11,1,7,1,153,1,105,1,64,1,255,1,176,1,104,1,255,1,174,1,101,1,255,1,172,1,98,1,255,1,171,1,96,1,255,1,170,1,93,1,255,1,168,1,90,1,255,1,167,1,87,1,255,1,165,1,84,1,255,1,163,1,80,1,255,1,161,1,77,1,255,1,160,1,74,1,255,1,158,1,71,1,255,1,156,1,67,1,255,1,155,1,65,1,67,1,40,1,16,39,0,3,39,3,234,3,114,3,6,324,0,3,50,3,238,36,255,3,187,168,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,30,0,1,68,1,48,1,31,1,255,1,183,1,118,1,255,1,183,1,118,1,255,1,183,1,118,1,255,1,183,1,118,1,255,1,183,1,118,1,255,1,182,1,117,1,255,1,182,1,116,1,67,1,48,1,30,18,0,1,203,1,139,1,81,1,255,1,175,1,102,1,255,1,173,1,99,1,255,1,171,1,96,1,255,1,170,1,94,1,255,1,169,1,91,1,255,1,167,1,88,1,255,1,166,1,85,1,255,1,164,1,82,1,255,1,163,1,79,1,255,1,161,1,76,1,255,1,159,1,73,1,255,1,158,1,70,1,255,1,156,1,67,1,255,1,155,1,64,1,255,1,153,1,61,1,67,1,40,1,15,42,0,3,36,3,182,3,219,3,80,321,0,3,186,18,255,3,187,3,118,3,119,3,186,3,238,6,255,3,187,168,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,30,0,1,68,1,47,1,29,1,255,1,179,1,111,1,255,1,180,1,112,1,255,1,180,1,112,1,255,1,180,1,112,1,255,1,179,1,111,1,255,1,179,1,111,1,255,1,179,1,110,1,67,1,46,1,28,15,0,1,119,1,81,1,46,1,255,1,172,1,98,1,255,1,171,1,96,1,255,1,170,1,94,1,255,1,169,1,92,1,255,1,168,1,89,1,255,1,167,1,87,1,255,1,165,1,84,1,255,1,163,1,80,1,255,1,162,1,78,1,255,1,160,1,75,1,255,1,159,1,72,1,255,1,158,1,70,1,255,1,156,1,66,1,255,1,155,1,64,1,255,1,153,1,61,1,255,1,151,1,58,1,67,1,39,1,14,48,0,3,72,3,212,3,188,3,3,9,0,3,36,3,184,3,42,36,0,3,3,3,68,3,11,249,0,3,67,15,255,3,204,3,33,15,0,3,50,3,119,3,101,168,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,30,0,1,68,1,47,1,27,1,255,1,177,1,106,1,255,1,177,1,106,1,255,1,177,1,106,1,255,1,177,1,106,1,255,1,177,1,106,1,255,1,176,1,105,1,255,1,176,1,105,1,67,1,46,1,27,12,0,1,34,1,23,1,12,1,255,1,171,1,96,1,255,1,170,1,93,1,255,1,169,1,91,1,255,1,168,1,89,1,255,1,166,1,86,1,255,1,165,1,84,1,255,1,164,1,81,1,255,1,163,1,79,1,255,1,161,1,77,1,255,1,159,1,73,1,255,1,158,1,71,1,255,1,157,1,69,1,255,1,156,1,66,1,255,1,154,1,63,1,255,1,153,1,60,1,255,1,151,1,57,1,255,1,150,1,55,1,67,1,39,1,13,51,0,3,2,3,63,12,0,3,169,3,240,3,254,3,157,3,15,21,0,3,44,3,120,3,182,3,246,3,197,3,35,249,0,3,118,12,255,3,238,3,17,195,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,30,0,1,68,1,46,1,26,1,255,1,174,1,100,1,255,1,174,1,100,1,255,1,174,1,100,1,255,1,174,1,100,1,255,1,174,1,100,1,255,1,173,1,99,1,255,1,172,1,98,1,67,1,45,1,26,12,0,1,119,1,78,1,43,1,255,1,168,1,89,1,255,1,167,1,88,1,255,1,166,1,86,1,255,1,165,1,84,1,255,1,164,1,82,1,255,1,163,1,79,1,255,1,161,1,77,1,238,1,149,1,70,1,102,1,63,1,29,1,33,1,21,1,8,3,0,1,50,1,31,1,13,1,101,1,61,1,24,1,135,1,80,1,31,1,204,1,121,1,45,1,255,1,149,1,54,1,255,1,148,1,51,1,67,1,39,1,13,66,0,3,60,3,227,6,255,3,248,3,245,3,109,3,3,12,0,3,89,3,218,3,143,3,77,3,14,255,0,3,187,12,255,3,153,198,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,30,0,1,68,1,45,1,25,1,255,1,170,1,94,1,255,1,170,1,94,1,255,1,170,1,94,1,255,1,170,1,94,1,255,1,170,1,94,1,255,1,170,1,94,1,255,1,170,1,93,1,67,1,45,1,24,12,0,1,153,1,100,1,52,1,255,1,165,1,84,1,255,1,165,1,83,1,255,1,164,1,81,1,255,1,163,1,79,1,255,1,161,1,77,1,255,1,160,1,74,1,255,1,159,1,73,1,51,1,31,1,14,21,0,1,34,1,19,1,6,1,68,1,39,1,13,1,17,1,9,1,3,63,0,3,3,3,213,3,251,12,255,3,204,3,116,282,0,3,187,12,255,3,119,48,0,3,67,6,118,6,119,3,0,3,16,3,119,3,204,12,255,3,187,3,135,3,33,39,0,3,17,3,119,3,187,3,238,9,255,3,238,3,186,3,119,3,34,30,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,30,0,1,68,1,44,1,23,1,255,1,168,1,89,1,255,1,168,1,89,1,255,1,167,1,88,1,255,1,167,1,88,1,255,1,167,1,88,1,255,1,167,1,88,1,255,1,167,1,87,1,67,1,44,1,23,12,0,1,186,1,120,1,59,1,255,1,163,1,80,1,255,1,162,1,78,1,255,1,161,1,77,1,255,1,160,1,74,1,255,1,159,1,73,1,255,1,158,1,70,1,204,1,125,1,54,96,0,3,105,3,223,12,255,3,241,3,230,3,11,282,0,3,186,12,255,3,153,48,0,3,118,12,255,3,118,3,238,27,255,3,118,33,0,3,84,3,238,27,255,3,238,3,102,27,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,30,0,1,68,1,43,1,21,1,255,1,165,1,83,1,255,1,165,1,84,1,255,1,165,1,83,1,255,1,165,1,83,1,255,1,165,1,83,1,255,1,165,1,83,1,255,1,164,1,82,1,67,1,43,1,21,12,0,1,187,1,118,1,56,1,255,1,160,1,74,1,255,1,159,1,73,1,255,1,158,1,71,1,255,1,158,1,70,1,255,1,157,1,68,1,255,1,156,1,66,1,204,1,124,1,51,93,0,3,18,3,242,15,255,3,203,3,89,285,0,3,169,12,255,3,238,3,17,45,0,3,118,48,255,3,119,27,0,3,84,39,255,3,102,24,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,30,0,1,68,1,42,1,20,1,255,1,161,1,77,1,255,1,163,1,79,1,255,1,162,1,78,1,255,1,162,1,78,1,255,1,162,1,78,1,255,1,161,1,77,1,255,1,161,1,77,1,67,1,42,1,20,12,0,1,186,1,115,1,51,1,255,1,158,1,70,1,255,1,157,1,69,1,255,1,156,1,67,1,255,1,156,1,66,1,255,1,155,1,64,1,255,1,153,1,61,1,255,1,153,1,60,1,50,1,29,1,11,90,0,3,151,3,234,12,255,3,228,3,195,288,0,3,119,15,255,3,204,3,17,42,0,3,119,24,255,3,238,3,186,21,255,3,33,21,0,3,17,3,238,15,255,3,169,3,119,3,186,15,255,3,238,3,33,21,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,30,0,1,68,1,42,1,19,1,255,1,159,1,73,1,255,1,159,1,72,1,255,1,159,1,73,1,255,1,159,1,73,1,255,1,159,1,73,1,255,1,159,1,73,1,255,1,159,1,72,1,67,1,41,1,19,12,0,1,136,1,83,1,35,1,255,1,155,1,65,1,255,1,155,1,64,1,255,1,154,1,62,1,255,1,154,1,62,1,255,1,153,1,60,1,255,1,151,1,58,1,255,1,150,1,56,1,203,1,119,1,43,1,33,1,19,1,7,84,0,3,36,3,253,15,255,3,219,3,50,9,0,3,14,276,0,3,16,3,238,15,255,3,203,3,33,39,0,3,119,18,255,3,169,3,51,6,0,3,16,3,153,15,255,3,152,21,0,3,153,12,255,3,238,3,51,9,0,3,68,15,255,3,136,21,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,30,0,1,68,1,41,1,17,1,255,1,157,1,68,1,255,1,157,1,68,1,255,1,157,1,68,1,255,1,157,1,68,1,255,1,156,1,67,1,255,1,156,1,67,1,255,1,156,2,67,1,41,1,17,12,0,1,101,1,61,1,24,1,255,1,154,1,62,1,255,1,153,1,60,1,255,1,151,1,58,1,255,1,151,1,57,1,255,1,150,1,56,1,255,1,149,1,54,1,255,1,148,1,52,1,255,1,147,1,50,1,238,1,137,1,45,1,119,1,68,1,22,81,0,3,179,3,159,3,224,9,255,3,217,3,165,12,0,3,203,3,164,3,29,273,0,3,118,18,255,3,238,3,85,36,0,3,119,12,255,3,238,3,68,18,0,3,170,15,255,3,34,15,0,3,17,3,238,12,255,3,102,15,0,3,119,12,255,3,238,21,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,30,0,1,68,1,41,1,16,1,255,1,154,1,63,1,255,1,154,1,63,1,255,1,154,1,63,1,255,1,154,1,63,1,255,1,155,1,64,1,255,1,154,1,63,1,255,1,154,1,63,1,67,1,40,1,16,15,0,1,238,1,141,1,52,1,255,1,150,1,55,1,255,1,149,1,54,1,255,1,149,1,53,1,255,1,148,1,51,1,255,1,147,1,50,1,255,1,147,1,49,1,255,1,146,1,47,1,255,1,145,1,46,1,255,1,144,1,44,1,221,1,123,1,36,1,84,1,47,1,13,72,0,3,74,3,180,3,3,3,12,3,124,3,246,3,250,3,245,3,26,12,0,3,12,3,132,3,237,3,128,3,8,270,0,3,152,21,255,3,169,3,17,30,0,3,119,12,255,3,186,21,0,3,34,15,255,3,102,15,0,3,101,12,255,3,221,18,0,3,34,15,255,3,50,18,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,30,0,1,68,1,40,1,15,1,255,1,151,1,58,1,255,1,152,1,59,1,255,1,152,1,59,1,255,1,152,1,59,1,255,1,152,1,59,1,255,1,151,1,58,1,255,1,151,1,58,1,67,1,39,1,14,15,0,1,118,1,69,1,24,1,255,1,148,1,52,1,255,1,147,1,50,1,255,1,147,1,50,1,255,1,146,1,48,1,255,1,146,1,47,1,255,1,145,1,46,1,255,1,144,1,44,1,255,1,143,1,42,1,255,1,143,1,41,1,255,1,141,1,39,1,255,1,141,1,38,1,187,1,102,1,26,1,68,1,37,1,9,63,0,3,6,3,219,3,77,9,4,3,33,3,182,3,120,21,0,3,29,3,164,3,224,3,42,270,0,3,152,21,255,3,221,3,50,27,0,3,119,12,255,3,187,24,0,3,203,12,255,3,152,15,0,3,136,12,255,3,152,21,0,3,221,12,255,3,119,18,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,30,0,1,68,1,39,1,14,1,255,1,149,1,54,1,255,1,150,1,55,1,255,1,150,1,55,1,255,1,150,1,55,1,255,1,149,1,54,1,255,1,149,1,54,1,255,1,149,1,54,1,67,1,39,1,14,18,0,1,152,1,87,1,29,1,255,1,146,1,47,1,255,1,145,1,46,1,255,1,145,1,45,1,255,1,144,1,44,1,255,1,143,1,42,1,255,1,143,1,41,1,255,1,142,1,40,1,255,1,141,1,38,1,255,1,140,1,37,1,255,1,139,1,35,1,255,1,139,1,34,1,255,1,138,1,32,1,136,1,73,1,16,60,0,3,120,3,146,12,4,3,78,3,219,3,5,27,0,3,60,3,6,273,0,3,119,24,255,3,102,24,0,3,119,12,255,3,187,24,0,3,135,12,255,3,186,15,0,3,186,12,255,3,119,21,0,3,187,12,255,3,118,18,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,30,0,1,68,1,39,1,13,1,255,1,147,1,50,1,255,1,148,1,51,1,255,1,147,1,50,1,255,1,147,1,50,1,255,1,148,1,51,1,255,1,147,1,50,1,255,1,147,1,50,1,67,1,39,1,13,21,0,1,152,1,86,1,25,1,255,1,144,1,43,1,255,1,143,1,42,1,255,1,142,1,40,1,255,1,141,1,39,1,255,1,141,1,38,1,255,1,140,1,37,1,255,1,140,1,36,1,255,1,139,1,35,1,255,1,138,1,33,1,255,1,138,1,32,1,255,1,137,1,30,1,255,1,136,1,28,1,203,1,109,1,22,1,16,1,8,1,1,51,0,3,26,3,243,3,34,12,5,3,181,3,75,312,0,3,50,3,203,21,255,3,119,21,0,3,119,12,255,3,187,24,0,3,118,12,255,3,238,15,0,3,220,12,255,3,68,21,0,3,186,12,255,3,152,18,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,30,0,1,68,1,38,1,12,1,255,1,146,1,47,1,255,1,146,1,47,1,255,1,146,1,47,1,255,1,146,1,47,1,255,1,146,1,47,1,255,1,146,1,47,1,255,1,145,1,46,1,67,1,38,1,12,24,0,1,85,1,47,1,12,1,220,1,122,1,33,1,255,1,140,1,37,1,255,1,140,1,36,1,255,1,139,1,35,1,255,1,139,1,34,1,255,1,138,1,32,1,255,1,138,1,32,1,255,1,137,1,31,1,255,1,136,1,29,1,255,1,136,1,28,1,255,1,135,1,27,1,255,1,134,1,25,1,169,1,89,1,15,51,0,3,155,3,125,3,6,9,5,3,105,3,191,321,0,3,136,21,255,3,85,18,0,3,119,12,255,3,187,24,0,3,68,15,255,15,0,15,255,3,153,3,119,3,118,15,119,3,204,12,255,3,186,18,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,30,0,1,68,1,38,1,11,1,255,1,144,1,44,1,255,1,144,1,44,1,255,1,144,1,44,1,255,1,144,1,43,1,255,1,144,1,43,1,255,1,144,1,43,1,255,1,144,1,43,1,67,1,38,1,11,30,0,1,118,1,64,1,16,1,238,1,129,1,31,1,255,1,138,1,32,1,255,1,138,1,32,1,255,1,137,1,30,1,255,1,136,1,29,1,255,1,136,1,28,1,255,1,135,1,27,1,255,1,135,1,26,1,255,1,134,1,24,1,255,1,134,1,24,1,255,1,133,1,22,1,101,1,53,1,8,45,0,3,48,3,252,3,9,9,6,3,9,3,252,3,48,324,0,3,68,3,238,15,255,3,238,3,16,15,0,3,119,12,255,3,187,24,0,3,68,15,255,15,0,54,255,3,187,18,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,30,0,1,68,1,37,1,10,1,255,1,142,1,40,1,255,1,142,1,40,1,255,1,142,1,40,1,255,1,143,1,41,1,255,1,142,1,40,1,255,1,142,1,40,1,255,1,141,1,39,1,67,1,37,1,10,33,0,1,16,1,9,1,2,1,118,1,64,1,14,1,255,1,136,1,28,1,255,1,136,1,28,1,255,1,135,1,27,1,255,1,135,1,26,1,255,1,134,1,25,1,255,1,134,1,24,1,255,1,133,1,23,1,255,1,133,1,22,1,255,1,132,1,21,1,203,1,105,1,16,45,0,3,195,3,106,12,6,3,134,3,149,330,0,3,16,3,204,15,255,3,118,15,0,3,119,12,255,3,187,24,0,3,68,15,255,15,0,54,255,3,187,18,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,30,0,1,68,1,37,1,9,1,255,1,140,1,37,1,255,1,140,1,37,1,255,1,140,1,37,1,255,1,140,1,37,1,255,1,140,1,37,1,255,1,140,1,36,1,255,1,140,1,36,1,67,1,37,1,9,39,0,1,33,1,17,1,3,1,204,1,107,1,19,1,255,1,134,1,25,1,255,1,133,1,23,1,255,1,133,1,23,1,255,1,133,1,22,1,255,1,132,1,21,1,255,1,132,1,20,1,255,1,131,1,19,1,255,1,130,1,18,1,51,1,26,1,3,39,0,3,89,3,167,12,7,3,50,3,237,3,18,333,0,3,34,3,238,12,255,3,187,15,0,3,119,12,255,3,187,24,0,3,68,15,255,15,0,54,255,3,136,18,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,30,0,1,68,1,37,1,9,1,255,1,138,1,33,1,255,1,138,1,33,1,255,1,139,1,34,1,255,1,139,1,34,1,255,1,139,1,34,1,255,1,139,1,34,1,255,1,138,1,33,1,67,1,37,1,8,42,0,1,17,1,9,1,1,1,203,1,105,1,17,1,255,1,132,1,21,1,255,1,132,1,21,1,255,1,132,1,20,1,255,1,131,1,19,1,255,1,130,1,18,1,255,1,130,1,17,1,255,1,130,1,17,1,102,1,52,1,6,36,0,3,11,3,228,3,65,12,7,3,152,3,105,339,0,3,152,15,255,15,0,3,119,12,255,3,187,24,0,3,84,15,255,15,0,15,255,3,67,57,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,30,0,1,68,1,36,1,8,1,255,1,137,1,31,1,255,1,137,1,31,1,255,1,137,1,31,1,255,1,137,1,31,1,255,1,137,1,31,1,255,1,137,1,31,1,255,1,137,1,31,1,67,1,36,1,7,45,0,1,84,1,43,1,6,1,255,1,132,1,20,1,255,1,131,1,19,1,255,1,131,1,19,1,255,1,130,1,18,1,255,1,129,1,16,1,255,1,129,1,16,1,255,1,129,1,15,1,119,1,60,1,7,36,0,3,135,3,142,12,8,3,81,3,206,3,3,339,0,3,84,15,255,15,0,3,119,12,255,3,187,24,0,3,119,12,255,3,204,15,0,3,220,12,255,3,102,57,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,30,0,1,68,1,36,1,7,1,255,1,136,1,28,1,255,1,136,1,28,1,255,1,136,1,28,1,255,1,136,1,29,1,255,1,136,1,28,1,255,1,136,1,28,1,255,1,136,1,28,1,67,1,36,1,7,48,0,1,255,1,131,1,19,1,255,1,130,1,18,1,255,1,130,1,17,1,255,1,129,1,16,1,255,1,129,1,15,1,255,1,129,1,15,1,255,1,128,1,14,1,119,1,60,1,6,33,0,3,32,3,249,3,23,3,8,9,9,3,182,3,75,342,0,3,68,15,255,15,0,3,119,12,255,3,187,24,0,3,170,12,255,3,170,15,0,3,186,12,255,3,119,57,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,30,0,1,68,1,36,1,6,1,255,1,134,1,25,1,255,1,134,1,25,1,255,1,135,1,26,1,255,1,135,1,26,1,255,1,135,1,26,1,255,1,134,1,25,1,255,1,134,1,25,1,67,1,35,1,6,45,0,1,16,1,8,1,1,1,255,1,130,1,17,1,255,1,129,1,16,1,255,1,129,1,16,1,255,1,129,1,15,1,255,1,128,1,14,1,255,1,128,1,14,1,255,1,127,1,12,1,118,1,59,1,5,33,0,3,165,3,121,12,9,3,118,3,180,345,0,3,101,15,255,15,0,3,119,12,255,3,187,24,0,3,238,12,255,3,119,15,0,3,153,12,255,3,204,57,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,30,0,1,68,1,35,1,6,1,255,1,134,1,24,1,255,1,134,1,24,1,255,1,134,1,24,1,255,1,134,1,24,1,255,1,133,1,23,1,255,1,133,1,23,1,255,1,133,1,23,1,67,1,35,1,6,45,0,1,101,1,51,1,5,1,255,1,129,1,15,1,255,1,129,1,15,1,255,1,128,1,14,1,255,1,128,1,14,1,255,1,128,1,13,1,255,1,128,1,13,1,255,1,127,1,11,1,118,1,59,1,5,30,0,3,60,3,197,3,9,9,10,3,24,3,249,3,35,345,0,3,187,12,255,3,204,15,0,3,119,12,255,3,187,21,0,3,101,15,255,3,34,15,0,3,102,15,255,3,67,54,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,12,0,1,119,1,61,1,9,1,101,1,52,1,8,1,34,1,17,1,2,9,0,1,101,1,52,1,8,1,255,1,133,1,22,1,255,1,133,1,22,1,255,1,132,1,21,1,255,1,133,1,22,1,255,1,133,1,22,1,255,1,132,1,21,1,255,1,132,1,21,1,67,1,34,1,5,12,0,1,119,1,61,1,9,1,255,1,132,1,20,1,170,1,87,1,12,1,118,1,60,1,8,1,33,1,17,1,2,15,0,1,67,1,34,1,3,1,238,1,119,1,13,1,255,1,128,1,14,1,255,1,128,1,13,1,255,1,128,1,13,1,255,1,127,1,12,1,255,1,127,1,12,1,255,1,127,1,11,1,255,1,126,1,10,1,67,1,33,1,2,27,0,3,3,3,206,3,97,12,10,3,142,3,134,345,0,3,101,15,255,3,152,15,0,3,119,12,255,3,187,18,0,3,17,3,220,12,255,3,204,18,0,3,16,15,255,3,203,3,16,24,0,3,67,3,33,21,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,12,0,1,255,1,130,1,18,1,255,1,131,1,19,1,255,1,131,1,19,1,221,1,113,1,16,1,169,1,87,1,12,1,152,1,78,1,11,1,255,1,131,1,19,1,255,1,131,1,19,1,255,1,131,1,19,1,255,1,132,1,20,1,255,1,132,1,20,1,255,1,131,1,19,1,255,1,131,1,19,1,255,1,131,1,19,1,51,1,26,1,3,12,0,1,119,1,60,1,8,1,255,1,130,1,17,1,255,1,130,1,17,1,255,1,130,1,17,1,255,1,129,1,16,1,238,1,120,1,15,1,187,1,94,1,11,1,119,1,60,1,6,1,135,1,68,1,7,1,204,1,102,1,11,1,255,1,128,1,14,1,255,1,128,1,14,1,255,1,127,1,12,1,255,1,127,1,12,1,255,1,127,1,11,1,255,1,127,1,11,1,255,1,127,1,11,1,255,1,126,1,10,1,238,1,118,1,8,30,0,3,105,3,154,12,11,3,62,3,227,3,11,315,0,3,119,3,255,3,220,3,152,3,101,3,67,6,0,3,67,3,153,18,255,3,84,15,0,3,119,12,255,3,203,3,34,12,0,3,34,3,203,15,255,3,85,21,0,3,152,15,255,3,221,3,101,3,16,3,0,3,33,3,67,3,118,3,170,3,238,3,255,3,119,21,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,12,0,1,255,1,129,1,16,1,255,1,130,1,17,1,255,1,130,1,17,1,255,1,130,1,18,1,255,1,130,1,18,1,255,1,130,1,17,1,255,1,130,1,18,1,255,1,130,1,18,1,255,1,130,1,18,1,255,1,130,1,17,1,255,1,130,1,18,1,255,1,130,1,18,1,255,1,130,1,18,1,255,1,130,1,18,15,0,1,119,1,60,1,7,1,255,1,129,1,16,1,255,1,129,1,15,1,255,1,129,1,15,1,255,1,129,1,15,1,255,1,128,1,14,1,255,1,128,1,14,1,255,1,128,1,13,1,255,1,128,1,14,1,255,1,128,1,13,1,255,1,127,1,12,1,255,1,127,1,12,1,255,1,127,1,11,1,255,1,127,1,11,1,255,1,126,1,10,1,255,1,126,1,10,1,255,1,126,1,9,1,255,1,126,1,9,1,119,1,58,1,3,27,0,3,18,3,237,3,54,12,11,3,163,3,95,318,0,3,119,42,255,3,204,18,0,3,119,18,255,3,203,3,153,3,119,3,186,18,255,3,169,24,0,3,34,3,238,42,255,3,118,21,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,12,0,1,255,1,129,1,15,1,255,1,129,1,15,1,255,1,129,1,16,1,255,1,129,1,15,1,255,1,129,1,15,1,255,1,129,1,16,1,255,1,129,1,16,1,255,1,129,1,16,1,255,1,129,1,16,1,255,1,129,1,16,1,255,1,129,1,16,1,255,1,129,1,16,1,255,1,129,1,15,1,152,1,77,1,8,15,0,1,119,1,60,1,6,1,255,1,128,1,14,1,255,1,128,1,14,1,255,1,128,1,13,1,255,1,128,1,13,1,255,1,128,1,13,1,255,1,128,1,13,1,255,1,127,1,12,1,255,1,127,1,12,1,255,1,127,1,12,1,255,1,127,1,11,1,255,1,127,1,11,1,255,1,127,1,11,1,255,1,126,1,10,1,255,1,126,1,9,1,255,1,126,1,9,1,255,1,126,1,9,1,204,1,99,1,5,1,17,1,8,28,0,3,150,3,138,3,11,9,12,3,98,3,206,3,3,318,0,3,119,39,255,3,238,3,51,18,0,3,119,45,255,3,204,3,16,27,0,3,101,42,255,3,119,21,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,12,0,1,255,1,128,1,13,1,255,1,128,1,14,1,255,1,128,1,14,1,255,1,128,1,14,1,255,1,128,1,14,1,255,1,128,1,14,1,255,1,128,1,14,1,255,1,128,1,14,1,255,1,128,1,14,1,255,1,129,1,15,1,255,1,129,1,15,1,255,1,129,1,15,1,238,1,119,1,13,1,34,1,17,1,1,15,0,1,119,1,59,1,6,1,255,1,128,1,13,1,255,1,128,1,13,1,255,1,128,1,13,1,255,1,128,1,13,1,255,1,127,1,12,1,255,1,127,1,12,1,255,1,127,1,11,1,255,1,127,1,11,1,255,1,126,1,10,1,255,1,126,1,10,1,255,1,126,1,10,1,255,1,126,1,9,1,255,1,126,1,9,1,255,1,125,1,8,1,255,1,125,1,8,1,221,1,108,1,6,1,51,1,25,1,1,27,0,3,36,3,249,3,18,12,12,3,198,3,59,321,0,3,119,36,255,3,187,3,51,21,0,3,119,42,255,3,136,36,0,3,84,3,238,36,255,3,118,21,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,12,0,1,255,1,127,1,12,1,255,1,127,1,12,1,255,1,127,1,12,1,255,1,128,1,13,1,255,1,128,1,13,1,255,1,128,1,13,1,255,1,128,1,13,1,255,1,128,1,13,1,255,1,128,1,13,1,255,1,128,1,13,1,255,1,128,1,13,1,238,1,119,1,12,1,51,1,25,1,2,18,0,1,119,1,59,1,5,1,255,1,127,1,12,1,255,1,127,1,12,1,255,1,127,1,11,1,255,1,127,1,11,1,255,1,127,1,11,1,255,1,127,1,11,1,255,1,126,1,10,1,255,1,126,1,10,1,255,1,126,1,9,1,255,1,126,1,9,1,255,1,126,1,9,1,255,1,126,1,9,1,255,1,125,1,8,1,255,1,125,1,8,1,152,1,74,1,3,1,16,1,7,31,0,3,179,3,121,6,12,3,13,3,12,3,129,3,165,324,0,3,16,3,102,3,136,3,186,3,238,12,255,3,238,3,186,3,135,3,68,27,0,3,119,12,255,3,221,3,152,3,221,12,255,3,187,3,136,3,33,42,0,3,16,3,101,3,170,3,203,15,255,3,204,3,170,3,119,3,50,24,0,3,102,3,118,3,119,6,118,3,68,18,0,3,102,3,118,3,119,6,118,3,68,12,0,1,50,1,25,1,2,1,118,1,58,1,4,1,169,1,84,1,7,1,203,1,101,1,9,1,255,1,127,1,11,1,255,1,127,1,12,1,255,1,127,1,12,1,255,1,127,1,12,1,238,1,119,1,11,1,186,1,93,1,8,1,119,1,59,1,5,1,17,1,8,25,0,1,51,1,25,1,2,1,118,1,59,1,5,1,153,1,75,1,5,1,186,1,92,1,7,1,221,1,109,1,8,1,255,1,126,1,9,1,255,1,126,1,9,1,255,1,126,1,9,1,255,1,126,1,9,1,255,1,125,1,8,1,204,1,99,1,5,1,170,1,83,1,4,1,119,1,58,1,2,1,34,1,16,34,0,3,74,3,183,12,13,3,41,3,243,3,27,390,0,3,119,12,255,3,186,333,0,3,215,3,116,12,13,3,147,3,120,393,0,3,119,12,255,3,187,333,0,3,42,3,182,3,187,3,87,3,14,3,70,3,227,3,8,393,0,3,119,12,255,3,187,339,0,3,71,3,219,3,151,3,169,3,90,396,0,3,119,12,255,3,187,342,0,3,6,3,113,3,180,399,0,3,119,12,255,3,187,750,0,3,119,12,255,3,187,750,0,3,119,12,255,3,187,750,0,3,119,12,255,3,187,49791,0,3,4,18,112,3,14,3,17,3,14,15,0,3,84,3,78,96,0,3,71,3,60,3,0,3,84,3,78,57,0,3,84,3,78,60,0,3,84,3,78,33,0,3,17,3,14,36,0,3,84,3,78,6,0,3,71,3,60,60,0,3,84,3,78,21,0,3,17,3,14,84,0,3,71,3,60,3,0,3,71,3,60,192,0,3,2,6,62,3,104,3,112,6,62,3,2,3,112,3,94,15,0,3,78,3,74,96,0,3,112,3,94,3,0,3,78,3,74,42,0,3,42,3,86,9,0,3,78,3,74,60,0,3,78,3,74,33,0,3,112,3,94,36,0,3,78,3,74,6,0,3,112,3,94,3,0,3,42,3,86,51,0,3,78,3,74,6,0,3,42,3,86,9,0,3,112,3,94,24,0,3,12,3,82,3,107,3,101,3,52,45,0,3,112,3,94,3,0,3,112,3,94,6,0,3,112,3,94,3,12,3,82,3,107,3,101,3,52,174,0,3,94,3,112,9,0,3,112,3,94,15,0,3,38,3,36,96,0,3,112,3,94,3,0,3,38,3,36,42,0,3,89,3,112,9,0,3,38,3,36,60,0,3,38,3,36,33,0,3,112,3,94,36,0,3,38,3,36,6,0,3,112,3,94,3,0,3,89,3,112,51,0,3,38,3,36,6,0,3,89,3,112,9,0,3,112,3,94,24,0,3,75,3,112,3,57,3,51,3,41,45,0,3,112,3,94,3,0,3,112,3,94,6,0,3,112,3,94,3,75,3,112,3,57,3,51,3,41,174,0,3,94,3,112,9,0,3,112,3,99,3,64,3,99,3,101,3,36,3,0,3,112,3,106,3,0,3,29,3,85,3,105,3,103,3,75,12,0,3,15,3,86,3,101,3,109,3,95,3,32,6,0,3,112,3,82,3,86,3,107,3,82,3,8,3,0,3,112,3,82,3,86,3,107,3,82,3,8,3,0,3,112,3,94,3,0,3,112,3,106,6,0,3,6,3,73,6,105,3,54,3,86,3,101,3,109,3,95,3,32,3,0,3,101,9,112,3,37,3,0,3,112,3,106,3,0,3,3,3,68,3,104,3,107,3,79,3,10,6,0,3,112,3,84,3,65,3,99,3,102,3,37,15,0,3,112,3,106,3,0,3,29,3,85,3,105,3,103,3,75,15,0,3,112,3,103,3,85,3,107,3,82,3,8,3,0,3,112,3,94,3,0,3,94,3,112,6,0,3,112,3,106,6,0,3,112,3,94,3,101,9,112,3,37,12,0,3,86,3,109,3,0,3,57,3,112,3,104,3,0,3,63,3,112,3,20,3,0,3,112,3,106,3,0,3,101,9,112,3,37,3,0,3,112,3,99,3,64,3,99,3,101,3,36,12,0,3,83,3,112,3,20,12,0,3,112,3,82,3,86,3,107,3,82,3,8,3,0,3,17,3,83,3,107,3,100,3,49,3,0,3,112,3,94,3,0,3,112,3,94,6,0,3,112,3,94,3,83,3,112,3,20,180,0,3,94,3,112,9,0,3,112,3,108,3,68,3,54,3,112,3,87,3,0,3,112,3,106,3,0,3,86,3,112,3,48,3,34,3,29,12,0,3,13,3,55,3,45,3,49,3,112,3,87,6,0,3,112,3,103,3,39,3,56,3,112,3,64,3,0,3,112,3,103,3,39,3,56,3,112,3,64,3,0,3,112,3,94,3,0,3,112,3,106,6,0,3,71,3,112,3,60,3,40,3,36,3,55,3,45,3,49,3,112,3,87,3,0,3,12,3,96,3,112,3,13,3,3,3,0,3,112,3,106,3,0,3,57,3,112,3,56,3,41,3,112,3,76,6,0,3,112,3,107,3,62,3,54,3,112,3,88,15,0,3,112,3,106,3,0,3,86,3,112,3,48,3,34,3,29,15,0,3,112,3,103,3,36,3,56,3,112,3,64,3,0,3,112,3,94,3,0,3,94,3,112,6,0,3,112,3,106,6,0,3,112,3,94,3,12,3,96,3,112,3,13,3,3,12,0,3,61,3,112,3,13,3,83,3,86,3,112,3,16,3,79,3,107,3,1,3,0,3,112,3,106,3,0,3,12,3,96,3,112,3,13,3,3,3,0,3,112,3,108,3,68,3,54,3,112,3,87,12,0,3,36,3,110,3,106,3,51,9,0,3,112,3,103,3,39,3,56,3,112,3,64,3,0,3,86,3,109,3,23,3,61,3,112,3,17,3,112,3,94,3,0,3,112,3,94,6,0,3,112,3,94,3,36,3,110,3,106,3,51,177,0,3,94,3,112,9,0,3,112,3,94,6,0,3,112,3,94,3,0,3,112,3,106,3,0,3,70,3,112,3,103,3,62,3,7,12,0,3,19,3,87,3,109,6,112,3,94,6,0,3,112,3,94,3,0,3,4,3,112,3,86,3,0,3,112,3,94,3,0,3,4,3,112,3,86,3,0,3,112,3,94,3,0,3,112,3,106,6,0,3,100,3,101,6,0,3,19,3,87,3,109,6,112,3,94,6,0,3,94,3,112,9,0,3,112,3,106,3,0,3,84,3,112,3,4,3,0,3,99,3,102,6,0,3,112,3,94,6,0,3,112,3,94,15,0,3,112,3,106,3,0,3,70,3,112,3,103,3,62,3,7,15,0,3,112,3,94,3,0,3,10,3,112,3,86,3,0,3,112,3,94,3,0,3,94,3,112,6,0,3,112,3,106,6,0,3,112,3,94,3,0,3,94,3,112,18,0,3,37,3,112,3,29,3,106,3,44,3,108,3,41,3,95,3,83,6,0,3,112,3,106,6,0,3,94,3,112,9,0,3,112,3,94,6,0,3,112,3,94,15,0,3,22,3,84,3,112,3,68,6,0,3,112,3,94,3,0,3,4,3,112,3,86,3,0,3,107,3,109,3,94,3,99,3,112,3,35,3,112,3,94,3,0,3,112,3,94,6,0,3,112,3,94,3,0,3,22,3,84,3,112,3,68,174,0,3,94,3,112,9,0,3,112,3,94,6,0,3,112,3,94,3,0,3,112,3,106,3,0,3,2,3,50,3,96,3,112,3,77,12,0,3,80,3,112,3,32,3,2,3,112,3,94,6,0,3,112,3,94,3,0,3,6,3,112,3,82,3,0,3,112,3,94,3,0,3,6,3,112,3,82,3,0,3,112,3,94,3,0,3,112,3,106,6,0,3,103,3,100,6,0,3,80,3,112,3,32,3,2,3,112,3,94,6,0,3,94,3,112,9,0,3,112,3,106,3,0,3,84,3,112,3,5,3,0,3,100,3,101,6,0,3,112,3,94,6,0,3,112,3,94,15,0,3,112,3,106,3,0,3,2,3,50,3,96,3,112,3,77,15,0,3,112,3,94,3,0,3,6,3,112,3,82,3,0,3,112,3,94,3,0,3,94,3,112,6,0,3,112,3,106,6,0,3,112,3,94,3,0,3,94,3,112,18,0,3,13,3,112,3,59,3,112,3,19,3,89,3,62,3,108,3,59,6,0,3,112,3,106,6,0,3,94,3,112,9,0,3,112,3,94,6,0,3,112,3,94,18,0,3,2,3,105,3,106,6,0,3,112,3,94,3,0,3,6,3,112,3,82,3,0,3,95,3,102,12,0,3,112,3,94,3,0,3,112,3,94,6,0,3,112,3,94,6,0,3,2,3,105,3,106,174,0,3,94,3,112,9,0,3,112,3,94,6,0,3,112,3,94,3,0,3,112,3,106,3,0,3,30,3,36,3,47,3,112,3,83,12,0,3,84,3,112,3,45,3,46,3,112,3,94,6,0,3,112,3,100,3,30,3,62,3,112,3,57,3,0,3,112,3,100,3,30,3,62,3,112,3,57,3,0,3,112,3,94,3,0,3,112,3,106,6,0,3,79,3,112,3,60,3,44,3,110,3,112,3,45,3,46,3,112,3,94,6,0,3,89,3,112,3,43,3,28,3,0,3,112,3,106,3,0,3,58,3,112,3,59,3,46,3,112,3,75,6,0,3,112,3,94,6,0,3,112,3,94,15,0,3,112,3,106,3,0,3,30,3,36,3,47,3,112,3,83,15,0,3,112,3,98,3,21,3,64,3,112,3,55,3,0,3,107,3,106,3,53,3,107,3,112,6,0,3,112,3,106,6,0,3,112,3,94,3,0,3,89,3,112,3,43,3,28,15,0,3,101,3,91,3,107,3,1,3,65,3,91,3,112,3,34,6,0,3,112,3,106,6,0,3,89,3,112,3,43,3,28,3,0,3,112,3,94,6,0,3,112,3,94,12,0,3,59,3,53,3,55,3,112,3,92,6,0,3,112,3,100,3,30,3,62,3,112,3,57,3,0,3,67,3,112,3,63,3,43,3,60,3,0,3,112,3,94,3,0,3,112,3,94,3,43,3,49,3,112,3,87,3,59,3,53,3,55,3,112,3,92,6,0,3,74,3,89,3,1,159,0,3,94,3,112,9,0,3,112,3,94,6,0,3,112,3,94,3,0,3,112,3,106,3,0,3,71,3,100,3,109,3,93,3,26,12,0,3,30,3,100,3,103,3,76,3,103,3,94,6,0,9,112,3,105,3,69,3,3,3,0,9,112,3,105,3,69,3,3,3,0,3,112,3,94,3,0,3,112,3,106,6,0,3,13,3,83,3,108,3,100,3,68,3,100,3,103,3,76,3,103,3,94,6,0,3,43,3,98,3,102,3,45,3,0,3,112,3,106,3,0,3,3,3,70,3,105,3,107,3,79,3,10,6,0,3,112,3,94,6,0,3,112,3,94,15,0,3,112,3,106,3,0,3,71,3,100,3,109,3,93,3,26,15,0,3,86,3,97,3,108,3,104,3,66,3,2,3,0,3,53,3,106,3,89,3,86,3,112,6,0,3,112,3,106,6,0,3,112,3,94,3,0,3,43,3,98,3,102,3,45,15,0,3,76,3,112,3,86,3,0,3,41,6,112,3,10,6,0,3,112,3,106,6,0,3,43,3,98,3,102,3,45,3,0,3,112,3,94,6,0,3,112,3,94,12,0,3,75,3,103,3,109,3,90,3,24,6,0,9,112,3,105,3,69,3,3,3,0,3,6,3,74,6,106,3,85,3,0,3,112,3,94,3,0,3,112,3,94,3,70,3,107,3,100,3,35,3,75,3,103,3,109,3,90,3,24,6,0,3,89,3,102,3,4,255,0,3,112,3,94,15,0,3,112,3,94,390,0,3,112,3,94,81,0,3,1,3,4,258,0,3,112,3,94,15,0,3,112,3,94,390,0,3,112,3,94,4071,0,3,112,3,94,12,0,3,84,3,78,102,0,3,14,3,17,309,0,3,84,3,78,27,0,3,71,3,60,123,0,3,71,3,60,159,0,3,112,3,94,12,0,3,78,3,74,102,0,3,94,3,112,18,0,3,47,3,93,3,97,3,93,279,0,3,78,3,74,27,0,3,112,3,94,123,0,3,112,3,94,159,0,3,112,3,94,12,0,3,38,3,36,102,0,3,94,3,112,18,0,3,106,3,103,285,0,3,38,3,36,27,0,3,112,3,94,123,0,3,112,3,94,159,0,3,112,3,94,12,0,3,112,3,106,6,0,3,6,3,73,6,105,3,39,3,17,3,83,3,107,3,100,3,49,3,0,3,112,3,84,3,65,3,99,3,102,3,37,3,29,3,85,3,105,3,103,3,75,3,0,3,17,3,83,3,107,3,100,3,49,3,0,3,14,3,87,3,101,3,105,3,112,12,0,3,6,12,112,3,46,3,68,3,104,3,107,3,79,3,10,6,0,3,112,3,83,3,93,3,64,15,0,3,112,3,84,3,65,3,99,3,102,3,37,3,3,3,68,3,104,3,107,3,79,3,10,6,0,3,112,3,84,3,65,3,99,3,102,3,37,21,0,3,6,3,73,6,105,3,42,3,68,3,104,3,107,3,79,3,10,6,0,3,112,6,85,3,103,3,52,3,63,3,100,3,102,3,37,6,0,3,112,6,85,3,103,3,52,3,63,3,100,3,102,3,37,6,0,3,17,3,83,3,107,3,100,3,49,3,0,3,112,3,83,3,93,3,64,3,0,3,6,3,73,6,105,3,39,3,112,3,106,3,0,3,15,3,86,3,101,3,109,3,95,3,32,6,0,3,112,3,94,15,0,3,112,3,94,3,0,3,94,3,112,3,0,3,29,3,85,3,105,3,103,3,75,3,0,3,17,3,83,3,107,3,100,3,49,12,0,3,3,3,68,3,104,3,107,3,79,3,10,6,0,3,112,3,84,3,65,3,99,3,102,3,37,3,0,3,112,3,96,3,99,3,95,3,0,3,19,3,112,3,59,141,0,3,112,3,94,12,0,3,112,3,106,6,0,3,71,3,112,3,60,3,40,3,23,3,86,3,109,3,23,3,61,3,112,3,17,3,112,3,107,3,62,3,54,3,112,3,88,3,86,3,112,3,48,3,34,3,29,3,0,3,86,3,109,3,23,3,61,3,112,3,17,3,78,3,112,3,46,3,103,3,112,15,0,3,13,3,112,3,99,3,13,3,62,3,112,3,56,3,41,3,112,3,76,6,0,3,112,3,107,3,68,3,40,15,0,3,112,3,107,3,62,3,54,3,112,3,88,3,57,3,112,3,56,3,41,3,112,3,76,6,0,3,112,3,107,3,62,3,54,3,112,3,88,3,18,12,112,3,59,3,0,3,71,3,112,3,60,3,40,3,81,3,112,3,56,3,41,3,112,3,76,6,0,3,112,3,107,3,55,3,105,3,112,3,67,3,53,3,112,3,87,6,0,3,112,3,107,3,55,3,105,3,112,3,67,3,53,3,112,3,87,6,0,3,86,3,109,3,23,3,61,3,112,3,17,3,112,3,107,3,68,3,40,3,0,3,71,3,112,3,60,3,40,3,23,3,112,3,106,3,0,3,13,3,55,3,45,3,49,3,112,3,87,6,0,3,112,3,94,15,0,3,112,3,94,3,0,3,94,3,112,3,0,3,86,3,112,3,48,3,34,3,29,3,0,3,86,3,109,3,23,3,61,3,112,3,17,9,0,3,57,3,112,3,56,3,41,3,112,3,76,6,0,3,112,3,107,3,62,3,54,3,112,3,88,3,0,3,112,3,94,3,53,3,112,3,17,3,48,3,112,3,21,141,0,3,112,3,94,12,0,3,112,3,106,6,0,3,100,3,101,9,0,3,107,3,109,3,94,3,99,3,112,3,35,3,112,3,94,6,0,3,112,3,94,3,70,3,112,3,103,3,62,3,7,3,0,3,107,3,109,3,94,3,99,3,112,3,35,3,102,3,103,3,0,3,94,3,112,18,0,3,112,3,97,3,0,3,84,3,112,3,4,3,0,3,99,3,102,6,0,3,112,3,94,21,0,3,112,3,94,6,0,3,112,3,94,3,84,3,112,3,4,3,0,3,99,3,102,6,0,3,112,3,94,6,0,3,112,3,94,3,16,12,94,3,50,3,0,3,100,3,101,6,0,3,84,3,112,3,4,3,0,3,99,3,102,6,0,3,112,3,94,3,0,3,94,3,112,6,0,3,112,3,94,6,0,3,112,3,94,3,0,3,94,3,112,6,0,3,112,3,94,6,0,3,107,3,109,3,94,3,99,3,112,3,35,3,112,3,94,9,0,3,100,3,101,9,0,3,112,3,106,3,0,3,19,3,87,3,109,6,112,3,94,6,0,3,112,3,94,15,0,3,112,3,94,3,0,3,94,3,112,3,0,3,70,3,112,3,103,3,62,3,7,3,0,3,107,3,109,3,94,3,99,3,112,3,35,9,0,3,84,3,112,3,4,3,0,3,99,3,102,6,0,3,112,3,94,6,0,3,112,3,94,3,0,3,112,3,94,3,8,3,107,3,51,3,77,3,97,144,0,3,112,3,94,12,0,3,112,3,106,6,0,3,103,3,100,9,0,3,95,3,102,12,0,3,112,3,94,6,0,3,112,3,94,3,2,3,50,3,96,3,112,3,77,3,0,3,95,3,102,12,0,3,104,3,101,3,0,3,94,3,112,18,0,3,112,3,97,3,0,3,84,3,112,3,5,3,0,3,100,3,101,6,0,3,112,3,94,21,0,3,112,3,94,6,0,3,112,3,94,3,84,3,112,3,5,3,0,3,100,3,101,6,0,3,112,3,94,6,0,3,112,3,94,21,0,3,103,3,100,6,0,3,84,3,112,3,5,3,0,3,100,3,101,6,0,3,112,3,94,3,0,3,94,3,112,6,0,3,112,3,94,6,0,3,112,3,94,3,0,3,94,3,112,6,0,3,112,3,94,6,0,3,95,3,102,12,0,3,112,3,94,9,0,3,103,3,100,9,0,3,112,3,106,3,0,3,80,3,112,3,32,3,2,3,112,3,94,6,0,3,112,3,94,15,0,3,112,3,94,3,0,3,94,3,112,3,0,3,2,3,50,3,96,3,112,3,77,3,0,3,95,3,102,21,0,3,84,3,112,3,5,3,0,3,100,3,101,6,0,3,112,3,94,6,0,3,112,3,94,3,0,3,112,3,94,3,0,3,67,3,87,3,105,3,59,144,0,3,112,3,104,6,60,3,35,3,0,3,112,3,106,6,0,3,79,3,112,3,60,3,44,3,25,3,67,3,112,3,63,3,43,3,60,3,0,3,112,3,94,6,0,3,112,3,94,3,30,3,36,3,47,3,112,3,83,3,0,3,67,3,112,3,63,3,43,3,60,3,0,3,83,3,112,3,43,3,104,3,112,18,0,3,112,3,97,3,0,3,58,3,112,3,59,3,46,3,112,3,75,6,0,3,112,3,94,21,0,3,112,3,94,6,0,3,112,3,94,3,58,3,112,3,59,3,46,3,112,3,75,6,0,3,112,3,94,6,0,3,112,3,94,21,0,3,79,3,112,3,60,3,44,3,84,3,112,3,59,3,46,3,112,3,75,6,0,3,112,3,94,3,0,3,94,3,112,6,0,3,112,3,94,6,0,3,112,3,94,3,0,3,94,3,112,6,0,3,112,3,94,6,0,3,67,3,112,3,63,3,43,3,60,3,0,3,112,3,94,9,0,3,79,3,112,3,60,3,44,3,25,3,112,3,106,3,0,3,84,3,112,3,45,3,46,3,112,3,94,6,0,3,112,3,94,15,0,3,107,3,106,3,53,3,107,3,112,3,0,3,30,3,36,3,47,3,112,3,83,3,0,3,67,3,112,3,63,3,43,3,60,12,0,3,58,3,112,3,59,3,46,3,112,3,75,6,0,3,112,3,94,6,0,3,112,3,94,3,0,3,112,3,94,3,0,3,19,6,112,3,21,6,0,3,74,3,89,3,1,129,0,12,112,3,54,3,0,3,112,3,106,6,0,3,13,3,83,3,108,3,100,3,37,3,6,3,74,6,106,3,85,3,0,3,112,3,94,6,0,3,112,3,94,3,71,3,100,3,109,3,93,3,26,3,0,3,6,3,74,6,106,3,85,3,0,3,21,3,94,3,102,3,93,3,112,18,0,3,112,3,97,3,0,3,3,3,70,3,105,3,107,3,79,3,10,6,0,3,112,3,94,21,0,3,112,3,94,6,0,3,112,3,94,3,3,3,70,3,105,3,107,3,79,3,10,6,0,3,112,3,94,6,0,3,112,3,94,21,0,3,13,3,83,3,108,3,100,3,41,3,70,3,105,3,107,3,79,3,10,6,0,3,112,3,94,3,0,3,94,3,112,6,0,3,112,3,94,6,0,3,112,3,94,3,0,3,94,3,112,6,0,3,112,3,94,6,0,3,6,3,74,6,106,3,85,3,0,3,112,3,94,9,0,3,13,3,83,3,108,3,100,3,37,3,112,3,106,3,0,3,30,3,100,3,103,3,76,3,103,3,94,6,0,3,112,3,94,15,0,3,53,3,106,3,89,3,86,3,112,3,0,3,71,3,100,3,109,3,93,3,26,3,0,3,6,3,74,6,106,3,85,12,0,3,3,3,70,3,105,3,107,3,79,3,10,6,0,3,112,3,94,6,0,3,112,3,94,3,0,3,112,3,94,6,0,3,90,3,96,9,0,3,89,3,102,3,4,738,0,3,37,3,45,3,110,3,58,9,0,3,1,3,4,741,0,3,76,3,106,3,82,3,8,10833,0],
				dataRGB = RLE.decode( dataRLE ),
				size    = 256

			var canvas = document.createElement( 'canvas' )

			canvas.width = size
			canvas.height = size

			var context   = canvas.getContext( '2d' ),
				imageData = context.createImageData( size, size )

			putDataRGBInImageData( imageData, dataRGB, size * size )
			context.putImageData( imageData, 0, 0 )

			return canvas
		}
	}
)

define(
	'spell/shared/util/platform/private/getAvailableScreenSize',
    [
		'spell/shared/util/platform/private/environment/isHtml5GameClosure',
        'spell/shared/util/platform/private/environment/isHtml5Ejecta',
	    'spell/shared/util/platform/private/environment/isHtml5Tizen',
		'spell/shared/util/platform/private/environment/isHtml5WinPhone'
    ],
	function(
		isHtml5GameClosure,
        isHtml5Ejecta,
	    isHtml5Tizen,
		isHtml5WinPhone
    ) {
		'use strict'


		var getOffset = function( element ) {
            if( !element.getBoundingClientRect ) {
                return [ 0, 0 ]
            }

			var box = element.getBoundingClientRect()

			var body    = document.body
			var docElem = document.documentElement

			var scrollTop  = window.pageYOffset || docElem.scrollTop || body.scrollTop
			var scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft

			var clientTop  = docElem.clientTop || body.clientTop || 0
			var clientLeft = docElem.clientLeft || body.clientLeft || 0

			var top  = box.top + scrollTop - clientTop
			var left = box.left + scrollLeft - clientLeft

			return [ Math.round( left ), Math.round( top ) ]
		}

		var createScreenSize = function( id ) {
			var offset = getOffset( document.getElementById( id ) )

			return [ window.innerWidth - offset[ 0 ], window.innerHeight - offset[ 1 ] ]
		}

		return function( id ) {
            if( isHtml5GameClosure ||
				isHtml5Ejecta ||
	            isHtml5Tizen ||
				isHtml5WinPhone ) {

                return [ window.innerWidth, window.innerHeight ]
            }

			if( !id ) {
				throw 'Missing container id argument. Please call the function with the spell container id.'
			}

			return createScreenSize( id )
		}
	}
)

define(
	'spell/shared/util/platform/private/flurry',
	[
		'spell/shared/util/platform/private/environment/isHtml5Ejecta',
		'spell/shared/util/platform/private/environment/isHtml5GameClosure'
	],
	function(
		isHtml5Ejecta,
		isHtml5GameClosure
	) {
		'use strict'


		return {
			logEvent : function( eventName, timed ) {
				if( isHtml5Ejecta ) {
					ejecta.flurryLogEvent( eventName, timed )

				} else if( isHtml5GameClosure ) {
					NATIVE.flurry.logEvent( eventName )
				}
			},
			endTimedEvent : function( eventName ) {
				if( isHtml5Ejecta ) {
					ejecta.flurryEndTimedEvent( eventName )

				} else if( isHtml5GameClosure ) {
					NATIVE.flurry.endTimedEvent( eventName )
				}
			}
		}
	}
)

define(
	'spell/shared/util/platform/private/Environment',
	[
		'spell/shared/util/platform/private/environment/visibilityChangeHandler'
	],
	function(
		visibilityChangeHandler
	) {
		'use strict'


		var Environment = function( configurationManager, eventManager ) {
			this.configurationManager = configurationManager
			this.eventManager         = eventManager
		}

		Environment.prototype = {
			init : function() {
				visibilityChangeHandler.registerListener( this.eventManager )
			}
		}

		return Environment
	}
)

/**
 * See http://www.w3.org/TR/page-visibility/ for details.
 *
 * enum VisibilityState { "hidden", "visible", "prerender", "unloaded" };
 *
 * partial interface Document {
 *  readonly attribute boolean hidden;
 *  readonly attribute VisibilityState visibilityState;
 * };
 */

define(
	'spell/shared/util/platform/private/environment/visibilityChangeHandler',
	[
		'spell/functions'
	],
	function(
		_
		) {
		'use strict'

		var hidden, state, visibilityChange

		if( typeof document.hidden !== 'undefined' ) {

			hidden = 'hidden'
			visibilityChange = 'visibilitychange'
			state = 'visibilityState'

		} else if( typeof document.mozHidden !== 'undefined' ) {

			hidden = 'mozHidden'
			visibilityChange = 'mozvisibilitychange'
			state = 'mozVisibilityState'

		} else if( typeof document.msHidden !== 'undefined' ) {

			hidden = 'msHidden'
			visibilityChange = 'msvisibilitychange'
			state = 'msVisibilityState'

		} else if( typeof document.webkitHidden !== 'undefined' ) {

			hidden = 'webkitHidden'
			visibilityChange = 'webkitvisibilitychange'
			state = 'webkitVisibilityState'
		}


		var handleVisibilityChange = function( eventManager ) {

			var visibilityState = document[ state ],
				isVisible       = ( visibilityState == 'VISIBLE' || visibilityState == 'visible' )

			eventManager.publish(
				eventManager.EVENT.VISIBILITY_CHANGED,
				isVisible
			)
		}

		return {
			registerListener : function( eventManager ) {

				var listener = _.bind( handleVisibilityChange, this, eventManager )

				document.addEventListener( visibilityChange, listener )
			},
			removeListener : function( ) {
			}
		}
	}
)

define(
	'spell/shared/util/platform/private/environment/isHtml5WinStore',
	function() {
		'use strict'

		return typeof( Windows ) !== 'undefined'
	}
)

define(
	'spell/shared/util/platform/private/environment/isBrowser',
	function() {
		'use strict'


		return !!( typeof window !== 'undefined' && navigator && document )
	}
)

define(
	'spell/shared/util/platform/private/createHost',
	function() {
		'use strict'


		return function() {
			return document.location.host
		}
	}
)

define(
	'spell/shared/util/platform/private/createComponentType',
	[
		'spell/shared/util/createModuleId'
	],
	function(
		createModuleId
	) {
		'use strict'


		var componentIdToType = {}

		return function( moduleLoader, spell, componentId ) {
			var type = componentIdToType[ componentId ]

			if( type === false ) {
				return

			} else if( type === undefined ) {
				try {
					type = moduleLoader.require( createModuleId( componentId ) )
					componentIdToType[ componentId ] = type

				} catch( exception ) {
					componentIdToType[ componentId ] = false

					return
				}
			}

			return new type( spell )
		}
	}
)

define(
	'spell/shared/util/platform/private/sound/winPhoneAudio/createWinPhoneAudioContext',
	[
		'spell/shared/util/createNormalizedVolume',
		'spell/shared/util/platform/private/sound/createFixedSoundFileSrc',
		'spell/shared/util/platform/private/sound/createSoundId',
		'spell/shared/util/platform/private/sound/html5Audio/createHtml5AudioContext'
	],
	function(
		createNormalizedVolume,
		createFixedSoundFileSrc,
		createSoundId,
		createHtml5AudioContext
	) {
		'use strict'


		var isMutedValue         = false
		var html5AudioContext    = createHtml5AudioContext()
		var isContextPausedValue = false

		var generateRequest = function( params ) {
			return params.join( ';' )
		}

		var sendNotification = function() {
			window.external.notify( generateRequest( Array.prototype.slice.call(arguments) ) )
		}

		/**
		 * @param {SoundAsset} soundAsset
		 * @param volume
		 * @param loop
		 */
		var play = function( soundAsset, volume, loop ) {
			var id  = createSoundId(),
				src = soundAsset.resource.resource.src

			volume = createNormalizedVolume( volume )
			loop   = !!loop

			if( soundAsset.isMusic ) {
				html5AudioContext.loadBuffer( src, soundAsset, function() {
					if( isContextMuted() ) {
						html5AudioContext.muteContext()
					}

					html5AudioContext.play( soundAsset, volume, loop )
				})

			} else {
				sendNotification( 'playSound', id, src, volume, loop )
			}

			return id
		}

		var stop = function( id ) {
			sendNotification( 'stopSound', id )
		}

		var setVolume = function ( id, volume ) {
			var volume = createNormalizedVolume( volume )

			sendNotification( 'setVolume', id, volume )
		}

		var setLoop = function( id, loop ) {
			sendNotification( 'setLoop', id, !!loop )
		}

		var mute = function( id ) {
			sendNotification( 'mute', id )
		}

		var unmute = function( id ) {
			sendNotification( 'unmute', id )
		}

		var muteContext = function() {
			html5AudioContext.muteContext()
			sendNotification( 'muteContext' )

			isMutedValue = true
		}

		var unmuteContext = function() {
			html5AudioContext.unmuteContext()
			sendNotification( 'unmuteContext' )

			isMutedValue = false
		}

		var isContextMuted = function() {
			return isMutedValue
		}

		var pause = function( id ) {
			sendNotification( 'pause', id )
		}

		var resume = function( id ) {
			sendNotification( 'resume', id )
		}

		var pauseContext = function() {
			html5AudioContext.pauseContext()
			sendNotification( 'pauseContext' )

			isContextPausedValue = true
		}

		var resumeContext = function() {
			html5AudioContext.resumeContext()
			sendNotification( 'resumeContext' )

			isContextPausedValue = false
		}

		var isContextPaused = function() {
			return isContextPausedValue
		}

		var tick = function() {}

		var loadBuffer = function( src, soundAsset, onLoadCallback ) {
			if( !src ) {
				throw 'Error: No src provided.'
			}

			if( !onLoadCallback ) {
				throw 'Error: No onLoadCallback provided.'
			}

			var src = createFixedSoundFileSrc( src )

			sendNotification( 'loadBuffer', src )

			onLoadCallback( { src: src } )
		}

		/*
		 * Returns a SoundResource instance.
		 *
		 * @param buffer
		 * @return {SoundResource}
		 */
		var createSound = function( buffer ) {
			return {
				/*
				 * Public
				 */
				duration : buffer.duration,

				/*
				 * Private
				 *
				 * This is an implementation detail of the class. If you write code that depends on this you better know what you are doing.
				 */
				resource : buffer
			}
		}

		/*
		 * Returns an audio context. Once a context has been created additional calls to this method return the same instance.
		 *
		 * @return {Object}
		 */
		var createAudioContext = function() {
			return createWrapperContext()
		}

		/*
		 * Creates a wrapper context for the back-end context.
		 */
		var createWrapperContext = function() {
			return {
				tick             : tick,
				play             : play,
				setLoop          : setLoop,
				setVolume        : setVolume,
				pause            : pause,
				resume           : resume,
				stop             : stop,
				mute             : mute,
				unmute           : unmute,
				muteContext      : muteContext,
				unmuteContext    : unmuteContext,
				isContextMuted   : isContextMuted,
				pauseContext     : pauseContext,
				resumeContext    : resumeContext,
				isContextPaused  : isContextPaused,
				createSound      : createSound,
				loadBuffer       : loadBuffer,
				getConfiguration : function() { return { type : 'winPhone' } }
			}
		}

		return createAudioContext
	}
)

define(
	'spell/shared/util/platform/private/sound/nativeAudio/createNativeAudioContext',
	[
		'spell/shared/util/createNormalizedVolume',
		'spell/shared/util/platform/private/sound/createFixedSoundFileSrc',
		'spell/shared/util/platform/private/sound/createSoundId'
	],
	function(
		createNormalizedVolume,
		createFixedSoundFileSrc,
		createSoundId
	) {
		'use strict'


		var dummy = function() {}

		// Unfortunately the game closure sound api is missing a "sound identity" concept. Therefore it is not possible to reference a playing sound by anything
		// but its src attribute value. The src value is not unqiue though.

		// HACK: This leaks memory because ids are never removed.
		var idToUrl = {}

		var audioBuffers = {}

		var AudioBuffer = function( src, onload, onerror ) {
			this.src     = src
			this.onload  = onload
			this.onerror = onerror
			this.loaded  = false
		}

		var isMutedValue         = false
		var isContextPausedValue = false

		var muteContext = function() {
			isMutedValue = true

			for( var id in idToUrl ) {
				setVolume( id , 0.0 )
			}
		}

		var pause = function( id ) {
			var url = idToUrl[ id ]
			if( !url ) return

			NATIVE.sound.pauseSound( url )
		}

		var resume = function( id ) {
			var url = idToUrl[ id ]
			if( !url ) return

			NATIVE.sound.play( url, 1, false )
		}

		var pauseContext = function() {
			isContextPausedValue = true

			for( var id in idToUrl ) {
				NATIVE.sound.pauseSound( id )
			}
		}

		var resumeContext = function() {
			isContextPausedValue = true

			for( var id in idToUrl ) {
				NATIVE.sound.playSound( id )
			}
		}

		var isContextPaused = function() {
			return isContextPausedValue
		}

		var unmuteContext = function() {
			isMutedValue = false

			for( var id in idToUrl ) {
				setVolume( id , 1.0 )
			}
		}

		var isContextMuted = function() {
			return isMutedValue
		}

		var setVolume = function( id, volume ) {
			var url = idToUrl[ id ]
			if( !url ) return

//			console.log( ' *** setVolume: ' + id + ' vol. ' + ( isMutedValue ? 0.0 : 1.0 ) )

			NATIVE.sound.setVolume( url, createNormalizedVolume( volume ) )
		}

		var stop = function ( id ) {
			var url = idToUrl[ id ]
			if( !url ) return

			delete idToUrl[ id ]

//			console.log( ' *** stop: ' + id )

			// TODO: Repair this
			// just a test if this causes the crash on android

			NATIVE.sound.stopSound( url )
		}

		var play = function( soundAsset, volume, loop ) {
			var id               = createSoundId(),
				url              = soundAsset.resource.src,
				normalizedVolume = createNormalizedVolume( volume )

			idToUrl[ id ] = url

//			console.log( ' *** play: ' + url + ', ' + ( id ? id : 'anonymous' ) + ', vol: ' + ( isMutedValue ? 0.0 : normalizedVolume ) )

			if( soundAsset.isMusic ) {
				NATIVE.sound.playBackgroundMusic( url, isMutedValue ? 0 : normalizedVolume, !!loop )

			} else {
				NATIVE.sound.playSound( url, isMutedValue ? 0 : normalizedVolume, !!loop )
			}

			return id
		}

		/*
		 * Returns a SoundResource instance.
		 *
		 * @param buffer
		 * @return {SoundResource}
		 */
		var createSound = function( audioBuffer ) {
//			console.log( ' *** Creating sound from buffer ' + audioBuffer.src )

			return {
				/*
				 * Public
				 */
				duration : 0, // not available

				/*
				 * Private
				 *
				 * This is an implementation detail of the class. If you write code that depends on this you better know what you are doing.
				 */
				src : audioBuffer.src
			}
		}


		var loadBuffer = function( src, soundAsset, onLoadCallback ) {
			if( !src ) {
				throw 'Error: No src provided.'
			}

			if( !onLoadCallback ) {
				throw 'Error: No onLoadCallback provided.'
			}

			var fixedSrc = createFixedSoundFileSrc( src )

			var audioBuffer = new AudioBuffer( fixedSrc, onLoadCallback )

			audioBuffers[ fixedSrc ] = audioBuffer

			if( soundAsset.isMusic ) {
				onLoadCallback( audioBuffer )

			} else {
				// trigger a load for this sound, this will trigger a sound loaded message in the future which will call the onLoadCallback
				NATIVE.sound.loadSound( fixedSrc )
			}
		}

		var createWrapperContext = function() {
			return {
				tick             : dummy,
				play             : play,
				setLoop          : dummy,
				setVolume        : setVolume,
				pause            : pause,
				resume           : resume,
				stop             : stop,
				mute             : dummy,
				unmute           : dummy,
				muteContext      : muteContext,
				unmuteContext    : unmuteContext,
				isContextMuted   : isContextMuted,
				pauseContext     : pauseContext,
				resumeContext    : resumeContext,
				isContextPaused  : isContextPaused,
				createSound      : createSound,
				loadBuffer       : loadBuffer,
				getConfiguration : function() { return { type : 'native' } }
			}
		}

		/**
		 * Creates an audio context
		 *
		 * @return {Object}
		 */
		var createAudioContext = function() {
			// The "soundLoaded" event is only triggered when loading a sound and not when loading (a.k.a. streaming) background music.
			NATIVE.events.registerHandler(
				'soundLoaded',
				function( event ) {
//					console.log( ' *** soundLoaded: ' + event.url )

					var audioBuffer = audioBuffers[ event.url ]

					if( audioBuffer &&
						!audioBuffer.loaded ) {

						audioBuffer.loaded = true

						if( audioBuffer.onload ) {
							audioBuffer.onload( audioBuffer )
						}
					}
				}
			)

			NATIVE.events.registerHandler(
				'soundError',
				function( event ) {
//					console.log( ' *** error loading ' + event.url )

					var audioBuffer = audioBuffers[ event.url ]

					if( audioBuffer &&
						audioBuffer.onerror ) {

						audioBuffer.onerror( audioBuffer )
					}
				}
			)

			return createWrapperContext()
		}

		return createAudioContext
	}
)

define(
	'spell/shared/util/platform/private/sound/webAudio/createWebAudioContext',
	[
		'spell/shared/util/createNormalizedVolume',
		'spell/shared/util/platform/private/sound/createFixedSoundFileSrc',
		'spell/shared/util/platform/private/sound/createSoundId',

		'spell/functions'
	],
	function(
		createNormalizedVolume,
		createFixedSoundFileSrc,
		createSoundId,

		_
	) {
		'use strict'


		var PLAYING_STATE = {
			 INIT: 0,
 			 PLAYING: 1,
			 PAUSED: 2,
			 FINISHED: 3
		}

		var SourceNodeWrapper = function( soundResource, volume, loop ) {
			this.volume             = volume
			this.loop               = loop
			this.startOffsetContext = 0
			this.pauseOffsetContext = 0
			this.startOffset        = 0
			this.state              = PLAYING_STATE.INIT

			this.soundResource = soundResource
		}

		SourceNodeWrapper.prototype = {


			play: function() {
				if( !this.node ||
					this.node.playbackState !== this.node.PLAYING_STATE ) {

					var gainNode    = context.createGainNode(),
						startOffset = this.startOffset + this.pauseOffsetContext - this.startOffsetContext

					this.node = context.createBufferSource()
					this.node.buffer = this.soundResource.resource
					this.node.connect( gainNode )

					gainNode.connect( context.destination )

					this.startOffsetContext = context.currentTime
					this.startOffset = startOffset % this.node.buffer.duration

					this.node.gain.value = isMuted() ? 0 : this.volume
					this.node.loop = this.loop
					this.state = PLAYING_STATE.PLAYING

					this.node.start( 0, this.startOffset )
				}
			}
		}

		var context,
			sourceNodes     = {},
			isMutedValue    = false,
			isContextPaused = false

		var create = function( id, soundResource, volume, loop, offset ) {
			volume = createNormalizedVolume( volume )
			loop   = !!loop
			offset = offset || 0

			var sourceNode = new SourceNodeWrapper( soundResource, volume, loop, offset )
			sourceNodes[ id ] = sourceNode

			return sourceNode
		}

		/**
		 * @param {SoundAsset} soundAsset
		 * @param volume
		 * @param loop
		 */
		var play = function( soundAsset, volume, loop ) {
			var id = createSoundId()

			var sourceNode = _.has( sourceNodes, id ) ?
				sourceNodes[ id ] :
				create( id, soundAsset.resource )

			setLoop( id, loop )
			setVolume( id, volume )

			sourceNode.play()

			return id
		}

		var stop = function( id ) {
			var sourceNode = sourceNodes[ id ]

			if( sourceNode &&
				sourceNode.node.playbackState === sourceNode.node.PLAYING_STATE ) {

				sourceNode.node.stop( 0 )
			}
		}

		var setVolume = function ( id, volume ) {
			var sourceNode = sourceNodes[ id ]

			if( sourceNode ) {
				sourceNode.volume =  createNormalizedVolume( volume )

				if( sourceNode.node ) {
					sourceNode.node.gain.value = sourceNode.volume
				}
			}
		}

		var setLoop = function( id, loop ) {
			var sourceNode = sourceNodes[ id ]

			if( sourceNode ) {
				sourceNode.loop = !!loop

				if( sourceNode.node ) {
					sourceNode.node.loop = sourceNode.loop
				}
			}
		}

		var mute = function( id ) {
			var sourceNode = sourceNodes[ id ]

			if( sourceNode ) {
				sourceNode.node.gain.value = 0
			}
		}

		var unmute = function( id ) {
			var sourceNode = sourceNodes[ id ]

			if( sourceNode ) {
				sourceNode.node.gain.value = sourceNode.volume
			}
		}

		var destroy = function( id ) {
			stop( id )

			sourceNodes[ id ] = null
			delete sourceNodes[ id ]
		}

		/**
		 * Looks through the sourceNodes and cleans up finished nodes
		 */
		var tick = function() {
			for( var id in sourceNodes ) {
				var sourceNode = sourceNodes[ id ]

				if( sourceNode.state != PLAYING_STATE.PAUSED &&
					sourceNode.node.playbackState === sourceNode.node.FINISHED_STATE ) {

					destroy( id )
				}
			}
		}

		var muteContext = function() {
			_.each( sourceNodes, function( value, key ) {
				mute( key )
			} )

			isMutedValue = true
		}

		var unmuteContext = function() {
			_.each( sourceNodes, function( value, key ) {
				unmute( key )
			} )

			isMutedValue = false
		}

		var resumeContext = function() {
			_.each( sourceNodes, function( value, key ) {
				resume( key )
			} )

			isContextPaused = false
		}

		var pauseContext = function() {
			_.each( sourceNodes, function( value, key ) {
				pause( key )
			} )

			isContextPaused = true
		}

		var isContextMuted = function() {
			return isMutedValue
		}

		var getIsContextPaused = function() {
			return isContextPaused
		}

		var isMuted = function() {
			return isMutedValue
		}

		var pause = function( id ) {
			var sourceNode = sourceNodes[ id ]

			if( sourceNode &&
				sourceNode.node.playbackState === sourceNode.node.PLAYING_STATE ) {

				sourceNode.state = PLAYING_STATE.PAUSED
				sourceNode.pauseOffsetContext = context.currentTime
				sourceNode.node.stop( 0 )
			}
		}

		var resume = function( id ) {
			var sourceNode = sourceNodes[ id ]

			if( sourceNode &&
				sourceNode.node.playbackState !== sourceNode.node.PLAYING_STATE ) {

				sourceNode.play()
			}
		}

		var loadBuffer = function( src, soundAsset, onLoadCallback ) {
			if( !src ) {
				throw 'Error: No src provided.'
			}

			if( !onLoadCallback ) {
				throw 'Error: No onLoadCallback provided.'
			}

			var request = new XMLHttpRequest()

			request.open( 'GET', createFixedSoundFileSrc( src ), true )
			request.responseType = 'arraybuffer'

			request.onload = function() {
				context.decodeAudioData(
					request.response,
					onLoadCallback
				)
			}

			request.onError = function() {
				throw 'Error: Could not load sound resource "' + config.resource + '".'
			}

			request.send()
		}

		/*
		 * Creates a wrapper context from the backend context.
		 */
		var createWrapperContext = function() {
			return {
				tick             : tick,
				play             : play,
				setLoop          : setLoop,
				setVolume        : setVolume,
				pause            : pause,
				resume           : resume,
				stop             : stop,
				mute             : mute,
				unmute           : unmute,
				muteContext      : muteContext,
				unmuteContext    : unmuteContext,
				isContextMuted   : isContextMuted,
				pauseContext     : pauseContext,
				resumeContext    : resumeContext,
				isContextPaused  : getIsContextPaused,
				createSound      : createSound,
				loadBuffer       : loadBuffer,
				getConfiguration : function() { return { type : 'web' } }
			}
		}

		/*
		 * Returns a audio context. Once a context has been created additional calls to this method return the same context instance.
		 *
		 * @return {Object}
		 */
		var createAudioContext = function() {
			if( context ) return context

			context = new webkitAudioContext()

			return createWrapperContext()
		}

		/*
		 * Returns a SoundResource instance.
		 *
		 * @param buffer
		 * @return {SoundResource}
		 */
		var createSound = function( buffer ) {
			return {
				/*
				 * Public
				 */
				duration : buffer.duration,

				/*
				 * Private
				 *
				 * This is an implementation detail of the class. If you write code that depends on this you better know what you are doing.
				 */
				resource : buffer
			}
		}

		return createAudioContext
	}
)

define(
	'spell/shared/util/platform/private/sound/getFileExtOfSupportedFormat',
	[
		'spell/shared/util/platform/private/environment/isHtml5GameClosure',
		'spell/shared/util/platform/private/environment/isHtml5WinPhone'
	],
	function(
		isHtml5GameClosure,
		isHtml5WinPhone
	) {
		'use strict'


		var fileExtensionToMimeTypes = [
			{
				fileExtension : 'ogg',
				mimeTypes : [
					'audio/ogg; codecs=vorbis'
				]
			},
			{
				fileExtension : 'mp3',
				mimeTypes : [
					'audio/mpeg; codecs="mp3"',
					'audio/mpeg',
					'audio/mp3',
					'audio/MPA',
					'audio/mpa-robust'
				]
			}
		]

		var fileExtOfSupportedFormat

		var getFileExtOfSupportedFormat = function() {
			if( isHtml5WinPhone ) {
				return 'wav'
			}

			if( isHtml5GameClosure ) {
				return 'mp3'
			}

			if( fileExtOfSupportedFormat ) {
				return fileExtOfSupportedFormat
			}

			var probe = new Audio()

			for( var i = 0, n = fileExtensionToMimeTypes.length; i < n; i++ ) {
				var fileExtension = fileExtensionToMimeTypes[ i ].fileExtension,
					mimeTypes     = fileExtensionToMimeTypes[ i ].mimeTypes

				for( var j = 0, m = mimeTypes.length; j < m; j++ ) {
					if( probe.canPlayType( mimeTypes[ j ] ) ) {
						fileExtOfSupportedFormat = fileExtension

						return fileExtension
					}
				}
			}
		}

        return getFileExtOfSupportedFormat
	}
)

define(
	'spell/shared/util/platform/private/sound/createFixedSoundFileSrc',
	[
		'spell/shared/util/platform/private/sound/getFileExtOfSupportedFormat'
	],
	function(
		getFileExtOfSupportedFormat
	) {
		'use strict'


		/**
		 * This function removes the extension from the supplied sound resource file and adds an extension which is
		 * supported by the audio back-end. The proper solution would be to not include the file extension in the
		 * library path to the sound resource file.
		 *
		 * @param src
		 * @return {String}
		 */
		var createFixedSoundFileSrc = function( src ) {
			var srcParts = src.split( '.' )

			srcParts.pop()
			srcParts.push( getFileExtOfSupportedFormat() )

			return srcParts.join( '.' )
		}

        return createFixedSoundFileSrc
	}
)

define(
	'spell/shared/util/createNormalizedVolume',
	[
		'spell/math/util'
	],
	function(
		mathUtil
	) {
		'use strict'

		return function( x ) {
			return x !== undefined ?
				mathUtil.clamp( x, 0, 1 ) :
				1
		}
	}
)

define(
	'spell/shared/util/platform/private/sound/html5Audio/createHtml5AudioContext',
	[
		'spell/shared/util/createNormalizedVolume',
		'spell/shared/util/platform/private/sound/createFixedSoundFileSrc',
		'spell/shared/util/platform/private/sound/createSoundId'
	],
	function(
		createNormalizedVolume,
		createFixedSoundFileSrc,
		createSoundId
	) {
		'use strict'


		var MAX_NUM_CHANNELS = 16 // the maximum amount of concurrently playing audio elements

		var audioElements        = {},
			isMutedValue         = false,
			numFreeChannels      = MAX_NUM_CHANNELS,
			isContextPausedValue = false

		var create = function( id, soundResource ) {
			var audio

			if( soundResource.resource.cloneNode ) {
				audio = soundResource.resource.cloneNode( true )

			} else {
				audio = new Audio()
				audio.src = soundResource.resource.src
			}

			audio.id = id
			audio.playing = false

			return audio
		}

		var loopCallback = function() {
			this.currentTime = 0
			this.play()
		}

		var removeCallback = function() {
			free( this )
		}

		var free = function( audioElement ) {
			audioElement.pause()

			audioElement.removeEventListener( 'ended', removeCallback, true )
			audioElement.removeEventListener( 'ended', loopCallback, true )

			numFreeChannels++

			delete audioElements[ audioElement.id ]
		}


		/**
		 * @param {SoundAsset} soundAsset
		 * @param volume
		 * @param loop
		 */
		var play = function( soundAsset, volume, loop ) {
			var id           = createSoundId(),
				audioElement = audioElements[ id ]

			if( !audioElement &&
				numFreeChannels > 0 ) {

				// when a free channel exists play the sound
				numFreeChannels--

				audioElement = create( id, soundAsset.resource )
				audioElements[ id ] = audioElement
			}

			if( audioElement ) {
				setLoop( id, loop )

				if( !audioElement.playing ) {
					audioElement.playing = true
					audioElement.play()
				}

				//set volume after play. In some browser it won't have an effect otherwise
				setVolume( id, volume )
				if( isContextMuted() ) {
					mute( id )
				}
			}

			return id
		}

		var stop = function( id ) {
			var audioElement = audioElements[ id ]
			if( !audioElement ) return

			free( audioElement )
		}

		var setVolume = function ( id, volume ) {
			var audioElement = audioElements[ id ]
			if( !audioElement ) return


			audioElement.volume = audioElement.sourceVolume = createNormalizedVolume( volume )
		}

		var setLoop = function( id, loop ) {
			var audioElement = audioElements[ id ]
			if( !audioElement ) return

			audioElement.loop = !!loop

			if( loop ) {
				audioElement.addEventListener( 'ended', loopCallback, true )
				audioElement.removeEventListener( 'ended', removeCallback, true )

			} else {
				audioElement.addEventListener( 'ended', removeCallback, true )
				audioElement.removeEventListener( 'ended', loopCallback, true )
			}
		}

		var mute = function( id ) {
			var audioElement = audioElements[ id ]

			if( audioElement ) {
				audioElement.volume = 0
			}
		}

		var unmute = function( id ) {
			var audioElement = audioElements[ id ]

			if( audioElement ) {
				audioElement.volume = audioElement.sourceVolume
			}
		}

		var muteContext = function() {
			for( var id in audioElements ) {
				mute( id )
			}

			isMutedValue = true
		}

		var unmuteContext = function() {
			for( var id in audioElements ) {
				unmute( id )
			}

			isMutedValue = false
		}

		var isContextMuted = function() {
			return isMutedValue
		}

		var pause = function( id ) {
			var audioElement = audioElements[ id ]

			if( audioElement ) {
				audioElement.pause()
			}
		}

		var resume = function( id ) {
			var audioElement = audioElements[ id ]

			if( audioElement ) {
				audioElement.play()
			}
		}

		var pauseContext = function() {
			for( var id in audioElements ) {
				pause( id )
			}

			isContextPausedValue = true
		}

		var resumeContext = function() {
			for( var id in audioElements ) {
				resume( id )
			}

			isContextPausedValue = false
		}

		var isContextPaused = function() {
			return isContextPausedValue
		}

		var tick = function() {}

		var loadBuffer = function( src, soundAsset, onLoadCallback ) {
			if( !src ) {
				throw 'Error: No src provided.'
			}

			if( !onLoadCallback ) {
				throw 'Error: No onLoadCallback provided.'
			}

			var audioElement = new Audio()

			audioElement.src = createFixedSoundFileSrc( src )

			// old webkit
			if( audioElement.autobuffer ) {
				audioElement.autobuffer = 'auto'
			}

			// new webkit
			if( audioElement.preload ) {
				audioElement.preload = 'auto'
			}

			audioElement.load()

			onLoadCallback( audioElement )
		}

		/*
		 * Returns a SoundResource instance.
		 *
		 * @param buffer
		 * @return {SoundResource}
		 */
		var createSound = function( buffer ) {
			return {
				/*
				 * Public
				 */
				duration : buffer.duration,

				/*
				 * Private
				 *
				 * This is an implementation detail of the class. If you write code that depends on this you better know what you are doing.
				 */
				resource : buffer
			}
		}

		/*
		 * Returns an audio context. Once a context has been created additional calls to this method return the same instance.
		 *
		 * @return {Object}
		 */
		var createAudioContext = function() {
			return createWrapperContext()
		}

		/*
		 * Creates a wrapper context for the back-end context.
		 */
		var createWrapperContext = function() {
			return {
				tick             : tick,
				play             : play,
				setLoop          : setLoop,
				setVolume        : setVolume,
				pause            : pause,
				resume           : resume,
				stop             : stop,
				mute             : mute,
				unmute           : unmute,
				muteContext      : muteContext,
				unmuteContext    : unmuteContext,
				isContextMuted   : isContextMuted,
				pauseContext     : pauseContext,
				resumeContext    : resumeContext,
				isContextPaused  : isContextPaused,
				createSound      : createSound,
				loadBuffer       : loadBuffer,
				getConfiguration : function() { return { type : 'web' } }
			}
		}

		return createAudioContext
	}
)

define(
	'spell/shared/util/platform/private/sound/createSoundId',
	function() {
		'use strict'


		var nextSoundId  = 1

		return function() {
			return nextSoundId++
		}
	}
)

define(
	'spell/shared/util/platform/private/sound/dummyAudio/createDummyAudioContext',
	[
		'spell/shared/util/platform/private/sound/createSoundId'
	],
	function(
		createSoundId
	) {
		'use strict'


		var isMutedValue         = false
		var isContextPausedValue = false

		var dummy = function() {}

		var play = function( soundAsset, volume, loop ) {
			return createSoundId()
		}

		var muteContext = function() {
			isMutedValue = true
		}

		var unmuteContext = function() {
			isMutedValue = false
		}

		var isContextMuted = function() {
			return isMutedValue
		}

		var isContextPaused = function() {
			return isContextPausedValue
		}

		var pauseContext = function() {
			isContextPausedValue = true
		}

		var resumeContext = function() {
			isContextPausedValue = false
		}

		/*
		 * Returns a SoundResource instance.
		 *
		 * @param buffer
		 * @return {SoundResource}
		 */
		var createSound = function( buffer ) {
			return {}
		}

		var loadBuffer = function( src, soundAsset, onLoadCallback ) {
			if( !src ) {
				throw 'Error: No src provided.'
			}

			if( !onLoadCallback ) {
				throw 'Error: No onLoadCallback provided.'
			}

			onLoadCallback( {} )
		}

		var createWrapperContext = function() {
			return {
				tick             : dummy,
				play             : play,
				setLoop          : dummy,
				setVolume        : dummy,
				pause            : dummy,
				resume           : dummy,
				stop             : dummy,
				mute             : dummy,
				unmute           : dummy,
				muteContext      : muteContext,
				unmuteContext    : unmuteContext,
				isContextMuted   : isContextMuted,
				pauseContext     : pauseContext,
				resumeContext    : resumeContext,
				isContextPaused  : isContextPaused,
				createSound      : createSound,
				loadBuffer       : loadBuffer,
				getConfiguration : function() { return { type : 'dummy' } }
			}
		}

		/*
		 * Returns an audio context.
		 *
		 * @return {Object}
		 */
		var createAudioContext = function() {
			return createWrapperContext()
		}

		return createAudioContext
	}
)

define(
	'spell/shared/util/platform/private/sound/AudioFactory',
	[
		'spell/shared/util/platform/private/sound/dummyAudio/createDummyAudioContext',
		'spell/shared/util/platform/private/sound/html5Audio/createHtml5AudioContext',
		'spell/shared/util/platform/private/sound/webAudio/createWebAudioContext',
		'spell/shared/util/platform/private/sound/nativeAudio/createNativeAudioContext',
		'spell/shared/util/platform/private/sound/winPhoneAudio/createWinPhoneAudioContext'
	],
	function(
		createDummyAudioContext,
		createHtml5AudioContext,
		createWebAudioContext,
		createNativeAudioContext,
		createWinPhoneAudioContext
	) {
		'use strict'


		var BACK_END_DUMMY_AUDIO    = 'dummy',
			BACK_END_WEB_AUDIO      = 'web',
			BACK_END_HTML5_AUDIO    = 'html5',
			BACK_END_NATIVE_AUDIO   = 'native',
			BACK_END_WIN_PHONE_AUDIO = 'winPhone'

		var context = null

		/*
		 * Creates an audio context
		 *
		 * @param requestedBackEnd - when supplied, overrides the automagic audio back-end detection
		 */
		var createAudioContext = function( requestedBackEnd ) {
			try {
				if( requestedBackEnd === undefined ? true : ( requestedBackEnd === BACK_END_DUMMY_AUDIO ) ) {
					context = createDummyAudioContext()

				} else if( requestedBackEnd === undefined ? true : ( requestedBackEnd === BACK_END_WEB_AUDIO ) ) {
					context = createWebAudioContext()

				} else if( requestedBackEnd === undefined ? true : ( requestedBackEnd === BACK_END_HTML5_AUDIO ) ) {
					context = createHtml5AudioContext()

				} else if( requestedBackEnd === undefined ? true : ( requestedBackEnd === BACK_END_NATIVE_AUDIO ) ) {
					context = createNativeAudioContext()

				} else if( requestedBackEnd === undefined ? true : ( requestedBackEnd === BACK_END_WIN_PHONE_AUDIO ) ) {
					context = createWinPhoneAudioContext()
				}

			} catch( e ) {
				context = null
			}

			if( context ) return context

			throw 'Could not create a audio back-end.'
		}

		return {
			BACK_END_DUMMY_AUDIO : BACK_END_DUMMY_AUDIO,
			BACK_END_HTML5_AUDIO : BACK_END_HTML5_AUDIO,
			BACK_END_WEB_AUDIO : BACK_END_WEB_AUDIO,
			BACK_END_NATIVE_AUDIO : BACK_END_NATIVE_AUDIO,
			BACK_END_WIN_PHONE_AUDIO : BACK_END_WIN_PHONE_AUDIO,
			createAudioContext : createAudioContext
		}
	}
)

define(
	'spell/shared/util/platform/private/graphics/createCanvasNode',
	function() {
		'use strict'


		return function( id, width, height ) {
            var canvas

            if ( window && window.canvas ) {
                // if a global canvas element was specified, use this (for Ejecta style environment)
                canvas = window.canvas

            } else {
                canvas = document.createElement( 'canvas' )
            }

            canvas.id           = id + '-screen'
            canvas.width        = width
            canvas.height       = height
            canvas.className    += 'spell-canvas'

			if( id ) {
				var container = document.getElementById( id )
				if( !container ) throw 'Could not find a container with the id ' + id + ' in the DOM tree.'

				container.appendChild( canvas )

			} else {
				document.body.appendChild( canvas )
			}

			return canvas
		}
	}
)

define(
	"spell/shared/util/platform/private/graphics/webgl/shaders",
	function() {
		return {
			vertex: [
				"attribute vec2 aVertexPosition;",

				"uniform mat3 uScreenSpaceShimMatrix;",
				"uniform mat3 uModelViewMatrix;",
				"uniform mat3 uTextureMatrix;",

				"varying vec2 vTextureCoord;",


				"void main( void ) {",
					"vTextureCoord = ( uTextureMatrix * vec3( aVertexPosition, 1.0 ) ).st;",
					"gl_Position = vec4( uScreenSpaceShimMatrix * uModelViewMatrix * vec3( aVertexPosition, 1.0 ), 1.0 );",
				"}"
			].join( "\n" ),

			fragment: [
				"precision mediump float;",

				"uniform sampler2D uTexture0;",
				"uniform vec4 uGlobalColor;",
				"uniform float uGlobalAlpha;",
				"uniform bool uFillRect;",

				"varying vec2 vTextureCoord;",


				"void main( void ) {",
					"if( !uFillRect ) {",
					"	vec4 color = texture2D( uTexture0, vTextureCoord );",
					"	gl_FragColor = color * vec4( 1.0, 1.0, 1.0, uGlobalAlpha );",

					"} else {",
					"	gl_FragColor = uGlobalColor * vec4( 1.0, 1.0, 1.0, uGlobalAlpha );",
					"}",
				"}"
			].join( "\n" )
		}
	}
)

define(
	"spell/shared/util/platform/private/graphics/webgl/createContext",
	[
		'spell/functions'
	],
	function(
		_
	) {
		"use strict"


		/*
		 * Returns a rendering context. Performs some probing to account for different runtime environments.
		 *
		 * @param canvas
		 */
		var createContext = function( canvas ) {
			var gl = null
			var contextNames = [ "webgl", "experimental-webgl", "webkit-3d", "moz-webgl" ]
			var attributes = {
				alpha: false
			}

			_.find(
				contextNames,
				function( it ) {
					gl = canvas.getContext( it, attributes )

					return ( gl !== null )
				}
			)

			return gl
		}

		return createContext
	}
)

define(
	'spell/shared/util/platform/private/graphics/webgl/createWebGlContext',
	[
		'spell/shared/util/platform/private/graphics/StateStack',
		'spell/shared/util/platform/private/graphics/webgl/createContext',
		'spell/shared/util/platform/private/graphics/webgl/shaders',

		'spell/shared/util/color',
		'spell/shared/util/platform/private/nativeType/createFloatArray',

		'spell/math/util',
		'spell/math/vec2',
		'spell/math/vec3',
		'spell/math/mat3',

		'spell/functions'
	],
	function(
		StateStack,
		createContext,
		shaders,

		color,
		createFloatArray,

		mathUtil,
		vec2,
		vec3,
		mat3,

		_
	) {
		'use strict'


		/*
		 * private
		 */

		var gl, canvas,
			stateStack           = new StateStack( 32 ),
			currentState         = stateStack.getTop(),
			NUM_CIRCLE_VERTICES  = 32,
			QUAD_VERTEX_OFFSET   = 0,
			CIRCLE_VERTEX_OFFSET = QUAD_VERTEX_OFFSET + 4,
			LINE_VERTEX_OFFSET   = CIRCLE_VERTEX_OFFSET + NUM_CIRCLE_VERTICES,
			vertices             = createFloatArray( ( LINE_VERTEX_OFFSET + 2 ) * 2 ),
			positionVertexBuffer

		var screenSpaceShimMatrix = mat3.create()

		// view space to screen space transformation matrix
		var viewToScreen = mat3.create()
		mat3.identity( viewToScreen )

		// world space to view space transformation matrix
		var worldToView = mat3.create()
		mat3.identity( worldToView )

		// accumulated transformation world space to screen space transformation matrix
		var worldToScreen = mat3.create()
		mat3.identity( worldToScreen )

		var screenToWorld = mat3.create()
		mat3.identity( screenToWorld )

		var tmpMatrix            = mat3.create(),
			defaultTextureMatrix = mat3.create()

		mat3.identity( defaultTextureMatrix )

		/*
		 * Creates a projection matrix that normalizes the transformation behaviour to that of the normalized canvas-2d (that is origin is in bottom left,
		 * positive x-axis to the right, positive y-axis up, screen space coordinates as input. The matrix transforms from screen space to clip space.
		 *
		 * @param width
		 * @param height
		 * @param matrix
		 */
		var createScreenSpaceShimMatrix = function( width, height, matrix ) {
			mathUtil.mat3Ortho(
				matrix,
				0,
				width,
				0,
				height
			)

			return matrix
		}

		var createViewToScreenMatrix = function( width, height, matrix ) {
			mat3.identity( matrix )

			matrix[ 0 ] = width * 0.5
			matrix[ 4 ] = height * 0.5
			matrix[ 6 ] = width * 0.5
			matrix[ 7 ] = height * 0.5

			return matrix
		}

		var initWrapperContext = function( shaderProgram ) {
			viewport( shaderProgram, 0, 0, gl.canvas.width, gl.canvas.height )

			// gl initialization
			gl.clearColor( 0.0, 0.0, 0.0, 1.0 )
			gl.clear( gl.COLOR_BUFFER_BIT )

			// setting up blending
			gl.enable( gl.BLEND )
			gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA )

			gl.disable( gl.DEPTH_TEST )

			gl.activeTexture( gl.TEXTURE0 )
		}

		/*
		 * Creates a wrapper context for the backend context.
		 */
		var createWrapperContext = function() {
			var shaderProgram = createShaderProgram()

			initWrapperContext( shaderProgram )

			return {
				clear                   : clear,
				createTexture           : createWebGlTexture,
				drawTexture             : _.bind( drawTexture, null, shaderProgram ),
				drawSubTexture          : _.bind( drawSubTexture, null, shaderProgram ),
				drawRect                : _.bind( drawRect, null, shaderProgram ),
				drawCircle              : _.bind( drawCircle, null, shaderProgram ),
				drawLine                : _.bind( drawLine, null, shaderProgram ),
				fillRect                : _.bind( fillRect, null, shaderProgram ),
				getConfiguration        : getConfiguration,
				resizeColorBuffer       : resizeColorBuffer,
				restore                 : restore,
				rotate                  : rotate,
				save                    : save,
				scale                   : scale,
				setClearColor           : setClearColor,
				setColor                : setColor,
				setLineColor            : setLineColor,
				setGlobalAlpha          : setGlobalAlpha,
				setTransform            : setTransform,
				setViewMatrix           : setViewMatrix,
				transform               : transform,
				translate               : translate,
				viewport                : _.bind( viewport, null, shaderProgram ),
				transformScreenToWorld  : transformScreenToWorld,
				getCanvasElement        : function() { return canvas },
				flush                   : function() {}
			}
		}

		/*
		 * Returns a rendering context. Once a context has been created additional calls to this method return the same context instance.
		 *
		 * @param canvas - the canvas dom element
		 */
		var createWebGlContext = function( canvasObj ) {
			if( canvasObj === undefined ) throw 'Missing first argument.'

			if( gl !== undefined ) return gl

			canvas = canvasObj
			gl = createContext( canvas )

			if( gl === null ) return null


			return createWrapperContext()
		}

		var createShaderProgram = function() {
			var shaderProgram = gl.createProgram()

			var vertexShader = gl.createShader( gl.VERTEX_SHADER )
			gl.shaderSource( vertexShader, shaders.vertex )
			gl.compileShader (vertexShader )
			gl.attachShader( shaderProgram, vertexShader )

			var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER )
			gl.shaderSource( fragmentShader, shaders.fragment )
			gl.compileShader( fragmentShader )
			gl.attachShader( shaderProgram, fragmentShader )

			gl.linkProgram( shaderProgram )
			gl.useProgram( shaderProgram )

			// storing the attribute and uniform locations
			shaderProgram.aVertexPosition        = gl.getAttribLocation( shaderProgram, 'aVertexPosition' )
			shaderProgram.uScreenSpaceShimMatrix = gl.getUniformLocation( shaderProgram, 'uScreenSpaceShimMatrix' )
			shaderProgram.uTextureMatrix         = gl.getUniformLocation( shaderProgram, 'uTextureMatrix' )
			shaderProgram.uFillRect              = gl.getUniformLocation( shaderProgram, 'uFillRect' )
			shaderProgram.uGlobalAlpha           = gl.getUniformLocation( shaderProgram, 'uGlobalAlpha' )
			shaderProgram.uGlobalColor           = gl.getUniformLocation( shaderProgram, 'uGlobalColor' )
			shaderProgram.uTexture0              = gl.getUniformLocation( shaderProgram, 'uTexture0' )
			shaderProgram.uModelViewMatrix       = gl.getUniformLocation( shaderProgram, 'uModelViewMatrix' )

			// setting up vertices
			var angleStep = Math.PI * 2 / NUM_CIRCLE_VERTICES

			// quad
			vertices[ QUAD_VERTEX_OFFSET * 2 + 0 ] = 0.0
			vertices[ QUAD_VERTEX_OFFSET * 2 + 1 ] = 0.0
			vertices[ QUAD_VERTEX_OFFSET * 2 + 2 ] = 1.0
			vertices[ QUAD_VERTEX_OFFSET * 2 + 3 ] = 0.0
			vertices[ QUAD_VERTEX_OFFSET * 2 + 4 ] = 1.0
			vertices[ QUAD_VERTEX_OFFSET * 2 + 5 ] = 1.0
			vertices[ QUAD_VERTEX_OFFSET * 2 + 6 ] = 0.0
			vertices[ QUAD_VERTEX_OFFSET * 2 + 7 ] = 1.0

			// circle
			for( var i = 0; i < NUM_CIRCLE_VERTICES; i++ ) {
				var angle = angleStep * i

				vertices[ CIRCLE_VERTEX_OFFSET * 2 + i * 2 ]     = Math.sin( angle )
				vertices[ CIRCLE_VERTEX_OFFSET * 2 + i * 2 + 1 ] = Math.cos( angle )
			}

			// line
			// These vertices are stubs and get overwritten once the drawLine function is called.
			vertices[ LINE_VERTEX_OFFSET * 2 + 0 ] = 0.0
			vertices[ LINE_VERTEX_OFFSET * 2 + 1 ] = 0.0
			vertices[ LINE_VERTEX_OFFSET * 2 + 2 ] = 0.0
			vertices[ LINE_VERTEX_OFFSET * 2 + 3 ] = 0.0

			positionVertexBuffer = gl.createBuffer()
			gl.bindBuffer( gl.ARRAY_BUFFER, positionVertexBuffer )
			gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW )

			gl.vertexAttribPointer( shaderProgram.aVertexPosition, 2, gl.FLOAT, false, 0, 0 )
			gl.enableVertexAttribArray( shaderProgram.aVertexPosition )

			// setting up screen space shim matrix
			gl.uniformMatrix3fv( shaderProgram.uScreenSpaceShimMatrix, false, screenSpaceShimMatrix )

			// setting up texture matrix
			setTextureMatrix( shaderProgram, defaultTextureMatrix )

			return shaderProgram
		}

		var updateTextureMatrix = function( shaderProgram, ss, st, tt, ts, matrix ) {
			mat3.identity( matrix )

			matrix[ 0 ] = ss
			matrix[ 4 ] = st
			matrix[ 6 ] = tt
			matrix[ 7 ] = ts

			gl.uniformMatrix3fv( shaderProgram.uTextureMatrix, false, matrix )
		}

		var setTextureMatrix = function( shaderProgram, textureMatrix ) {
			gl.uniformMatrix3fv( shaderProgram.uTextureMatrix, false, textureMatrix )
		}


		/*
		 * public
		 */
		var transformScreenToWorld = function( vec ) {
			// transform vec to a gl-like origin (bottom left)
			// use worldPosition as temp because we need to allocate it anyway
			var worldPosition = vec2.clone( vec )

			worldPosition[ 1 ] = gl.canvas.height - worldPosition[ 1 ]

			vec2.transformMat3( worldPosition, worldPosition, screenToWorld )

			return worldPosition
		}

		var save = function() {
			stateStack.pushState()
			currentState = stateStack.getTop()
		}

		var restore = function() {
			stateStack.popState()
			currentState = stateStack.getTop()

			setViewMatrix( currentState.viewMatrix )
		}

		var setColor = function( vec ) {
			currentState.color = color.createRgba( vec )
		}

		var setLineColor = function( vec ) {
			currentState.lineColor = color.createRgba( vec )
		}

		var setGlobalAlpha = function( u ) {
			currentState.opacity = u
		}

		var setClearColor = function( vec ) {
			gl.clearColor( vec[ 0 ], vec[ 1 ], vec[ 2 ], 1.0 )
		}

		var scale = function( vec ) {
			mat3.scale( currentState.matrix, currentState.matrix, vec )
		}

		var translate = function( vec ) {
			mat3.translate( currentState.matrix, currentState.matrix, vec )
		}

		var rotate = function( u ) {
			mat3.rotate( currentState.matrix, currentState.matrix, u )
		}

		/*
		 * Clears the color buffer with the clear color
		 */
		var clear = function() {
			gl.clear( gl.COLOR_BUFFER_BIT )
		}

		var drawTexture = function( shaderProgram, texture, destinationPosition, destinationDimensions, textureMatrix ) {
			if( texture === undefined ) throw 'Texture is undefined'

			// setting up fillRect mode
			gl.uniform1i( shaderProgram.uFillRect, 0 )

			// setting up global alpha
			gl.uniform1f( shaderProgram.uGlobalAlpha, currentState.opacity )

			// setting up global color
			gl.uniform4fv( shaderProgram.uGlobalColor, currentState.color )

			// setting up texture
			gl.bindTexture( gl.TEXTURE_2D, texture.privateGlTextureResource )
			gl.uniform1i( shaderProgram.uTexture0, 0 )

			// setting up transformation
			mat3.multiply( tmpMatrix, worldToScreen, currentState.matrix )

			// rotating the image so that it is not upside down
			mat3.translate( tmpMatrix, tmpMatrix, destinationPosition )
			mat3.rotate( tmpMatrix, tmpMatrix, Math.PI )
			mat3.scale( tmpMatrix, tmpMatrix, [ -1.0, 1.0 ] )
			mat3.scale( tmpMatrix, tmpMatrix, destinationDimensions )
			mat3.translate( tmpMatrix, tmpMatrix, [ 0.0, -1.0 ] )

			gl.uniformMatrix3fv( shaderProgram.uModelViewMatrix, false, tmpMatrix )

			setTextureMatrix(
				shaderProgram,
				textureMatrix ?
					textureMatrix :
					defaultTextureMatrix
			)

			gl.drawArrays( gl.TRIANGLE_FAN, QUAD_VERTEX_OFFSET, 4 )
		}

		var drawSubTexture = function( shaderProgram, texture, sourcePosition, sourceDimensions, destinationPosition, destinationDimensions ) {
			if( texture === undefined ) throw 'Texture is undefined'

			// setting up fillRect mode
			gl.uniform1i( shaderProgram.uFillRect, 0 )

			// setting up global alpha
			gl.uniform1f( shaderProgram.uGlobalAlpha, currentState.opacity )

			// setting up global color
			gl.uniform4fv( shaderProgram.uGlobalColor, currentState.color )

			// setting up texture
			gl.bindTexture( gl.TEXTURE_2D, texture.privateGlTextureResource )
			gl.uniform1i( shaderProgram.uTexture0, 0 )

			// setting up transformation
			mat3.multiply( tmpMatrix, worldToScreen, currentState.matrix )

			// rotating the image so that it is not upside down
			mat3.translate( tmpMatrix, tmpMatrix, destinationPosition )
			mat3.rotate( tmpMatrix, tmpMatrix, Math.PI )
			mat3.scale( tmpMatrix, tmpMatrix, [ -1.0, 1.0 ] )
			mat3.scale( tmpMatrix, tmpMatrix, destinationDimensions )
			mat3.translate( tmpMatrix, tmpMatrix, [ 0.0, -1.0 ] )

			gl.uniformMatrix3fv( shaderProgram.uModelViewMatrix, false, tmpMatrix )

			// setting up the texture matrix
			var tw = texture.dimensions[ 0 ],
				th = texture.dimensions[ 1 ]

			updateTextureMatrix(
				shaderProgram,
				( sourceDimensions[ 0 ] - 1 ) / tw,
				( sourceDimensions[ 1 ] - 1 ) / th,
				( sourcePosition[ 0 ] + 0.5 ) / tw,
				( sourcePosition[ 1 ] + 0.5 ) / th,
				tmpMatrix
			)

			gl.drawArrays( gl.TRIANGLE_FAN, QUAD_VERTEX_OFFSET, 4 )
		}

		var drawRect = function( shaderProgram, dx, dy, dw, dh, lineWidth ) {
			if( !lineWidth ) lineWidth = 1

			gl.lineWidth( lineWidth )

			// setting up fillRect mode
			gl.uniform1i( shaderProgram.uFillRect, 1 )

			// setting up global alpha
			gl.uniform1f( shaderProgram.uGlobalAlpha, currentState.opacity )

			// setting up global color
			gl.uniform4fv( shaderProgram.uGlobalColor, currentState.lineColor )

			// setting up transformation
			mat3.multiply( tmpMatrix, worldToScreen, currentState.matrix )

			// correcting position
			mat3.translate( tmpMatrix, tmpMatrix, [ dx, dy ] )
			mat3.scale( tmpMatrix, tmpMatrix, [ dw, dh ] )

			gl.uniformMatrix3fv( shaderProgram.uModelViewMatrix, false, tmpMatrix )

			gl.drawArrays( gl.LINE_LOOP, QUAD_VERTEX_OFFSET, 4 )
		}

		var drawCircle = function( shaderProgram, dx, dy, radius, lineWidth ) {
			if( !lineWidth ) lineWidth = 1

			gl.lineWidth( lineWidth )

			// setting up fillRect mode
			gl.uniform1i( shaderProgram.uFillRect, 1 )

			// setting up global alpha
			gl.uniform1f( shaderProgram.uGlobalAlpha, currentState.opacity )

			// setting up global color
			gl.uniform4fv( shaderProgram.uGlobalColor, currentState.lineColor )

			// setting up transformation
			mat3.multiply( tmpMatrix, worldToScreen, currentState.matrix )

			// correcting position
			mat3.translate( tmpMatrix, tmpMatrix, [ dx, dy ] )
			mat3.scale( tmpMatrix, tmpMatrix, [ radius, radius ] )

			gl.uniformMatrix3fv( shaderProgram.uModelViewMatrix, false, tmpMatrix )

			gl.drawArrays( gl.LINE_LOOP, CIRCLE_VERTEX_OFFSET, NUM_CIRCLE_VERTICES )
		}

		var drawLine = function( shaderProgram, ax, ay, bx, by, lineWidth ) {
			if( !lineWidth ) lineWidth = 1

			gl.lineWidth( lineWidth )

			// setting up fillRect mode
			gl.uniform1i( shaderProgram.uFillRect, 1 )

			// setting up global alpha
			gl.uniform1f( shaderProgram.uGlobalAlpha, currentState.opacity )

			// setting up global color
			gl.uniform4fv( shaderProgram.uGlobalColor, currentState.lineColor )

			// setting up transformation
			mat3.multiply( tmpMatrix, worldToScreen, currentState.matrix )

			gl.uniformMatrix3fv( shaderProgram.uModelViewMatrix, false, tmpMatrix )

			// line
			vertices[ LINE_VERTEX_OFFSET * 2 + 0 ] = ax
			vertices[ LINE_VERTEX_OFFSET * 2 + 1 ] = ay
			vertices[ LINE_VERTEX_OFFSET * 2 + 2 ] = bx
			vertices[ LINE_VERTEX_OFFSET * 2 + 3 ] = by

			gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW )

			gl.drawArrays( gl.LINES, LINE_VERTEX_OFFSET, 2 )
		}

		var fillRect = function( shaderProgram, dx, dy, dw, dh ) {
			// setting up fillRect mode
			gl.uniform1i( shaderProgram.uFillRect, 1 )

			// setting up global alpha
			gl.uniform1f( shaderProgram.uGlobalAlpha, currentState.opacity )

			// setting up global color
			gl.uniform4fv( shaderProgram.uGlobalColor, currentState.color )

			// setting up transformation
			mat3.multiply( tmpMatrix, worldToScreen, currentState.matrix )

			// correcting position
			mat3.translate( tmpMatrix, tmpMatrix, [ dx, dy ] )
			mat3.scale( tmpMatrix, tmpMatrix, [ dw, dh ] )

			gl.uniformMatrix3fv( shaderProgram.uModelViewMatrix, false, tmpMatrix )

			gl.drawArrays( gl.TRIANGLE_FAN, QUAD_VERTEX_OFFSET, 4 )
		}

		var resizeColorBuffer = function( width, height ) {
			gl.canvas.width  = width
			gl.canvas.height = height

			createViewToScreenMatrix( width, height, viewToScreen )
			mat3.multiply( worldToScreen, viewToScreen, worldToView )
		}

		var transform = function( matrix ) {
			mat3.multiply( currentState.matrix, currentState.matrix, matrix )
		}

		var setTransform = function( matrix ) {
			mat3.copy( currentState.matrix, matrix )
		}

		var setViewMatrix = function( matrix ) {
			mat3.copy( currentState.viewMatrix, matrix )

			mat3.copy( worldToView, matrix )
			createViewToScreenMatrix( gl.canvas.width, gl.canvas.height, viewToScreen )
			mat3.multiply( worldToScreen, viewToScreen, worldToView )
			mat3.invert( screenToWorld, worldToScreen )
		}

		var viewport = function( shaderProgram, x, y, width, height ) {
			gl.viewport( x, y , width, height )

			// reinitialize screen space shim matrix
			createScreenSpaceShimMatrix( width, height, screenSpaceShimMatrix )

			gl.uniformMatrix3fv( shaderProgram.uScreenSpaceShimMatrix, false, screenSpaceShimMatrix )
		}

		/*
		 * Returns an object describing the current configuration of the rendering backend.
		 */
		var getConfiguration = function() {
			var info = gl.getParameter( gl.VENDOR ) + ';' +
				gl.getParameter( gl.RENDERER ) + ';' +
				gl.getParameter( gl.VERSION ) + ';' +
				gl.getParameter( gl.SHADING_LANGUAGE_VERSION )

			return {
				type   : 'webgl',
				width  : gl.canvas.width,
				height : gl.canvas.height,
				info   : info
			}
		}

		var isPowerOfTwo = function( number ) {
			var magnitude = ( Math.log( number ) / Math.log( 2 ) )

			return magnitude === parseInt( magnitude, 10 )
		}

		/*
		 * Returns instance of texture class
		 *
		 * The public interface of the texture class consists of the two attributes width and height.
		 *
		 * @param image
		 */
		var createWebGlTexture = function( image ) {
			var isPowerOfTwoTexture = isPowerOfTwo( image.width ) && isPowerOfTwo( image.height )

			var texture = gl.createTexture()

			gl.bindTexture( gl.TEXTURE_2D, texture )
			gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image )
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR )

			if( isPowerOfTwoTexture ) {
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT )
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT )
				gl.generateMipmap( gl.TEXTURE_2D )

			} else {
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE )
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE )
			}

			gl.bindTexture( gl.TEXTURE_2D, null )

			return {
				/*
				 * Public
				 */
				dimensions : [ image.width, image.height ],

				/*
				 * Private
				 *
				 * This is an implementation detail of the class. If you write code that depends on this you better know what you are doing.
				 */
				privateGlTextureResource : texture
			}
		}

		return createWebGlContext
	}
)

define(
	'spell/shared/util/color',
	[
		'spell/math/util',

		'spell/math/vec3',
		'spell/functions'
	],
	function(
		mathUtil,

		vec3
	) {
		'use strict'


		var toRange = function( value ) {
			return Math.round( mathUtil.clamp( value, 0, 1 ) * 255 )
		}


		var createRgb = function( r, g, b ) {
			return [ r, g, b ]
		}


		var createRgba = function( vec ) {
			return ( vec.length === 4 ?
				[ vec[ 0 ], vec[ 1 ], vec[ 2 ], vec[ 3 ] ] :
				[ vec[ 0 ], vec[ 1 ], vec[ 2 ], 1.0 ] )
		}


		var createRandom = function() {
			var primaryColorIndex = Math.round( Math.random() * 3 )
			var colorVec = vec3.fromValues( 0.8, 0.8, 0.8 )

			for( var i = 0; i < colorVec.length; i++ ) {
				if ( i === primaryColorIndex ) {
					colorVec[ i ] = 0.95

				} else {
					colorVec[ i ] *= Math.random()
				}
			}

			return colorVec
		}


		var formatCanvas = function( vec ) {
			if( vec.length === 4 ) {
				return 'rgba('
					+ toRange( vec[ 0 ] ) + ', '
					+ toRange( vec[ 1 ] ) + ', '
					+ toRange( vec[ 2 ] ) + ', '
					+ mathUtil.clamp( vec[ 3 ], 0, 1 ) + ')'
			}

			return 'rgb('
				+ toRange( vec[ 0 ] ) + ', '
				+ toRange( vec[ 1 ] ) + ', '
				+ toRange( vec[ 2 ] ) + ')'
		}


		return {
			createRgb    : createRgb,
			createRgba   : createRgba,
			createRandom : createRandom,
			formatCanvas : formatCanvas
		}
	}
)

define(
	'spell/shared/util/platform/private/Time',
	function() {
		'use strict'

		return {
			/*
			 * Returns the number of milliseconds since midnight January 1, 1970, UTC.
			 */
			getCurrentInMs: function() {
				return Date.now()
			}
		}
	}
)

define(
	'spell/shared/util/platform/private/nativeType/Int32Array',
	function() {
		'use strict'


		var isSupported = typeof( Int32Array ) !== 'undefined',
			arrayType   = isSupported ? Int32Array : Array

		return {
			isSupported : function() {
				return isSupported
			},
			create : function( length ) {
				return new arrayType( length )
			},
			fromValues : function( values ) {
				return isSupported ?
					new arrayType( values ) :
					values.slice( 0 )
			}
		}
	}
)

define(
	'spell/shared/util/platform/private/nativeType/Int8Array',
	function() {
		'use strict'


		var isSupported = typeof( Int8Array ) !== 'undefined',
			arrayType   = isSupported ? Int8Array : Array

		return {
			isSupported : function() {
				return isSupported
			},
			create : function( length ) {
				return new arrayType( length )
			},
			fromValues : function( values ) {
				return isSupported ?
					new arrayType( values ) :
					values.slice( 0 )
			}
		}
	}
)

define(
	'spell/shared/util/platform/private/nativeType/hasFloatArraySupport',
	function() {
		'use strict'


		return function() {
			return typeof( Float32Array ) !== 'undefined'
		}
	}
)

define(
	'spell/shared/util/platform/private/nativeType/createFloatArray',
	[
		'spell/shared/util/platform/private/nativeType/hasFloatArraySupport'
	],
	function(
		hasFloatArraySupport
	) {
		'use strict'


		var arrayType = ( hasFloatArraySupport() ? Float32Array : Array )

		return function( length ) {
			return new arrayType( length )
		}
	}
)

define(
	'spell/shared/util/platform/private/graphics/StateStack',
	[
		'spell/shared/util/platform/private/nativeType/createFloatArray',

		'spell/math/mat3',
		'spell/functions'
	],
	function(
		createFloatArray,

		mat3,
		_
	) {
		'use strict'


		/*
		 * private
		 */

		var createState = function( opacity, color, lineColor, matrix, viewMatrix ) {
			return {
				opacity     : opacity,
				color       : color,
				lineColor   : lineColor,
				matrix      : matrix,
				viewMatrix  : viewMatrix
			}
		}

		var createDefaultState = function() {
			var opacity     = 1.0,
				color       = createFloatArray( 4 ),
				lineColor   = createFloatArray( 4 ),
				matrix      = mat3.create(),
				viewMatrix  = mat3.create()

			color[ 0 ] = 1.0
			color[ 1 ] = 1.0
			color[ 2 ] = 1.0
			color[ 3 ] = 1.0

			lineColor[ 0 ] = 1.0
			lineColor[ 1 ] = 1.0
			lineColor[ 2 ] = 1.0
			lineColor[ 3 ] = 1.0

			mat3.identity( matrix )
			mat3.identity( viewMatrix )

			return createState( opacity, color, lineColor, matrix, viewMatrix )
		}

		var copyState = function( source, target ) {
			target.opacity = source.opacity

			target.color[ 0 ] = source.color[ 0 ]
			target.color[ 1 ] = source.color[ 1 ]
			target.color[ 2 ] = source.color[ 2 ]
			target.color[ 3 ] = source.color[ 3 ]

			target.lineColor[ 0 ] = source.lineColor[ 0 ]
			target.lineColor[ 1 ] = source.lineColor[ 1 ]
			target.lineColor[ 2 ] = source.lineColor[ 2 ]
			target.lineColor[ 3 ] = source.lineColor[ 3 ]

			mat3.copy( target.matrix, source.matrix )
			mat3.copy( target.viewMatrix, source.viewMatrix )
		}


		/*
		 * public
		 */

		var StateStack = function( depth ) {
			this.depth = depth
			this.stack = _.range( depth )
			this.index = 0

			// initializing stack
			for( var i = 0, stack = this.stack; i < depth; i++ ) {
				stack[ i ] = createDefaultState()
			}
		}

		StateStack.prototype = {
			pushState : function() {
				var index = this.index,
					stack = this.stack

				if( index === this.depth -1 ) throw 'Can not push state. Maximum state stack depth of ' + this.depth + ' was reached.'


				copyState( stack[ index ], stack[ ++this.index ] )
			},
			popState : function() {
				var index = this.index

				if( index > 0 ) {
					this.index--

				} else {
					throw 'Can not pop state. The state stack is already depleted.'
				}
			},
			getTop : function() {
				return this.stack[ this.index ]
			}
		}

		return StateStack
	}
)

define(
	'spell/shared/util/platform/private/graphics/canvas/createCanvasContext',
	[
		'spell/functions',
		'spell/shared/util/platform/private/graphics/StateStack',
		'spell/shared/util/color',

		'spell/math/util',
		'spell/math/vec2',
		'spell/math/mat3'
	],
	function(
		_,
		StateStack,
		color,

		mathUtil,
		vec2,
		mat3
	) {
		'use strict'


		var modulo = mathUtil.modulo

		var context,
			canvas,
			clearColor   = color.formatCanvas( [ 0.0, 0.0, 0.0, 1.0 ] ),
			stateStack   = new StateStack( 32 ),
			currentState = stateStack.getTop()


		// HACK: this scale factor is used to mitigate the insane canvas-2d rasterization rules
		var magicScale    = 1.015,
			negMagicScale = -magicScale

		// scaling factor which must be applied to draw a one pixel wide line
		var pixelScale

		// world space to view space transformation matrix
		var worldToView = mat3.create()
		mat3.identity( worldToView )

		// view space to screen space transformation matrix
		var viewToScreen = mat3.create()
		mat3.identity( viewToScreen )

		// accumulated transformation world space to screen space transformation matrix
		var worldToScreen = mat3.create()
		mat3.identity( worldToScreen )

		var screenToWorld = mat3.create()
		mat3.identity( screenToWorld )

		var getUntilTexCoord = function( i, numIterations, endTexCoord ) {
			if( i + 1 === numIterations ) {
				var tc = endTexCoord % 1

				return tc === 0.0 ? 1.0 : tc
			}

			return 1
		}

		var normalizeStartTexCoord = function( tc ) {
			if( tc < 0.0 ) {
				tc += 1.0
			}

			return modulo( tc, 1.0 )
		}

		/**
		 * This function emulates texture mapping on canvas-2d. Rotation transformations and negative scales are not
		 * supported.
		 *
		 * @param context
		 * @param texture
		 * @param textureMatrix
		 * @param destinationDimensions
		 */
		var mapTexture = function( context, texture, textureMatrix, destinationDimensions ) {
			var scaleX            = Math.abs( textureMatrix[ 0 ] ),
				scaleY            = Math.abs( textureMatrix[ 4 ] ),
				textureWidth      = texture.dimensions[ 0 ],
				textureHeight     = texture.dimensions[ 1 ],
				destinationWidth  = destinationDimensions[ 0 ],
				destinationHeight = destinationDimensions[ 1 ]

			var startTexCoordX = normalizeStartTexCoord( textureMatrix[ 6 ] ),
				startTexCoordY = normalizeStartTexCoord( textureMatrix[ 7 ] ),
				endTexCoordX   = startTexCoordX + Math.abs( scaleX ),
				endTexCoordY   = startTexCoordY + Math.abs( scaleY )

			var numIterationsX = Math.round( Math.ceil( endTexCoordX ) - Math.floor( startTexCoordX ) ),
				numIterationsY = Math.round( Math.ceil( endTexCoordY ) - Math.floor( startTexCoordY ) )

			for( var y = 0,
				 fromTexCoordY = startTexCoordY,
				 untilTexCoordY = 0.0,
				 texCoordRangeY = 0.0,
				 scaledTexCoordRangeY = 0.0,
				 scaledTexCoordRangeX = 0.0,
				 destinationPositionY = 0.0,
				 coveredTexCoordY = 0.0;
				 y < numIterationsY;
				 y++ ) {

				untilTexCoordY       = getUntilTexCoord( y, numIterationsY, endTexCoordY )
				texCoordRangeY       = untilTexCoordY - fromTexCoordY
				coveredTexCoordY     += texCoordRangeY
				scaledTexCoordRangeY = texCoordRangeY / scaleY

				for( var x = 0,
					 fromTexCoordX = startTexCoordX,
					 untilTexCoordX = 0.0,
					 texCoordRangeX = 0.0,
					 destinationPositionX = 0.0,
					 coveredTexCoordX = 0.0;
					 x < numIterationsX;
					 x++ ) {

					untilTexCoordX       = getUntilTexCoord( x, numIterationsX, endTexCoordX )
					texCoordRangeX       = untilTexCoordX - fromTexCoordX
					coveredTexCoordX     += texCoordRangeX
					scaledTexCoordRangeX = texCoordRangeX / scaleX

					context.drawImage(
						texture.privateImageResource,
						textureWidth * fromTexCoordX,
						textureHeight * fromTexCoordY,
						textureWidth * texCoordRangeX,
						textureHeight * texCoordRangeY,
						destinationWidth * destinationPositionX,
						destinationHeight * destinationPositionY,
						destinationWidth * scaledTexCoordRangeX,
						destinationHeight * scaledTexCoordRangeY
					)

					destinationPositionX += scaledTexCoordRangeX
					fromTexCoordX = 0
				}

				destinationPositionY += scaledTexCoordRangeY
				fromTexCoordY = 0
			}
		}

		/*
		 * Returns true if the supplied quad covers the full screen, false otherwise.
		 *
		 * @param x
		 * @param y
		 * @param width
		 * @param height
		 */
		var isFullscreenCovered = function( x, y, width, height ) {
			var leftBorder   = x,
				rightBorder  = x + width,
				topBorder    = y + height,
				bottomBorder = y

			return ( leftBorder <= 0 &&
				rightBorder >= canvas.width &&
				topBorder >= canvas.height &&
				bottomBorder <= 0 )
		}

		var setClippingRegion = function( x, y, width, height ) {
			context.beginPath()
			context.rect( x, y, width, height )
			context.closePath()
			context.clip()
		}

		var updateWorldToScreen = function( viewToScreen, worldToView ) {
			mat3.multiply( worldToScreen, viewToScreen, worldToView )
			mat3.invert( screenToWorld, worldToScreen )

			pixelScale = Math.abs( 1 / worldToScreen[ 0 ] )

			context.setTransform(
				worldToScreen[ 0 ],
				worldToScreen[ 1 ],
				worldToScreen[ 3 ],
				worldToScreen[ 4 ],
				worldToScreen[ 6 ],
				worldToScreen[ 7 ]
			)
		}

		var initWrapperContext = function() {
			viewport( 0.0, 0.0, canvas.width, canvas.height )

			// world space to view space matrix
			var cameraWidth  = canvas.width,
				cameraHeight = canvas.height

			mathUtil.mat3Ortho(
				worldToView,
				-cameraWidth * 0.5,
				cameraWidth * 0.5,
				-cameraHeight * 0.5,
				cameraHeight * 0.5
			)

			mat3.translate( worldToView, worldToView, [ -cameraWidth * 0.5, -cameraHeight * 0.5 ] ) // WATCH OUT: apply inverse translation for camera position

			updateWorldToScreen( viewToScreen, worldToView )
		}

		/*
		 * Creates a wrapper context from the backend context.
		 */
		var createWrapperContext = function() {
			initWrapperContext()

			// The gameclosure canvas wrapper exposes a flush method. It flushes accumulated state to the color buffer.
			var flush = _.isFunction( context.flush ) ? context.flush : function() {}

			return {
				clear                  : clear,
				createTexture          : createCanvasTexture,
				drawTexture            : drawTexture,
				drawSubTexture         : drawSubTexture,
				drawRect               : drawRect,
				drawCircle             : drawCircle,
				drawLine               : drawLine,
				fillRect               : fillRect,
				getConfiguration       : getConfiguration,
				resizeColorBuffer      : resizeColorBuffer,
				restore                : restore,
				rotate                 : rotate,
				save                   : save,
				scale                  : scale,
				setClearColor          : setClearColor,
				setColor               : setColor,
				setLineColor           : setLineColor,
				setGlobalAlpha         : setGlobalAlpha,
				setTransform           : setTransform,
				setViewMatrix          : setViewMatrix,
				transform              : transform,
				translate              : translate,
				viewport               : viewport,
				transformScreenToWorld : transformScreenToWorld,
				getCanvasElement       : function() { return canvas },
				flush                  : flush
			}
		}

		/*
		 * Returns a rendering context. Once a context has been created additional calls to this method return the same context instance.
		 *
		 * @param canvas - the canvas dom element
		 */
		var createCanvasContext = function( canvasObj ) {
			if( canvasObj === undefined ) throw 'Missing first argument.'

			if( context !== undefined ) return context

			canvas  = canvasObj
			context = canvas.getContext( '2d' )

			if( context === null ) return null

			return createWrapperContext()
		}


		/*
		 * public
		 */
		var transformScreenToWorld = function( vec ) {
			return vec2.transformMat3( vec2.create(), vec, screenToWorld )
		}

		var setColor = function( vec ) {
			currentState.color = color.createRgba( vec )
			context.fillStyle = color.formatCanvas( vec )
		}

		var setLineColor = function( vec ) {
			currentState.lineColor = color.createRgba( vec )
			context.strokeStyle = color.formatCanvas( vec )
		}

		var setGlobalAlpha = function( u ) {
			currentState.opacity = u
			context.globalAlpha = u
		}

		var setClearColor = function( vec ) {
			clearColor = color.formatCanvas( vec )
		}

		var save = function() {
			stateStack.pushState()
			currentState = stateStack.getTop()
		}

		var restore = function() {
			stateStack.popState()
			currentState = stateStack.getTop()

			setViewMatrix( currentState.viewMatrix )
		}

		var scale = function( vec ) {
			mat3.scale( currentState.matrix, currentState.matrix, vec )
		}

		var translate = function( vec ) {
			mat3.translate( currentState.matrix, currentState.matrix, vec )
		}

		var rotate = function( u ) {
			mat3.rotate( currentState.matrix, u )
		}

		/*
		 * Clears the color buffer with the clear color
		 */
		var clear = function() {
 			context.save()
			{
				// reset transformation to identity
				context.setTransform( 1.0, 0.0, 0.0, 1.0, 0.0, 0.0 )

				context.globalAlpha = 1.0
				context.fillStyle = clearColor
				context.fillRect( 0.0, 0.0, canvas.width, canvas.height )
			}
			context.restore()
		}

		var drawTexture = function( texture, destinationPosition, destinationDimensions, textureMatrix ) {
			if( texture === undefined ) throw 'Texture is undefined'

			context.save()
			{
				context.globalAlpha = currentState.opacity

				var modelToWorld = currentState.matrix

				context.transform(
					modelToWorld[ 0 ],
					modelToWorld[ 1 ],
					modelToWorld[ 3 ],
					modelToWorld[ 4 ],
					modelToWorld[ 6 ],
					modelToWorld[ 7 ]
				)

				if( !textureMatrix ) {
					// rotating the image so that it is not upside down
					context.translate( destinationPosition[ 0 ], destinationPosition[ 1 ] )
					context.rotate( Math.PI )
					context.scale( -1.0, 1.0 )
					context.translate( 0.0, -destinationDimensions[ 1 ] )

					context.drawImage(
						texture.privateImageResource,
						0.0,
						0.0,
						destinationDimensions[ 0 ],
						destinationDimensions[ 1 ]
					)

				} else {
					context.translate( destinationPosition[ 0 ], destinationPosition[ 1 ] )
					context.rotate( Math.PI )

					// Compensating for the lack of negative scales support in mapTexture by letting canvas do the work.
					// Macgyver would have been proud.
					var xAxisInverted = textureMatrix[ 0 ] < 0.0,
						yAxisInverted = textureMatrix[ 4 ] < 0.0

					context.scale(
						xAxisInverted ? 1.0 : -1.0,
						yAxisInverted ? -1.0 : 1.0
					)

					context.translate(
						xAxisInverted ? -destinationDimensions[ 0 ] : 0.0,
						yAxisInverted ? 0.0 : -destinationDimensions[ 1 ]
					)

					mapTexture( context, texture, textureMatrix, destinationDimensions )
				}
			}
			context.restore()
		}

		var drawSubTexture = function( texture, sourcePosition, sourceDimensions, destinationPosition, destinationDimensions ) {
			if( texture === undefined ) throw 'Texture is undefined'

			context.save()
			{
				context.globalAlpha = currentState.opacity

				var modelToWorld = currentState.matrix

				context.transform(
					modelToWorld[ 0 ],
					modelToWorld[ 1 ],
					modelToWorld[ 3 ],
					modelToWorld[ 4 ],
					modelToWorld[ 6 ],
					modelToWorld[ 7 ]
				)

				// rotating the image so that it is not upside down
				context.translate( destinationPosition[ 0 ], destinationPosition[ 1 ] )
				context.rotate( Math.PI )
				context.scale( negMagicScale, magicScale )
				context.translate( 0.0, -destinationDimensions[ 1 ] )

				context.drawImage(
					texture.privateImageResource,
					sourcePosition[ 0 ],
					sourcePosition[ 1 ],
					sourceDimensions[ 0 ],
					sourceDimensions[ 1 ],
					0,
					0,
					destinationDimensions[ 0 ],
					destinationDimensions[ 1 ]
				)
			}
			context.restore()
		}

		var drawRect = function( dx, dy, dw, dh, lineWidth ) {
			if( !lineWidth ) lineWidth = 1

			context.save()
			{
				context.globalAlpha = currentState.opacity

				var modelToWorld = currentState.matrix

				context.transform(
					modelToWorld[ 0 ],
					modelToWorld[ 1 ],
					modelToWorld[ 3 ],
					modelToWorld[ 4 ],
					modelToWorld[ 6 ],
					modelToWorld[ 7 ]
				)

				context.lineWidth = pixelScale * lineWidth
			    context.strokeRect( dx, dy, dw, dh )
			}
			context.restore()
		}

		var drawCircle = function( dx, dy, radius, lineWidth ) {
			if( !lineWidth ) lineWidth = 1

			context.save()
			{
				context.globalAlpha = currentState.opacity

				var modelToWorld = currentState.matrix

				context.transform(
					modelToWorld[ 0 ],
					modelToWorld[ 1 ],
					modelToWorld[ 3 ],
					modelToWorld[ 4 ],
					modelToWorld[ 6 ],
					modelToWorld[ 7 ]
				)

				context.lineWidth = pixelScale * lineWidth
				context.beginPath()
				context.arc( dx, dy, radius, 0, Math.PI * 2, true )
				context.stroke()
			}
			context.restore()
		}

		var drawLine = function( ax, ay, bx, by, lineWidth ) {
			if( !lineWidth ) lineWidth = 1

			context.save()
			{
				context.globalAlpha = currentState.opacity

				var modelToWorld = currentState.matrix

				context.transform(
					modelToWorld[ 0 ],
					modelToWorld[ 1 ],
					modelToWorld[ 3 ],
					modelToWorld[ 4 ],
					modelToWorld[ 6 ],
					modelToWorld[ 7 ]
				)

				var scaledLineWidth = pixelScale * lineWidth

				context.lineWidth = scaledLineWidth

				context.beginPath()
				context.moveTo( ax, ay )
				context.lineTo( bx, by )
				context.stroke()
			}
			context.restore()
		}

		var fillRect = function( dx, dy, dw, dh ) {
			context.save()
			{
				context.globalAlpha = currentState.opacity

				var modelToWorld = currentState.matrix

				context.transform(
					modelToWorld[ 0 ],
					modelToWorld[ 1 ],
					modelToWorld[ 3 ],
					modelToWorld[ 4 ],
					modelToWorld[ 6 ],
					modelToWorld[ 7 ]
				)

				// rotating the image so that it is not upside down
				context.translate( dx, dy )
				context.rotate( Math.PI )
				context.scale( -1.0, 1.0 )
				context.translate( 0.0, -dh )

				context.fillRect( 0.0, 0.0, dw, dh )
			}
			context.restore()
		}

		var resizeColorBuffer = function( width, height ) {
			canvas.width  = width
			canvas.height = height
		}

		var transform = function( matrix ) {
			mat3.multiply( matrix, currentState.matrix )
		}

		var setTransform = function( matrix ) {
			mat3.copy( currentState.matrix, matrix )
		}

		var setViewMatrix = function( matrix ) {
			mat3.copy( currentState.viewMatrix, matrix )
			mat3.copy( worldToView, matrix )

			updateWorldToScreen( viewToScreen, worldToView )
		}

		var viewport = function( x, y, width, height ) {
			mat3.identity( viewToScreen )

			viewToScreen[ 0 ] = width * 0.5
			viewToScreen[ 4 ] = height * 0.5 * -1 // mirroring y-axis
			viewToScreen[ 6 ] = x + width * 0.5
			viewToScreen[ 7 ] = y + height * 0.5

			updateWorldToScreen( viewToScreen, worldToView )

			if( !isFullscreenCovered( x, y, width, height ) ) {
				setClippingRegion( x, y, width, height )
			}
		}

		/*
		 * Returns an object describing the current configuration of the rendering backend.
		 */
		var getConfiguration = function() {
			return {
				type   : 'canvas-2d',
				width  : canvas.width,
				height : canvas.height,
				info   : ''
			}
		}

		/*
		 * Returns instance of texture class
		 *
		 * The public interface of the texture class consists of the two attributes width and height.
		 *
		 * @param image
		 */
		var createCanvasTexture = function( image ) {
			return {
				/*
				 * Public
				 */
				dimensions : [ image.width, image.height ],

				/*
				 * Private
				 *
				 * This is an implementation detail of the class. If you write code that depends on this you better know what you are doing.
				 */
				privateImageResource : image
			}
		}

		return createCanvasContext
	}
)

define(
	'spell/shared/util/platform/private/graphics/RenderingFactory',
	[
		'spell/shared/util/platform/private/graphics/canvas/createCanvasContext',
		'spell/shared/util/platform/private/graphics/webgl/createWebGlContext',
		'spell/shared/util/platform/private/graphics/createCanvasNode'
	],
	function(
		createCanvasContext,
		createWebGlContext,
		createCanvasNode
	) {
		'use strict'


		var BACK_END_CANVAS = 'canvas-2d',
			BACK_END_WEBGL  = 'webgl'

		/*
		 * Creates a rendering context
		 *
         * @param eventManager - Eventmanager
		 * @param id - the id of the dom node the engine instance is placed in
		 * @param width - width in pixels
		 * @param height - height in pixels
		 * @param requestedBackEnd - when supplied, overrides the automagic rendering back-end detection
		 */
		var createContext2d = function( eventManager, id, width, height, requestedBackEnd ) {
			var canvas = createCanvasNode( id, width, height ),
				context

			if( canvas === null || canvas === undefined ) throw 'Could not create canvas node.'

			// webgl
			if( requestedBackEnd === undefined ? true : ( requestedBackEnd === BACK_END_WEBGL ) ) {
				context = createWebGlContext( canvas )

				if( context ) return context
			}

			// canvas-2d
			if( requestedBackEnd === undefined ? true : ( requestedBackEnd === BACK_END_CANVAS ) ) {
				// HACK: disable default canvas scaling behaviour on html5-ejecta
				if( canvas.scalingMode ) {
					canvas.scalingMode = 'none'
				}

				context = createCanvasContext( canvas )

				if( context ) return context
			}

			throw 'Could not create a rendering back-end.'
		}

		return {
			BACK_END_WEBGL : BACK_END_WEBGL,
			BACK_END_CANVAS : BACK_END_CANVAS,
			createContext2d : createContext2d
		}
	}
)

define(
	'spell/shared/util/platform/private/configurationOptions',
	[
		'spell/shared/util/platform/private/graphics/RenderingFactory',
		'spell/shared/util/platform/private/sound/AudioFactory'
	],
	function(
		RenderingFactory,
		AudioFactory
	) {
		'use strict'


		/*
		 * These are the platform specific options.
		 */
		var validOptions = {
			renderingBackEnd : {
				validValues  : [
					RenderingFactory.BACK_END_CANVAS,
					RenderingFactory.BACK_END_WEBGL
				],
				configurable : true
			},
			audioBackEnd : {
				validValues  : [
					AudioFactory.BACK_END_DUMMY_AUDIO,
					AudioFactory.BACK_END_WEB_AUDIO,
					AudioFactory.BACK_END_HTML5_AUDIO,
					AudioFactory.BACK_END_NATIVE_AUDIO
				],
				configurable : true
			},
			libraryUrl : {
				configurable : true
			}
		}

		/*
		 * These options are used when they are not overridden by the environment configuration set up by the stage-0-loader.
		 */
		var defaultOptions = {
			renderingBackEnd : 'canvas-2d',
			audioBackEnd : 'html5',
			libraryUrl : 'library'
		}

		return {
			defaultOptions : defaultOptions,
			validOptions   : validOptions
		}
	}
)

define(
	"spell/shared/util/platform/private/callNextFrame",
	[
		"spell/shared/util/platform/private/registerTimer"
	],
	function(
		registerTimer
	) {
		"use strict";


		// running in node context
		if( typeof window === "undefined" ) {
			return function( callback ) {
				registerTimer( callback, 5 )
			}
		}


		// running in browser
		var browserCallback = (
			window.requestAnimationFrame       ||
			window.webkitRequestAnimationFrame ||
			window.mozRequestAnimationFrame    ||
			window.oRequestAnimationFrame      ||
			window.msRequestAnimationFrame
		)

		var hasBrowserSupport = !!browserCallback

		if( hasBrowserSupport ) {
			return function( callback ) {
				browserCallback.call( window, callback )
			}
		}


		// no browser support
		return function( callback ) {
			registerTimer(
				function() {
					callback( new Date() )
				},
				1000 / 60 // 60 Hz
			)
		}
	}
)

/**
 * @license
 * @preserve
 *
 * Box2D
 * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
 *
 * This software is provided 'as-is', without any express or implied
 * warranty.  In no event will the authors be held liable for any damages
 * arising from the use of this software.
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 * 1. The origin of this software must not be misrepresented; you must not
 * claim that you wrote the original software. If you use this software
 * in a product, an acknowledgment in the product documentation would be
 * appreciated but is not required.
 * 2. Altered source versions must be plainly marked as such, and must not be
 * misrepresented as being the original software.
 * 3. This notice may not be removed or altered from any source distribution.
 */
define(
	'spell/shared/util/platform/private/Box2D',
	function() {

var FLOAT_EPSILON = 0.000001;

var Box2D = {};

(function (a2j, undefined) {

   if(!(Object.prototype.defineProperty instanceof Function)
      && Object.prototype.__defineGetter__ instanceof Function
      && Object.prototype.__defineSetter__ instanceof Function)
   {
      Object.defineProperty = function(obj, p, cfg) {
         if(cfg.get instanceof Function)
            obj.__defineGetter__(p, cfg.get);
         if(cfg.set instanceof Function)
            obj.__defineSetter__(p, cfg.set);
      }
   }

   function emptyFn() {};
   a2j.inherit = function(cls, base) {
      var tmpCtr = cls;
      emptyFn.prototype = base.prototype;
      cls.prototype = new emptyFn;
      cls.prototype.constructor = tmpCtr;
   };

   a2j.generateCallback = function generateCallback(context, cb) {
      return function () {
         cb.apply(context, arguments);
      };
   };

   a2j.NVector = function NVector(length) {
      if (length === undefined) length = 0;
      var tmp = new Array(length || 0);
      for (var i = 0; i < length; ++i)
      tmp[i] = 0;
      return tmp;
   };

   a2j.is = function is(o1, o2) {
      if (o1 === null) return false;
      if ((o2 instanceof Function) && (o1 instanceof o2)) return true;
      if ((o1.constructor.__implements != undefined) && (o1.constructor.__implements[o2])) return true;
      return false;
   };

   a2j.parseUInt = function(v) {
      return Math.abs(parseInt(v));
   }

})(Box2D);

//#TODO remove assignments from global namespace
var Vector = Array;
var Vector_a2j_Number = Box2D.NVector;
//package structure
if (typeof(Box2D) === "undefined") Box2D = {};
if (typeof(Box2D.Collision) === "undefined") Box2D.Collision = {};
if (typeof(Box2D.Collision.Shapes) === "undefined") Box2D.Collision.Shapes = {};
if (typeof(Box2D.Common) === "undefined") Box2D.Common = {};
if (typeof(Box2D.Common.Math) === "undefined") Box2D.Common.Math = {};
if (typeof(Box2D.Dynamics) === "undefined") Box2D.Dynamics = {};
if (typeof(Box2D.Dynamics.Contacts) === "undefined") Box2D.Dynamics.Contacts = {};
if (typeof(Box2D.Dynamics.Controllers) === "undefined") Box2D.Dynamics.Controllers = {};
if (typeof(Box2D.Dynamics.Joints) === "undefined") Box2D.Dynamics.Joints = {};
//pre-definitions
(function () {
   Box2D.Collision.IBroadPhase = 'Box2D.Collision.IBroadPhase';

   function b2AABB() {
      b2AABB.b2AABB.apply(this, arguments);
   };
   Box2D.Collision.b2AABB = b2AABB;

   function b2Bound() {
      b2Bound.b2Bound.apply(this, arguments);
   };
   Box2D.Collision.b2Bound = b2Bound;

   function b2BoundValues() {
      b2BoundValues.b2BoundValues.apply(this, arguments);
      if (this.constructor === b2BoundValues) this.b2BoundValues.apply(this, arguments);
   };
   Box2D.Collision.b2BoundValues = b2BoundValues;

   function b2Collision() {
      b2Collision.b2Collision.apply(this, arguments);
   };
   Box2D.Collision.b2Collision = b2Collision;

   function b2ContactID() {
      b2ContactID.b2ContactID.apply(this, arguments);
      if (this.constructor === b2ContactID) this.b2ContactID.apply(this, arguments);
   };
   Box2D.Collision.b2ContactID = b2ContactID;

   function b2ContactPoint() {
      b2ContactPoint.b2ContactPoint.apply(this, arguments);
   };
   Box2D.Collision.b2ContactPoint = b2ContactPoint;

   function b2Distance() {
      b2Distance.b2Distance.apply(this, arguments);
   };
   Box2D.Collision.b2Distance = b2Distance;

   function b2DistanceInput() {
      b2DistanceInput.b2DistanceInput.apply(this, arguments);
   };
   Box2D.Collision.b2DistanceInput = b2DistanceInput;

   function b2DistanceOutput() {
      b2DistanceOutput.b2DistanceOutput.apply(this, arguments);
   };
   Box2D.Collision.b2DistanceOutput = b2DistanceOutput;

   function b2DistanceProxy() {
      b2DistanceProxy.b2DistanceProxy.apply(this, arguments);
   };
   Box2D.Collision.b2DistanceProxy = b2DistanceProxy;

   function b2DynamicTree() {
      b2DynamicTree.b2DynamicTree.apply(this, arguments);
      if (this.constructor === b2DynamicTree) this.b2DynamicTree.apply(this, arguments);
   };
   Box2D.Collision.b2DynamicTree = b2DynamicTree;

   function b2DynamicTreeBroadPhase() {
      b2DynamicTreeBroadPhase.b2DynamicTreeBroadPhase.apply(this, arguments);
   };
   Box2D.Collision.b2DynamicTreeBroadPhase = b2DynamicTreeBroadPhase;

   function b2DynamicTreeNode() {
      b2DynamicTreeNode.b2DynamicTreeNode.apply(this, arguments);
   };
   Box2D.Collision.b2DynamicTreeNode = b2DynamicTreeNode;

   function b2DynamicTreePair() {
      b2DynamicTreePair.b2DynamicTreePair.apply(this, arguments);
   };
   Box2D.Collision.b2DynamicTreePair = b2DynamicTreePair;

   function b2Manifold() {
      b2Manifold.b2Manifold.apply(this, arguments);
      if (this.constructor === b2Manifold) this.b2Manifold.apply(this, arguments);
   };
   Box2D.Collision.b2Manifold = b2Manifold;

   function b2ManifoldPoint() {
      b2ManifoldPoint.b2ManifoldPoint.apply(this, arguments);
      if (this.constructor === b2ManifoldPoint) this.b2ManifoldPoint.apply(this, arguments);
   };
   Box2D.Collision.b2ManifoldPoint = b2ManifoldPoint;

   function b2Point() {
      b2Point.b2Point.apply(this, arguments);
   };
   Box2D.Collision.b2Point = b2Point;

   function b2RayCastInput() {
      b2RayCastInput.b2RayCastInput.apply(this, arguments);
      if (this.constructor === b2RayCastInput) this.b2RayCastInput.apply(this, arguments);
   };
   Box2D.Collision.b2RayCastInput = b2RayCastInput;

   function b2RayCastOutput() {
      b2RayCastOutput.b2RayCastOutput.apply(this, arguments);
   };
   Box2D.Collision.b2RayCastOutput = b2RayCastOutput;

   function b2Segment() {
      b2Segment.b2Segment.apply(this, arguments);
   };
   Box2D.Collision.b2Segment = b2Segment;

   function b2SeparationFunction() {
      b2SeparationFunction.b2SeparationFunction.apply(this, arguments);
   };
   Box2D.Collision.b2SeparationFunction = b2SeparationFunction;

   function b2Simplex() {
      b2Simplex.b2Simplex.apply(this, arguments);
      if (this.constructor === b2Simplex) this.b2Simplex.apply(this, arguments);
   };
   Box2D.Collision.b2Simplex = b2Simplex;

   function b2SimplexCache() {
      b2SimplexCache.b2SimplexCache.apply(this, arguments);
   };
   Box2D.Collision.b2SimplexCache = b2SimplexCache;

   function b2SimplexVertex() {
      b2SimplexVertex.b2SimplexVertex.apply(this, arguments);
   };
   Box2D.Collision.b2SimplexVertex = b2SimplexVertex;

   function b2TimeOfImpact() {
      b2TimeOfImpact.b2TimeOfImpact.apply(this, arguments);
   };
   Box2D.Collision.b2TimeOfImpact = b2TimeOfImpact;

   function b2TOIInput() {
      b2TOIInput.b2TOIInput.apply(this, arguments);
   };
   Box2D.Collision.b2TOIInput = b2TOIInput;

   function b2WorldManifold() {
      b2WorldManifold.b2WorldManifold.apply(this, arguments);
      if (this.constructor === b2WorldManifold) this.b2WorldManifold.apply(this, arguments);
   };
   Box2D.Collision.b2WorldManifold = b2WorldManifold;

   function ClipVertex() {
      ClipVertex.ClipVertex.apply(this, arguments);
   };
   Box2D.Collision.ClipVertex = ClipVertex;

   function Features() {
      Features.Features.apply(this, arguments);
   };
   Box2D.Collision.Features = Features;

   function b2CircleShape() {
      b2CircleShape.b2CircleShape.apply(this, arguments);
      if (this.constructor === b2CircleShape) this.b2CircleShape.apply(this, arguments);
   };
   Box2D.Collision.Shapes.b2CircleShape = b2CircleShape;

   function b2EdgeChainDef() {
      b2EdgeChainDef.b2EdgeChainDef.apply(this, arguments);
      if (this.constructor === b2EdgeChainDef) this.b2EdgeChainDef.apply(this, arguments);
   };
   Box2D.Collision.Shapes.b2EdgeChainDef = b2EdgeChainDef;

   function b2EdgeShape() {
      b2EdgeShape.b2EdgeShape.apply(this, arguments);
      if (this.constructor === b2EdgeShape) this.b2EdgeShape.apply(this, arguments);
   };
   Box2D.Collision.Shapes.b2EdgeShape = b2EdgeShape;

   function b2MassData() {
      b2MassData.b2MassData.apply(this, arguments);
   };
   Box2D.Collision.Shapes.b2MassData = b2MassData;

   function b2PolygonShape() {
      b2PolygonShape.b2PolygonShape.apply(this, arguments);
      if (this.constructor === b2PolygonShape) this.b2PolygonShape.apply(this, arguments);
   };
   Box2D.Collision.Shapes.b2PolygonShape = b2PolygonShape;

   function b2Shape() {
      b2Shape.b2Shape.apply(this, arguments);
      if (this.constructor === b2Shape) this.b2Shape.apply(this, arguments);
   };
   Box2D.Collision.Shapes.b2Shape = b2Shape;
   Box2D.Common.b2internal = 'Box2D.Common.b2internal';

   function b2Color() {
      b2Color.b2Color.apply(this, arguments);
      if (this.constructor === b2Color) this.b2Color.apply(this, arguments);
   };
   Box2D.Common.b2Color = b2Color;

   function b2Settings() {
      b2Settings.b2Settings.apply(this, arguments);
   };
   Box2D.Common.b2Settings = b2Settings;

   function b2Mat22() {
      b2Mat22.b2Mat22.apply(this, arguments);
      if (this.constructor === b2Mat22) this.b2Mat22.apply(this, arguments);
   };
   Box2D.Common.Math.b2Mat22 = b2Mat22;

   function b2Mat33() {
      b2Mat33.b2Mat33.apply(this, arguments);
      if (this.constructor === b2Mat33) this.b2Mat33.apply(this, arguments);
   };
   Box2D.Common.Math.b2Mat33 = b2Mat33;

   function b2Math() {
      b2Math.b2Math.apply(this, arguments);
   };
   Box2D.Common.Math.b2Math = b2Math;

   function b2Sweep() {
      b2Sweep.b2Sweep.apply(this, arguments);
   };
   Box2D.Common.Math.b2Sweep = b2Sweep;

   function b2Transform() {
      b2Transform.b2Transform.apply(this, arguments);
      if (this.constructor === b2Transform) this.b2Transform.apply(this, arguments);
   };
   Box2D.Common.Math.b2Transform = b2Transform;

   function b2Vec2() {
      b2Vec2.b2Vec2.apply(this, arguments);
      if (this.constructor === b2Vec2) this.b2Vec2.apply(this, arguments);
   };
   Box2D.Common.Math.b2Vec2 = b2Vec2;

   function b2Vec3() {
      b2Vec3.b2Vec3.apply(this, arguments);
      if (this.constructor === b2Vec3) this.b2Vec3.apply(this, arguments);
   };
   Box2D.Common.Math.b2Vec3 = b2Vec3;

   function b2Body() {
      b2Body.b2Body.apply(this, arguments);
      if (this.constructor === b2Body) this.b2Body.apply(this, arguments);
   };
   Box2D.Dynamics.b2Body = b2Body;

   function b2BodyDef() {
      b2BodyDef.b2BodyDef.apply(this, arguments);
      if (this.constructor === b2BodyDef) this.b2BodyDef.apply(this, arguments);
   };
   Box2D.Dynamics.b2BodyDef = b2BodyDef;

   function b2ContactFilter() {
      b2ContactFilter.b2ContactFilter.apply(this, arguments);
   };
   Box2D.Dynamics.b2ContactFilter = b2ContactFilter;

   function b2ContactImpulse() {
      b2ContactImpulse.b2ContactImpulse.apply(this, arguments);
   };
   Box2D.Dynamics.b2ContactImpulse = b2ContactImpulse;

   function b2ContactListener() {
      b2ContactListener.b2ContactListener.apply(this, arguments);
   };
   Box2D.Dynamics.b2ContactListener = b2ContactListener;

   function b2ContactManager() {
      b2ContactManager.b2ContactManager.apply(this, arguments);
      if (this.constructor === b2ContactManager) this.b2ContactManager.apply(this, arguments);
   };
   Box2D.Dynamics.b2ContactManager = b2ContactManager;

   function b2DebugDraw() {
      b2DebugDraw.b2DebugDraw.apply(this, arguments);
      if (this.constructor === b2DebugDraw) this.b2DebugDraw.apply(this, arguments);
   };
   Box2D.Dynamics.b2DebugDraw = b2DebugDraw;

   function b2DestructionListener() {
      b2DestructionListener.b2DestructionListener.apply(this, arguments);
   };
   Box2D.Dynamics.b2DestructionListener = b2DestructionListener;

   function b2FilterData() {
      b2FilterData.b2FilterData.apply(this, arguments);
   };
   Box2D.Dynamics.b2FilterData = b2FilterData;

   function b2Fixture() {
      b2Fixture.b2Fixture.apply(this, arguments);
      if (this.constructor === b2Fixture) this.b2Fixture.apply(this, arguments);
   };
   Box2D.Dynamics.b2Fixture = b2Fixture;

   function b2FixtureDef() {
      b2FixtureDef.b2FixtureDef.apply(this, arguments);
      if (this.constructor === b2FixtureDef) this.b2FixtureDef.apply(this, arguments);
   };
   Box2D.Dynamics.b2FixtureDef = b2FixtureDef;

   function b2Island() {
      b2Island.b2Island.apply(this, arguments);
      if (this.constructor === b2Island) this.b2Island.apply(this, arguments);
   };
   Box2D.Dynamics.b2Island = b2Island;

   function b2TimeStep() {
      b2TimeStep.b2TimeStep.apply(this, arguments);
   };
   Box2D.Dynamics.b2TimeStep = b2TimeStep;

   function b2World() {
      b2World.b2World.apply(this, arguments);
      if (this.constructor === b2World) this.b2World.apply(this, arguments);
   };
   Box2D.Dynamics.b2World = b2World;

   function b2CircleContact() {
      b2CircleContact.b2CircleContact.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2CircleContact = b2CircleContact;

   function b2Contact() {
      b2Contact.b2Contact.apply(this, arguments);
      if (this.constructor === b2Contact) this.b2Contact.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2Contact = b2Contact;

   function b2ContactConstraint() {
      b2ContactConstraint.b2ContactConstraint.apply(this, arguments);
      if (this.constructor === b2ContactConstraint) this.b2ContactConstraint.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2ContactConstraint = b2ContactConstraint;

   function b2ContactConstraintPoint() {
      b2ContactConstraintPoint.b2ContactConstraintPoint.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2ContactConstraintPoint = b2ContactConstraintPoint;

   function b2ContactEdge() {
      b2ContactEdge.b2ContactEdge.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2ContactEdge = b2ContactEdge;

   function b2ContactFactory() {
      b2ContactFactory.b2ContactFactory.apply(this, arguments);
      if (this.constructor === b2ContactFactory) this.b2ContactFactory.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2ContactFactory = b2ContactFactory;

   function b2ContactRegister() {
      b2ContactRegister.b2ContactRegister.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2ContactRegister = b2ContactRegister;

   function b2ContactResult() {
      b2ContactResult.b2ContactResult.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2ContactResult = b2ContactResult;

   function b2ContactSolver() {
      b2ContactSolver.b2ContactSolver.apply(this, arguments);
      if (this.constructor === b2ContactSolver) this.b2ContactSolver.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2ContactSolver = b2ContactSolver;

   function b2EdgeAndCircleContact() {
      b2EdgeAndCircleContact.b2EdgeAndCircleContact.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2EdgeAndCircleContact = b2EdgeAndCircleContact;

   function b2NullContact() {
      b2NullContact.b2NullContact.apply(this, arguments);
      if (this.constructor === b2NullContact) this.b2NullContact.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2NullContact = b2NullContact;

   function b2PolyAndCircleContact() {
      b2PolyAndCircleContact.b2PolyAndCircleContact.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2PolyAndCircleContact = b2PolyAndCircleContact;

   function b2PolyAndEdgeContact() {
      b2PolyAndEdgeContact.b2PolyAndEdgeContact.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2PolyAndEdgeContact = b2PolyAndEdgeContact;

   function b2PolygonContact() {
      b2PolygonContact.b2PolygonContact.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2PolygonContact = b2PolygonContact;

   function b2PositionSolverManifold() {
      b2PositionSolverManifold.b2PositionSolverManifold.apply(this, arguments);
      if (this.constructor === b2PositionSolverManifold) this.b2PositionSolverManifold.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2PositionSolverManifold = b2PositionSolverManifold;

   function b2BuoyancyController() {
      b2BuoyancyController.b2BuoyancyController.apply(this, arguments);
   };
   Box2D.Dynamics.Controllers.b2BuoyancyController = b2BuoyancyController;

   function b2ConstantAccelController() {
      b2ConstantAccelController.b2ConstantAccelController.apply(this, arguments);
   };
   Box2D.Dynamics.Controllers.b2ConstantAccelController = b2ConstantAccelController;

   function b2ConstantForceController() {
      b2ConstantForceController.b2ConstantForceController.apply(this, arguments);
   };
   Box2D.Dynamics.Controllers.b2ConstantForceController = b2ConstantForceController;

   function b2Controller() {
      b2Controller.b2Controller.apply(this, arguments);
   };
   Box2D.Dynamics.Controllers.b2Controller = b2Controller;

   function b2ControllerEdge() {
      b2ControllerEdge.b2ControllerEdge.apply(this, arguments);
   };
   Box2D.Dynamics.Controllers.b2ControllerEdge = b2ControllerEdge;

   function b2GravityController() {
      b2GravityController.b2GravityController.apply(this, arguments);
   };
   Box2D.Dynamics.Controllers.b2GravityController = b2GravityController;

   function b2TensorDampingController() {
      b2TensorDampingController.b2TensorDampingController.apply(this, arguments);
   };
   Box2D.Dynamics.Controllers.b2TensorDampingController = b2TensorDampingController;

   function b2DistanceJoint() {
      b2DistanceJoint.b2DistanceJoint.apply(this, arguments);
      if (this.constructor === b2DistanceJoint) this.b2DistanceJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2DistanceJoint = b2DistanceJoint;

   function b2DistanceJointDef() {
      b2DistanceJointDef.b2DistanceJointDef.apply(this, arguments);
      if (this.constructor === b2DistanceJointDef) this.b2DistanceJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2DistanceJointDef = b2DistanceJointDef;

   function b2FrictionJoint() {
      b2FrictionJoint.b2FrictionJoint.apply(this, arguments);
      if (this.constructor === b2FrictionJoint) this.b2FrictionJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2FrictionJoint = b2FrictionJoint;

   function b2FrictionJointDef() {
      b2FrictionJointDef.b2FrictionJointDef.apply(this, arguments);
      if (this.constructor === b2FrictionJointDef) this.b2FrictionJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2FrictionJointDef = b2FrictionJointDef;

   function b2GearJoint() {
      b2GearJoint.b2GearJoint.apply(this, arguments);
      if (this.constructor === b2GearJoint) this.b2GearJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2GearJoint = b2GearJoint;

   function b2GearJointDef() {
      b2GearJointDef.b2GearJointDef.apply(this, arguments);
      if (this.constructor === b2GearJointDef) this.b2GearJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2GearJointDef = b2GearJointDef;

   function b2Jacobian() {
      b2Jacobian.b2Jacobian.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2Jacobian = b2Jacobian;

   function b2Joint() {
      b2Joint.b2Joint.apply(this, arguments);
      if (this.constructor === b2Joint) this.b2Joint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2Joint = b2Joint;

   function b2JointDef() {
      b2JointDef.b2JointDef.apply(this, arguments);
      if (this.constructor === b2JointDef) this.b2JointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2JointDef = b2JointDef;

   function b2JointEdge() {
      b2JointEdge.b2JointEdge.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2JointEdge = b2JointEdge;

   function b2LineJoint() {
      b2LineJoint.b2LineJoint.apply(this, arguments);
      if (this.constructor === b2LineJoint) this.b2LineJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2LineJoint = b2LineJoint;

   function b2LineJointDef() {
      b2LineJointDef.b2LineJointDef.apply(this, arguments);
      if (this.constructor === b2LineJointDef) this.b2LineJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2LineJointDef = b2LineJointDef;

   function b2MouseJoint() {
      b2MouseJoint.b2MouseJoint.apply(this, arguments);
      if (this.constructor === b2MouseJoint) this.b2MouseJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2MouseJoint = b2MouseJoint;

   function b2MouseJointDef() {
      b2MouseJointDef.b2MouseJointDef.apply(this, arguments);
      if (this.constructor === b2MouseJointDef) this.b2MouseJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2MouseJointDef = b2MouseJointDef;

   function b2PrismaticJoint() {
      b2PrismaticJoint.b2PrismaticJoint.apply(this, arguments);
      if (this.constructor === b2PrismaticJoint) this.b2PrismaticJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2PrismaticJoint = b2PrismaticJoint;

   function b2PrismaticJointDef() {
      b2PrismaticJointDef.b2PrismaticJointDef.apply(this, arguments);
      if (this.constructor === b2PrismaticJointDef) this.b2PrismaticJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2PrismaticJointDef = b2PrismaticJointDef;

   function b2PulleyJoint() {
      b2PulleyJoint.b2PulleyJoint.apply(this, arguments);
      if (this.constructor === b2PulleyJoint) this.b2PulleyJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2PulleyJoint = b2PulleyJoint;

   function b2PulleyJointDef() {
      b2PulleyJointDef.b2PulleyJointDef.apply(this, arguments);
      if (this.constructor === b2PulleyJointDef) this.b2PulleyJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2PulleyJointDef = b2PulleyJointDef;

   function b2RevoluteJoint() {
      b2RevoluteJoint.b2RevoluteJoint.apply(this, arguments);
      if (this.constructor === b2RevoluteJoint) this.b2RevoluteJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2RevoluteJoint = b2RevoluteJoint;

   function b2RevoluteJointDef() {
      b2RevoluteJointDef.b2RevoluteJointDef.apply(this, arguments);
      if (this.constructor === b2RevoluteJointDef) this.b2RevoluteJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2RevoluteJointDef = b2RevoluteJointDef;

   function b2WeldJoint() {
      b2WeldJoint.b2WeldJoint.apply(this, arguments);
      if (this.constructor === b2WeldJoint) this.b2WeldJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2WeldJoint = b2WeldJoint;

   function b2WeldJointDef() {
      b2WeldJointDef.b2WeldJointDef.apply(this, arguments);
      if (this.constructor === b2WeldJointDef) this.b2WeldJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2WeldJointDef = b2WeldJointDef;
})(); //definitions
Box2D.postDefs = [];
(function () {
   var b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
      b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
      b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
      b2MassData = Box2D.Collision.Shapes.b2MassData,
      b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
      b2Shape = Box2D.Collision.Shapes.b2Shape,
      b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3,
      b2AABB = Box2D.Collision.b2AABB,
      b2Bound = Box2D.Collision.b2Bound,
      b2BoundValues = Box2D.Collision.b2BoundValues,
      b2Collision = Box2D.Collision.b2Collision,
      b2ContactID = Box2D.Collision.b2ContactID,
      b2ContactPoint = Box2D.Collision.b2ContactPoint,
      b2Distance = Box2D.Collision.b2Distance,
      b2DistanceInput = Box2D.Collision.b2DistanceInput,
      b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
      b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
      b2DynamicTree = Box2D.Collision.b2DynamicTree,
      b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
      b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
      b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
      b2Manifold = Box2D.Collision.b2Manifold,
      b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
      b2Point = Box2D.Collision.b2Point,
      b2RayCastInput = Box2D.Collision.b2RayCastInput,
      b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
      b2Segment = Box2D.Collision.b2Segment,
      b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
      b2Simplex = Box2D.Collision.b2Simplex,
      b2SimplexCache = Box2D.Collision.b2SimplexCache,
      b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
      b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
      b2TOIInput = Box2D.Collision.b2TOIInput,
      b2WorldManifold = Box2D.Collision.b2WorldManifold,
      ClipVertex = Box2D.Collision.ClipVertex,
      Features = Box2D.Collision.Features,
      IBroadPhase = Box2D.Collision.IBroadPhase;

   b2AABB.b2AABB = function () {
      this.lowerBound = new b2Vec2();
      this.upperBound = new b2Vec2();
   };
   b2AABB.prototype.IsValid = function () {
      var dX = this.upperBound.x - this.lowerBound.x;
      var dY = this.upperBound.y - this.lowerBound.y;
      var valid = dX >= 0.0 && dY >= 0.0;
      valid = valid && this.lowerBound.IsValid() && this.upperBound.IsValid();
      return valid;
   }
   b2AABB.prototype.GetCenter = function () {
      return new b2Vec2((this.lowerBound.x + this.upperBound.x) / 2, (this.lowerBound.y + this.upperBound.y) / 2);
   }
   b2AABB.prototype.GetExtents = function () {
      return new b2Vec2((this.upperBound.x - this.lowerBound.x) / 2, (this.upperBound.y - this.lowerBound.y) / 2);
   }
   b2AABB.prototype.Contains = function (aabb) {
      var result = true;
      result = result && this.lowerBound.x <= aabb.lowerBound.x;
      result = result && this.lowerBound.y <= aabb.lowerBound.y;
      result = result && aabb.upperBound.x <= this.upperBound.x;
      result = result && aabb.upperBound.y <= this.upperBound.y;
      return result;
   }
   b2AABB.prototype.RayCast = function (output, input) {
      var tmin = (-Number.MAX_VALUE);
      var tmax = Number.MAX_VALUE;
      var pX = input.p1.x;
      var pY = input.p1.y;
      var dX = input.p2.x - input.p1.x;
      var dY = input.p2.y - input.p1.y;
      var absDX = Math.abs(dX);
      var absDY = Math.abs(dY);
      var normal = output.normal;
      var inv_d = 0;
      var t1 = 0;
      var t2 = 0;
      var t3 = 0;
      var s = 0; {
         if (absDX < FLOAT_EPSILON) {
            if (pX < this.lowerBound.x || this.upperBound.x < pX) return false;
         }
         else {
            inv_d = 1.0 / dX;
            t1 = (this.lowerBound.x - pX) * inv_d;
            t2 = (this.upperBound.x - pX) * inv_d;
            s = (-1.0);
            if (t1 > t2) {
               t3 = t1;
               t1 = t2;
               t2 = t3;
               s = 1.0;
            }
            if (t1 > tmin) {
               normal.x = s;
               normal.y = 0;
               tmin = t1;
            }
            tmax = Math.min(tmax, t2);
            if (tmin > tmax) return false;
         }
      } {
         if (absDY < FLOAT_EPSILON) {
            if (pY < this.lowerBound.y || this.upperBound.y < pY) return false;
         }
         else {
            inv_d = 1.0 / dY;
            t1 = (this.lowerBound.y - pY) * inv_d;
            t2 = (this.upperBound.y - pY) * inv_d;
            s = (-1.0);
            if (t1 > t2) {
               t3 = t1;
               t1 = t2;
               t2 = t3;
               s = 1.0;
            }
            if (t1 > tmin) {
               normal.y = s;
               normal.x = 0;
               tmin = t1;
            }
            tmax = Math.min(tmax, t2);
            if (tmin > tmax) return false;
         }
      }
      output.fraction = tmin;
      return true;
   }
   b2AABB.prototype.TestOverlap = function (other) {
      var d1X = other.lowerBound.x - this.upperBound.x;
      var d1Y = other.lowerBound.y - this.upperBound.y;
      var d2X = this.lowerBound.x - other.upperBound.x;
      var d2Y = this.lowerBound.y - other.upperBound.y;
      if (d1X > 0.0 || d1Y > 0.0) return false;
      if (d2X > 0.0 || d2Y > 0.0) return false;
      return true;
   }
   b2AABB.Combine = function (aabb1, aabb2) {
      var aabb = new b2AABB();
      aabb.Combine(aabb1, aabb2);
      return aabb;
   }
   b2AABB.prototype.Combine = function (aabb1, aabb2) {
      this.lowerBound.x = Math.min(aabb1.lowerBound.x, aabb2.lowerBound.x);
      this.lowerBound.y = Math.min(aabb1.lowerBound.y, aabb2.lowerBound.y);
      this.upperBound.x = Math.max(aabb1.upperBound.x, aabb2.upperBound.x);
      this.upperBound.y = Math.max(aabb1.upperBound.y, aabb2.upperBound.y);
   }
   b2Bound.b2Bound = function () {};
   b2Bound.prototype.IsLower = function () {
      return (this.value & 1) == 0;
   }
   b2Bound.prototype.IsUpper = function () {
      return (this.value & 1) == 1;
   }
   b2Bound.prototype.Swap = function (b) {
      var tempValue = this.value;
      var tempProxy = this.proxy;
      var tempStabbingCount = this.stabbingCount;
      this.value = b.value;
      this.proxy = b.proxy;
      this.stabbingCount = b.stabbingCount;
      b.value = tempValue;
      b.proxy = tempProxy;
      b.stabbingCount = tempStabbingCount;
   }
   b2BoundValues.b2BoundValues = function () {};
   b2BoundValues.prototype.b2BoundValues = function () {
      this.lowerValues = new Vector_a2j_Number();
      this.lowerValues[0] = 0.0;
      this.lowerValues[1] = 0.0;
      this.upperValues = new Vector_a2j_Number();
      this.upperValues[0] = 0.0;
      this.upperValues[1] = 0.0;
   }
   b2Collision.b2Collision = function () {};
   b2Collision.ClipSegmentToLine = function (vOut, vIn, normal, offset) {
      if (offset === undefined) offset = 0;
      var cv;
      var numOut = 0;
      cv = vIn[0];
      var vIn0 = cv.v;
      cv = vIn[1];
      var vIn1 = cv.v;
      var distance0 = normal.x * vIn0.x + normal.y * vIn0.y - offset;
      var distance1 = normal.x * vIn1.x + normal.y * vIn1.y - offset;
      if (distance0 <= 0.0) vOut[numOut++].Set(vIn[0]);
      if (distance1 <= 0.0) vOut[numOut++].Set(vIn[1]);
      if (distance0 * distance1 < 0.0) {
         var interp = distance0 / (distance0 - distance1);
         cv = vOut[numOut];
         var tVec = cv.v;
         tVec.x = vIn0.x + interp * (vIn1.x - vIn0.x);
         tVec.y = vIn0.y + interp * (vIn1.y - vIn0.y);
         cv = vOut[numOut];
         var cv2;
         if (distance0 > 0.0) {
            cv2 = vIn[0];
            cv.id = cv2.id;
         }
         else {
            cv2 = vIn[1];
            cv.id = cv2.id;
         }++numOut;
      }
      return numOut;
   }
   b2Collision.EdgeSeparation = function (poly1, xf1, edge1, poly2, xf2) {
      if (edge1 === undefined) edge1 = 0;
      var count1 = parseInt(poly1.m_vertexCount);
      var vertices1 = poly1.m_vertices;
      var normals1 = poly1.m_normals;
      var count2 = parseInt(poly2.m_vertexCount);
      var vertices2 = poly2.m_vertices;
      var tMat;
      var tVec;
      tMat = xf1.R;
      tVec = normals1[edge1];
      var normal1WorldX = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var normal1WorldY = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tMat = xf2.R;
      var normal1X = (tMat.col1.x * normal1WorldX + tMat.col1.y * normal1WorldY);
      var normal1Y = (tMat.col2.x * normal1WorldX + tMat.col2.y * normal1WorldY);
      var index = 0;
      var minDot = Number.MAX_VALUE;
      for (var i = 0; i < count2; ++i) {
         tVec = vertices2[i];
         var dot = tVec.x * normal1X + tVec.y * normal1Y;
         if (dot < minDot) {
            minDot = dot;
            index = i;
         }
      }
      tVec = vertices1[edge1];
      tMat = xf1.R;
      var v1X = xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var v1Y = xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tVec = vertices2[index];
      tMat = xf2.R;
      var v2X = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var v2Y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      v2X -= v1X;
      v2Y -= v1Y;
      var separation = v2X * normal1WorldX + v2Y * normal1WorldY;
      return separation;
   }
   b2Collision.FindMaxSeparation = function (edgeIndex, poly1, xf1, poly2, xf2) {
      var count1 = parseInt(poly1.m_vertexCount);
      var normals1 = poly1.m_normals;
      var tVec;
      var tMat;
      tMat = xf2.R;
      tVec = poly2.m_centroid;
      var dX = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var dY = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tMat = xf1.R;
      tVec = poly1.m_centroid;
      dX -= xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      dY -= xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      var dLocal1X = (dX * xf1.R.col1.x + dY * xf1.R.col1.y);
      var dLocal1Y = (dX * xf1.R.col2.x + dY * xf1.R.col2.y);
      var edge = 0;
      var maxDot = (-Number.MAX_VALUE);
      for (var i = 0; i < count1; ++i) {
         tVec = normals1[i];
         var dot = (tVec.x * dLocal1X + tVec.y * dLocal1Y);
         if (dot > maxDot) {
            maxDot = dot;
            edge = i;
         }
      }
      var s = b2Collision.EdgeSeparation(poly1, xf1, edge, poly2, xf2);
      var prevEdge = parseInt(edge - 1 >= 0 ? edge - 1 : count1 - 1);
      var sPrev = b2Collision.EdgeSeparation(poly1, xf1, prevEdge, poly2, xf2);
      var nextEdge = parseInt(edge + 1 < count1 ? edge + 1 : 0);
      var sNext = b2Collision.EdgeSeparation(poly1, xf1, nextEdge, poly2, xf2);
      var bestEdge = 0;
      var bestSeparation = 0;
      var increment = 0;
      if (sPrev > s && sPrev > sNext) {
         increment = (-1);
         bestEdge = prevEdge;
         bestSeparation = sPrev;
      }
      else if (sNext > s) {
         increment = 1;
         bestEdge = nextEdge;
         bestSeparation = sNext;
      }
      else {
         edgeIndex[0] = edge;
         return s;
      }
      while (true) {
         if (increment == (-1)) edge = bestEdge - 1 >= 0 ? bestEdge - 1 : count1 - 1;
         else edge = bestEdge + 1 < count1 ? bestEdge + 1 : 0;s = b2Collision.EdgeSeparation(poly1, xf1, edge, poly2, xf2);
         if (s > bestSeparation) {
            bestEdge = edge;
            bestSeparation = s;
         }
         else {
            break;
         }
      }
      edgeIndex[0] = bestEdge;
      return bestSeparation;
   }
   b2Collision.FindIncidentEdge = function (c, poly1, xf1, edge1, poly2, xf2) {
      if (edge1 === undefined) edge1 = 0;
      var count1 = parseInt(poly1.m_vertexCount);
      var normals1 = poly1.m_normals;
      var count2 = parseInt(poly2.m_vertexCount);
      var vertices2 = poly2.m_vertices;
      var normals2 = poly2.m_normals;
      var tMat;
      var tVec;
      tMat = xf1.R;
      tVec = normals1[edge1];
      var normal1X = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var normal1Y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tMat = xf2.R;
      var tX = (tMat.col1.x * normal1X + tMat.col1.y * normal1Y);
      normal1Y = (tMat.col2.x * normal1X + tMat.col2.y * normal1Y);
      normal1X = tX;
      var index = 0;
      var minDot = Number.MAX_VALUE;
      for (var i = 0; i < count2; ++i) {
         tVec = normals2[i];
         var dot = (normal1X * tVec.x + normal1Y * tVec.y);
         if (dot < minDot) {
            minDot = dot;
            index = i;
         }
      }
      var tClip;
      var i1 = parseInt(index);
      var i2 = parseInt(i1 + 1 < count2 ? i1 + 1 : 0);
      tClip = c[0];
      tVec = vertices2[i1];
      tMat = xf2.R;
      tClip.v.x = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      tClip.v.y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tClip.id.features.referenceEdge = edge1;
      tClip.id.features.incidentEdge = i1;
      tClip.id.features.incidentVertex = 0;
      tClip = c[1];
      tVec = vertices2[i2];
      tMat = xf2.R;
      tClip.v.x = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      tClip.v.y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tClip.id.features.referenceEdge = edge1;
      tClip.id.features.incidentEdge = i2;
      tClip.id.features.incidentVertex = 1;
   }
   b2Collision.MakeClipPointVector = function () {
      var r = new Vector(2);
      r[0] = new ClipVertex();
      r[1] = new ClipVertex();
      return r;
   }
   b2Collision.CollidePolygons = function (manifold, polyA, xfA, polyB, xfB) {
      var cv;
      manifold.m_pointCount = 0;
      var totalRadius = polyA.m_radius + polyB.m_radius;
      var edgeA = 0;
      b2Collision.s_edgeAO[0] = edgeA;
      var separationA = b2Collision.FindMaxSeparation(b2Collision.s_edgeAO, polyA, xfA, polyB, xfB);
      edgeA = b2Collision.s_edgeAO[0];
      if (separationA > totalRadius) return;
      var edgeB = 0;
      b2Collision.s_edgeBO[0] = edgeB;
      var separationB = b2Collision.FindMaxSeparation(b2Collision.s_edgeBO, polyB, xfB, polyA, xfA);
      edgeB = b2Collision.s_edgeBO[0];
      if (separationB > totalRadius) return;
      var poly1;
      var poly2;
      var xf1;
      var xf2;
      var edge1 = 0;
      var flip = 0;
      var k_relativeTol = 0.98;
      var k_absoluteTol = 0.001;
      var tMat;
      if (separationB > k_relativeTol * separationA + k_absoluteTol) {
         poly1 = polyB;
         poly2 = polyA;
         xf1 = xfB;
         xf2 = xfA;
         edge1 = edgeB;
         manifold.m_type = b2Manifold.e_faceB;
         flip = 1;
      }
      else {
         poly1 = polyA;
         poly2 = polyB;
         xf1 = xfA;
         xf2 = xfB;
         edge1 = edgeA;
         manifold.m_type = b2Manifold.e_faceA;
         flip = 0;
      }
      var incidentEdge = b2Collision.s_incidentEdge;
      b2Collision.FindIncidentEdge(incidentEdge, poly1, xf1, edge1, poly2, xf2);
      var count1 = parseInt(poly1.m_vertexCount);
      var vertices1 = poly1.m_vertices;
      var local_v11 = vertices1[edge1];
      var local_v12;
      if (edge1 + 1 < count1) {
         local_v12 = vertices1[parseInt(edge1 + 1)];
      }
      else {
         local_v12 = vertices1[0];
      }
      var localTangent = b2Collision.s_localTangent;
      localTangent.Set(local_v12.x - local_v11.x, local_v12.y - local_v11.y);
      localTangent.Normalize();
      var localNormal = b2Collision.s_localNormal;
      localNormal.x = localTangent.y;
      localNormal.y = (-localTangent.x);
      var planePoint = b2Collision.s_planePoint;
      planePoint.Set(0.5 * (local_v11.x + local_v12.x), 0.5 * (local_v11.y + local_v12.y));
      var tangent = b2Collision.s_tangent;
      tMat = xf1.R;
      tangent.x = (tMat.col1.x * localTangent.x + tMat.col2.x * localTangent.y);
      tangent.y = (tMat.col1.y * localTangent.x + tMat.col2.y * localTangent.y);
      var tangent2 = b2Collision.s_tangent2;
      tangent2.x = (-tangent.x);
      tangent2.y = (-tangent.y);
      var normal = b2Collision.s_normal;
      normal.x = tangent.y;
      normal.y = (-tangent.x);
      var v11 = b2Collision.s_v11;
      var v12 = b2Collision.s_v12;
      v11.x = xf1.position.x + (tMat.col1.x * local_v11.x + tMat.col2.x * local_v11.y);
      v11.y = xf1.position.y + (tMat.col1.y * local_v11.x + tMat.col2.y * local_v11.y);
      v12.x = xf1.position.x + (tMat.col1.x * local_v12.x + tMat.col2.x * local_v12.y);
      v12.y = xf1.position.y + (tMat.col1.y * local_v12.x + tMat.col2.y * local_v12.y);
      var frontOffset = normal.x * v11.x + normal.y * v11.y;
      var sideOffset1 = (-tangent.x * v11.x) - tangent.y * v11.y + totalRadius;
      var sideOffset2 = tangent.x * v12.x + tangent.y * v12.y + totalRadius;
      var clipPoints1 = b2Collision.s_clipPoints1;
      var clipPoints2 = b2Collision.s_clipPoints2;
      var np = 0;
      np = b2Collision.ClipSegmentToLine(clipPoints1, incidentEdge, tangent2, sideOffset1);
      if (np < 2) return;
      np = b2Collision.ClipSegmentToLine(clipPoints2, clipPoints1, tangent, sideOffset2);
      if (np < 2) return;
      manifold.m_localPlaneNormal.SetV(localNormal);
      manifold.m_localPoint.SetV(planePoint);
      var pointCount = 0;
      for (var i = 0; i < b2Settings.b2_maxManifoldPoints; ++i) {
         cv = clipPoints2[i];
         var separation = normal.x * cv.v.x + normal.y * cv.v.y - frontOffset;
         if (separation <= totalRadius) {
            var cp = manifold.m_points[pointCount];
            tMat = xf2.R;
            var tX = cv.v.x - xf2.position.x;
            var tY = cv.v.y - xf2.position.y;
            cp.m_localPoint.x = (tX * tMat.col1.x + tY * tMat.col1.y);
            cp.m_localPoint.y = (tX * tMat.col2.x + tY * tMat.col2.y);
            cp.m_id.Set(cv.id);
            cp.m_id.features.flip = flip;
            ++pointCount;
         }
      }
      manifold.m_pointCount = pointCount;
   }
   b2Collision.CollideCircles = function (manifold, circle1, xf1, circle2, xf2) {
      manifold.m_pointCount = 0;
      var tMat;
      var tVec;
      tMat = xf1.R;
      tVec = circle1.m_p;
      var p1X = xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var p1Y = xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tMat = xf2.R;
      tVec = circle2.m_p;
      var p2X = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var p2Y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      var dX = p2X - p1X;
      var dY = p2Y - p1Y;
      var distSqr = dX * dX + dY * dY;
      var radius = circle1.m_radius + circle2.m_radius;
      if (distSqr > radius * radius) {
         return;
      }
      manifold.m_type = b2Manifold.e_circles;
      manifold.m_localPoint.SetV(circle1.m_p);
      manifold.m_localPlaneNormal.SetZero();
      manifold.m_pointCount = 1;
      manifold.m_points[0].m_localPoint.SetV(circle2.m_p);
      manifold.m_points[0].m_id.key = 0;
   }
   b2Collision.CollidePolygonAndCircle = function (manifold, polygon, xf1, circle, xf2) {
      manifold.m_pointCount = 0;
      var tPoint;
      var dX = 0;
      var dY = 0;
      var positionX = 0;
      var positionY = 0;
      var tVec;
      var tMat;
      tMat = xf2.R;
      tVec = circle.m_p;
      var cX = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var cY = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      dX = cX - xf1.position.x;
      dY = cY - xf1.position.y;
      tMat = xf1.R;
      var cLocalX = (dX * tMat.col1.x + dY * tMat.col1.y);
      var cLocalY = (dX * tMat.col2.x + dY * tMat.col2.y);
      var dist = 0;
      var normalIndex = 0;
      var separation = (-Number.MAX_VALUE);
      var radius = polygon.m_radius + circle.m_radius;
      var vertexCount = parseInt(polygon.m_vertexCount);
      var vertices = polygon.m_vertices;
      var normals = polygon.m_normals;
      for (var i = 0; i < vertexCount; ++i) {
         tVec = vertices[i];
         dX = cLocalX - tVec.x;
         dY = cLocalY - tVec.y;
         tVec = normals[i];
         var s = tVec.x * dX + tVec.y * dY;
         if (s > radius) {
            return;
         }
         if (s > separation) {
            separation = s;
            normalIndex = i;
         }
      }
      var vertIndex1 = parseInt(normalIndex);
      var vertIndex2 = parseInt(vertIndex1 + 1 < vertexCount ? vertIndex1 + 1 : 0);
      var v1 = vertices[vertIndex1];
      var v2 = vertices[vertIndex2];
      if (separation < FLOAT_EPSILON) {
         manifold.m_pointCount = 1;
         manifold.m_type = b2Manifold.e_faceA;
         manifold.m_localPlaneNormal.SetV(normals[normalIndex]);
         manifold.m_localPoint.x = 0.5 * (v1.x + v2.x);
         manifold.m_localPoint.y = 0.5 * (v1.y + v2.y);
         manifold.m_points[0].m_localPoint.SetV(circle.m_p);
         manifold.m_points[0].m_id.key = 0;
         return;
      }
      var u1 = (cLocalX - v1.x) * (v2.x - v1.x) + (cLocalY - v1.y) * (v2.y - v1.y);
      var u2 = (cLocalX - v2.x) * (v1.x - v2.x) + (cLocalY - v2.y) * (v1.y - v2.y);
      if (u1 <= 0.0) {
         if ((cLocalX - v1.x) * (cLocalX - v1.x) + (cLocalY - v1.y) * (cLocalY - v1.y) > radius * radius) return;
         manifold.m_pointCount = 1;
         manifold.m_type = b2Manifold.e_faceA;
         manifold.m_localPlaneNormal.x = cLocalX - v1.x;
         manifold.m_localPlaneNormal.y = cLocalY - v1.y;
         manifold.m_localPlaneNormal.Normalize();
         manifold.m_localPoint.SetV(v1);
         manifold.m_points[0].m_localPoint.SetV(circle.m_p);
         manifold.m_points[0].m_id.key = 0;
      }
      else if (u2 <= 0) {
         if ((cLocalX - v2.x) * (cLocalX - v2.x) + (cLocalY - v2.y) * (cLocalY - v2.y) > radius * radius) return;
         manifold.m_pointCount = 1;
         manifold.m_type = b2Manifold.e_faceA;
         manifold.m_localPlaneNormal.x = cLocalX - v2.x;
         manifold.m_localPlaneNormal.y = cLocalY - v2.y;
         manifold.m_localPlaneNormal.Normalize();
         manifold.m_localPoint.SetV(v2);
         manifold.m_points[0].m_localPoint.SetV(circle.m_p);
         manifold.m_points[0].m_id.key = 0;
      }
      else {
         var faceCenterX = 0.5 * (v1.x + v2.x);
         var faceCenterY = 0.5 * (v1.y + v2.y);
         separation = (cLocalX - faceCenterX) * normals[vertIndex1].x + (cLocalY - faceCenterY) * normals[vertIndex1].y;
         if (separation > radius) return;
         manifold.m_pointCount = 1;
         manifold.m_type = b2Manifold.e_faceA;
         manifold.m_localPlaneNormal.x = normals[vertIndex1].x;
         manifold.m_localPlaneNormal.y = normals[vertIndex1].y;
         manifold.m_localPlaneNormal.Normalize();
         manifold.m_localPoint.Set(faceCenterX, faceCenterY);
         manifold.m_points[0].m_localPoint.SetV(circle.m_p);
         manifold.m_points[0].m_id.key = 0;
      }
   }
   b2Collision.TestOverlap = function (a, b) {
      var t1 = b.lowerBound;
      var t2 = a.upperBound;
      var d1X = t1.x - t2.x;
      var d1Y = t1.y - t2.y;
      t1 = a.lowerBound;
      t2 = b.upperBound;
      var d2X = t1.x - t2.x;
      var d2Y = t1.y - t2.y;
      if (d1X > 0.0 || d1Y > 0.0) return false;
      if (d2X > 0.0 || d2Y > 0.0) return false;
      return true;
   }
   Box2D.postDefs.push(function () {
      Box2D.Collision.b2Collision.s_incidentEdge = b2Collision.MakeClipPointVector();
      Box2D.Collision.b2Collision.s_clipPoints1 = b2Collision.MakeClipPointVector();
      Box2D.Collision.b2Collision.s_clipPoints2 = b2Collision.MakeClipPointVector();
      Box2D.Collision.b2Collision.s_edgeAO = new Vector_a2j_Number(1);
      Box2D.Collision.b2Collision.s_edgeBO = new Vector_a2j_Number(1);
      Box2D.Collision.b2Collision.s_localTangent = new b2Vec2();
      Box2D.Collision.b2Collision.s_localNormal = new b2Vec2();
      Box2D.Collision.b2Collision.s_planePoint = new b2Vec2();
      Box2D.Collision.b2Collision.s_normal = new b2Vec2();
      Box2D.Collision.b2Collision.s_tangent = new b2Vec2();
      Box2D.Collision.b2Collision.s_tangent2 = new b2Vec2();
      Box2D.Collision.b2Collision.s_v11 = new b2Vec2();
      Box2D.Collision.b2Collision.s_v12 = new b2Vec2();
      Box2D.Collision.b2Collision.b2CollidePolyTempVec = new b2Vec2();
      Box2D.Collision.b2Collision.b2_nullFeature = 0x000000ff;
   });
   b2ContactID.b2ContactID = function () {
      this.features = new Features();
   };
   b2ContactID.prototype.b2ContactID = function () {
      this.features._m_id = this;
   }
   b2ContactID.prototype.Set = function (id) {
      this.key = id._key;
   }
   b2ContactID.prototype.Copy = function () {
      var id = new b2ContactID();
      id.key = this.key;
      return id;
   }
   Object.defineProperty(b2ContactID.prototype, 'key', {
      enumerable: false,
      configurable: true,
      get: function () {
         return this._key;
      }
   });
   Object.defineProperty(b2ContactID.prototype, 'key', {
      enumerable: false,
      configurable: true,
      set: function (value) {
         if (value === undefined) value = 0;
         this._key = value;
         this.features._referenceEdge = this._key & 0x000000ff;
         this.features._incidentEdge = ((this._key & 0x0000ff00) >> 8) & 0x000000ff;
         this.features._incidentVertex = ((this._key & 0x00ff0000) >> 16) & 0x000000ff;
         this.features._flip = ((this._key & 0xff000000) >> 24) & 0x000000ff;
      }
   });
   b2ContactPoint.b2ContactPoint = function () {
      this.position = new b2Vec2();
      this.velocity = new b2Vec2();
      this.normal = new b2Vec2();
      this.id = new b2ContactID();
   };
   b2Distance.b2Distance = function () {};
   b2Distance.Distance = function (output, cache, input) {
      ++b2Distance.b2_gjkCalls;
      var proxyA = input.proxyA;
      var proxyB = input.proxyB;
      var transformA = input.transformA;
      var transformB = input.transformB;
      var simplex = b2Distance.s_simplex;
      simplex.ReadCache(cache, proxyA, transformA, proxyB, transformB);
      var vertices = simplex.m_vertices;
      var k_maxIters = 20;
      var saveA = b2Distance.s_saveA;
      var saveB = b2Distance.s_saveB;
      var saveCount = 0;
      var closestPoint = simplex.GetClosestPoint();
      var distanceSqr1 = closestPoint.LengthSquared();
      var distanceSqr2 = distanceSqr1;
      var i = 0;
      var p;
      var iter = 0;
      while (iter < k_maxIters) {
         saveCount = simplex.m_count;
         for (i = 0;
         i < saveCount; i++) {
            saveA[i] = vertices[i].indexA;
            saveB[i] = vertices[i].indexB;
         }
         switch (simplex.m_count) {
         case 1:
            break;
         case 2:
            simplex.Solve2();
            break;
         case 3:
            simplex.Solve3();
            break;
         default:
            b2Settings.b2Assert(false);
         }
         if (simplex.m_count == 3) {
            break;
         }
         p = simplex.GetClosestPoint();
         distanceSqr2 = p.LengthSquared();
         if (distanceSqr2 > distanceSqr1) {}
         distanceSqr1 = distanceSqr2;
         var d = simplex.GetSearchDirection();
         if (d.LengthSquared() < FLOAT_EPSILON * FLOAT_EPSILON) {
            break;
         }
         var vertex = vertices[simplex.m_count];
         vertex.indexA = proxyA.GetSupport(b2Math.MulTMV(transformA.R, d.GetNegative()));
         vertex.wA = b2Math.MulX(transformA, proxyA.GetVertex(vertex.indexA));
         vertex.indexB = proxyB.GetSupport(b2Math.MulTMV(transformB.R, d));
         vertex.wB = b2Math.MulX(transformB, proxyB.GetVertex(vertex.indexB));
         vertex.w = b2Math.SubtractVV(vertex.wB, vertex.wA);
         ++iter;
         ++b2Distance.b2_gjkIters;
         var duplicate = false;
         for (i = 0;
         i < saveCount; i++) {
            if (vertex.indexA == saveA[i] && vertex.indexB == saveB[i]) {
               duplicate = true;
               break;
            }
         }
         if (duplicate) {
            break;
         }++simplex.m_count;
      }
      b2Distance.b2_gjkMaxIters = b2Math.Max(b2Distance.b2_gjkMaxIters, iter);
      simplex.GetWitnessPoints(output.pointA, output.pointB);
      output.distance = b2Math.SubtractVV(output.pointA, output.pointB).Length();
      output.iterations = iter;
      simplex.WriteCache(cache);
      if (input.useRadii) {
         var rA = proxyA.m_radius;
         var rB = proxyB.m_radius;
         if (output.distance > rA + rB && output.distance > FLOAT_EPSILON) {
            output.distance -= rA + rB;
            var normal = b2Math.SubtractVV(output.pointB, output.pointA);
            normal.Normalize();
            output.pointA.x += rA * normal.x;
            output.pointA.y += rA * normal.y;
            output.pointB.x -= rB * normal.x;
            output.pointB.y -= rB * normal.y;
         }
         else {
            p = new b2Vec2();
            p.x = .5 * (output.pointA.x + output.pointB.x);
            p.y = .5 * (output.pointA.y + output.pointB.y);
            output.pointA.x = output.pointB.x = p.x;
            output.pointA.y = output.pointB.y = p.y;
            output.distance = 0.0;
         }
      }
   }
   Box2D.postDefs.push(function () {
      Box2D.Collision.b2Distance.s_simplex = new b2Simplex();
      Box2D.Collision.b2Distance.s_saveA = new Vector_a2j_Number(3);
      Box2D.Collision.b2Distance.s_saveB = new Vector_a2j_Number(3);
   });
   b2DistanceInput.b2DistanceInput = function () {};
   b2DistanceOutput.b2DistanceOutput = function () {
      this.pointA = new b2Vec2();
      this.pointB = new b2Vec2();
   };
   b2DistanceProxy.b2DistanceProxy = function () {};
   b2DistanceProxy.prototype.Set = function (shape) {
      switch (shape.GetType()) {
      case b2Shape.e_circleShape:
         {
            var circle = (shape instanceof b2CircleShape ? shape : null);
            this.m_vertices = new Vector(1, true);
            this.m_vertices[0] = circle.m_p;
            this.m_count = 1;
            this.m_radius = circle.m_radius;
         }
         break;
      case b2Shape.e_polygonShape:
         {
            var polygon = (shape instanceof b2PolygonShape ? shape : null);
            this.m_vertices = polygon.m_vertices;
            this.m_count = polygon.m_vertexCount;
            this.m_radius = polygon.m_radius;
         }
         break;
      default:
         b2Settings.b2Assert(false);
      }
   }
   b2DistanceProxy.prototype.GetSupport = function (d) {
      var bestIndex = 0;
      var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
      for (var i = 1; i < this.m_count; ++i) {
         var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
         if (value > bestValue) {
            bestIndex = i;
            bestValue = value;
         }
      }
      return bestIndex;
   }
   b2DistanceProxy.prototype.GetSupportVertex = function (d) {
      var bestIndex = 0;
      var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
      for (var i = 1; i < this.m_count; ++i) {
         var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
         if (value > bestValue) {
            bestIndex = i;
            bestValue = value;
         }
      }
      return this.m_vertices[bestIndex];
   }
   b2DistanceProxy.prototype.GetVertexCount = function () {
      return this.m_count;
   }
   b2DistanceProxy.prototype.GetVertex = function (index) {
      if (index === undefined) index = 0;
      b2Settings.b2Assert(0 <= index && index < this.m_count);
      return this.m_vertices[index];
   }
   b2DynamicTree.b2DynamicTree = function () {};
   b2DynamicTree.prototype.b2DynamicTree = function () {
      this.m_root = null;
      this.m_freeList = null;
      this.m_path = 0;
      this.m_insertionCount = 0;
   }
   b2DynamicTree.prototype.CreateProxy = function (aabb, userData) {
      var node = this.AllocateNode();
      var extendX = b2Settings.b2_aabbExtension;
      var extendY = b2Settings.b2_aabbExtension;
      node.aabb.lowerBound.x = aabb.lowerBound.x - extendX;
      node.aabb.lowerBound.y = aabb.lowerBound.y - extendY;
      node.aabb.upperBound.x = aabb.upperBound.x + extendX;
      node.aabb.upperBound.y = aabb.upperBound.y + extendY;
      node.userData = userData;
      this.InsertLeaf(node);
      return node;
   }
   b2DynamicTree.prototype.DestroyProxy = function (proxy) {
      this.RemoveLeaf(proxy);
      this.FreeNode(proxy);
   }
   b2DynamicTree.prototype.MoveProxy = function (proxy, aabb, displacement) {
      b2Settings.b2Assert(proxy.IsLeaf());
      if (proxy.aabb.Contains(aabb)) {
         return false;
      }
      this.RemoveLeaf(proxy);
      var extendX = b2Settings.b2_aabbExtension + b2Settings.b2_aabbMultiplier * (displacement.x > 0 ? displacement.x : (-displacement.x));
      var extendY = b2Settings.b2_aabbExtension + b2Settings.b2_aabbMultiplier * (displacement.y > 0 ? displacement.y : (-displacement.y));
      proxy.aabb.lowerBound.x = aabb.lowerBound.x - extendX;
      proxy.aabb.lowerBound.y = aabb.lowerBound.y - extendY;
      proxy.aabb.upperBound.x = aabb.upperBound.x + extendX;
      proxy.aabb.upperBound.y = aabb.upperBound.y + extendY;
      this.InsertLeaf(proxy);
      return true;
   }
   b2DynamicTree.prototype.Rebalance = function (iterations) {
      if (iterations === undefined) iterations = 0;
      if (this.m_root == null) return;
      for (var i = 0; i < iterations; i++) {
         var node = this.m_root;
         var bit = 0;
         while (node.IsLeaf() == false) {
            node = (this.m_path >> bit) & 1 ? node.child2 : node.child1;
            bit = (bit + 1) & 31;
         }++this.m_path;
         this.RemoveLeaf(node);
         this.InsertLeaf(node);
      }
   }
   b2DynamicTree.prototype.GetFatAABB = function (proxy) {
      return proxy.aabb;
   }
   b2DynamicTree.prototype.GetUserData = function (proxy) {
      return proxy.userData;
   }
   b2DynamicTree.prototype.Query = function (callback, aabb) {
      if (this.m_root == null) return;
      var stack = new Vector();
      var count = 0;
      stack[count++] = this.m_root;
      while (count > 0) {
         var node = stack[--count];
         if (node.aabb.TestOverlap(aabb)) {
            if (node.IsLeaf()) {
               var proceed = callback(node);
               if (!proceed) return;
            }
            else {
               stack[count++] = node.child1;
               stack[count++] = node.child2;
            }
         }
      }
   }
   b2DynamicTree.prototype.RayCast = function (callback, input) {
      if (this.m_root == null) return;
      var p1 = input.p1;
      var p2 = input.p2;
      var r = b2Math.SubtractVV(p1, p2);
      r.Normalize();
      var v = b2Math.CrossFV(1.0, r);
      var abs_v = b2Math.AbsV(v);
      var maxFraction = input.maxFraction;
      var segmentAABB = new b2AABB();
      var tX = 0;
      var tY = 0; {
         tX = p1.x + maxFraction * (p2.x - p1.x);
         tY = p1.y + maxFraction * (p2.y - p1.y);
         segmentAABB.lowerBound.x = Math.min(p1.x, tX);
         segmentAABB.lowerBound.y = Math.min(p1.y, tY);
         segmentAABB.upperBound.x = Math.max(p1.x, tX);
         segmentAABB.upperBound.y = Math.max(p1.y, tY);
      }
      var stack = new Vector();
      var count = 0;
      stack[count++] = this.m_root;
      while (count > 0) {
         var node = stack[--count];
         if (node.aabb.TestOverlap(segmentAABB) == false) {
            continue;
         }
         var c = node.aabb.GetCenter();
         var h = node.aabb.GetExtents();
         var separation = Math.abs(v.x * (p1.x - c.x) + v.y * (p1.y - c.y)) - abs_v.x * h.x - abs_v.y * h.y;
         if (separation > 0.0) continue;
         if (node.IsLeaf()) {
            var subInput = new b2RayCastInput();
            subInput.p1 = input.p1;
            subInput.p2 = input.p2;
            subInput.maxFraction = input.maxFraction;
            maxFraction = callback(subInput, node);
            if (maxFraction == 0.0) return;
            if (maxFraction > 0.0) {
               tX = p1.x + maxFraction * (p2.x - p1.x);
               tY = p1.y + maxFraction * (p2.y - p1.y);
               segmentAABB.lowerBound.x = Math.min(p1.x, tX);
               segmentAABB.lowerBound.y = Math.min(p1.y, tY);
               segmentAABB.upperBound.x = Math.max(p1.x, tX);
               segmentAABB.upperBound.y = Math.max(p1.y, tY);
            }
         }
         else {
            stack[count++] = node.child1;
            stack[count++] = node.child2;
         }
      }
   }
   b2DynamicTree.prototype.AllocateNode = function () {
      if (this.m_freeList) {
         var node = this.m_freeList;
         this.m_freeList = node.parent;
         node.parent = null;
         node.child1 = null;
         node.child2 = null;
         return node;
      }
      return new b2DynamicTreeNode();
   }
   b2DynamicTree.prototype.FreeNode = function (node) {
      node.parent = this.m_freeList;
      this.m_freeList = node;
   }
   b2DynamicTree.prototype.InsertLeaf = function (leaf) {
      ++this.m_insertionCount;
      if (this.m_root == null) {
         this.m_root = leaf;
         this.m_root.parent = null;
         return;
      }
      var center = leaf.aabb.GetCenter();
      var sibling = this.m_root;
      if (sibling.IsLeaf() == false) {
         do {
            var child1 = sibling.child1;
            var child2 = sibling.child2;
            var norm1 = Math.abs((child1.aabb.lowerBound.x + child1.aabb.upperBound.x) / 2 - center.x) + Math.abs((child1.aabb.lowerBound.y + child1.aabb.upperBound.y) / 2 - center.y);
            var norm2 = Math.abs((child2.aabb.lowerBound.x + child2.aabb.upperBound.x) / 2 - center.x) + Math.abs((child2.aabb.lowerBound.y + child2.aabb.upperBound.y) / 2 - center.y);
            if (norm1 < norm2) {
               sibling = child1;
            }
            else {
               sibling = child2;
            }
         }
         while (sibling.IsLeaf() == false)
      }
      var node1 = sibling.parent;
      var node2 = this.AllocateNode();
      node2.parent = node1;
      node2.userData = null;
      node2.aabb.Combine(leaf.aabb, sibling.aabb);
      if (node1) {
         if (sibling.parent.child1 == sibling) {
            node1.child1 = node2;
         }
         else {
            node1.child2 = node2;
         }
         node2.child1 = sibling;
         node2.child2 = leaf;
         sibling.parent = node2;
         leaf.parent = node2;
         do {
            if (node1.aabb.Contains(node2.aabb)) break;
            node1.aabb.Combine(node1.child1.aabb, node1.child2.aabb);
            node2 = node1;
            node1 = node1.parent;
         }
         while (node1)
      }
      else {
         node2.child1 = sibling;
         node2.child2 = leaf;
         sibling.parent = node2;
         leaf.parent = node2;
         this.m_root = node2;
      }
   }
   b2DynamicTree.prototype.RemoveLeaf = function (leaf) {
      if (leaf == this.m_root) {
         this.m_root = null;
         return;
      }
      var node2 = leaf.parent;
      var node1 = node2.parent;
      var sibling;
      if (node2.child1 == leaf) {
         sibling = node2.child2;
      }
      else {
         sibling = node2.child1;
      }
      if (node1) {
         if (node1.child1 == node2) {
            node1.child1 = sibling;
         }
         else {
            node1.child2 = sibling;
         }
         sibling.parent = node1;
         this.FreeNode(node2);
         while (node1) {
            var oldAABB = node1.aabb;
            node1.aabb = b2AABB.Combine(node1.child1.aabb, node1.child2.aabb);
            if (oldAABB.Contains(node1.aabb)) break;
            node1 = node1.parent;
         }
      }
      else {
         this.m_root = sibling;
         sibling.parent = null;
         this.FreeNode(node2);
      }
   }
   b2DynamicTreeBroadPhase.b2DynamicTreeBroadPhase = function () {
      this.m_tree = new b2DynamicTree();
      this.m_moveBuffer = new Vector();
      this.m_pairBuffer = new Vector();
      this.m_pairCount = 0;
   };
   b2DynamicTreeBroadPhase.prototype.CreateProxy = function (aabb, userData) {
      var proxy = this.m_tree.CreateProxy(aabb, userData);
      ++this.m_proxyCount;
      this.BufferMove(proxy);
      return proxy;
   }
   b2DynamicTreeBroadPhase.prototype.DestroyProxy = function (proxy) {
      this.UnBufferMove(proxy);
      --this.m_proxyCount;
      this.m_tree.DestroyProxy(proxy);
   }
   b2DynamicTreeBroadPhase.prototype.MoveProxy = function (proxy, aabb, displacement) {
      var buffer = this.m_tree.MoveProxy(proxy, aabb, displacement);
      if (buffer) {
         this.BufferMove(proxy);
      }
   }
   b2DynamicTreeBroadPhase.prototype.TestOverlap = function (proxyA, proxyB) {
      var aabbA = this.m_tree.GetFatAABB(proxyA);
      var aabbB = this.m_tree.GetFatAABB(proxyB);
      return aabbA.TestOverlap(aabbB);
   }
   b2DynamicTreeBroadPhase.prototype.GetUserData = function (proxy) {
      return this.m_tree.GetUserData(proxy);
   }
   b2DynamicTreeBroadPhase.prototype.GetFatAABB = function (proxy) {
      return this.m_tree.GetFatAABB(proxy);
   }
   b2DynamicTreeBroadPhase.prototype.GetProxyCount = function () {
      return this.m_proxyCount;
   }
   b2DynamicTreeBroadPhase.prototype.UpdatePairs = function (callback) {
      var __this = this;
      __this.m_pairCount = 0;
      var i = 0,
         queryProxy;
      for (i = 0;
      i < __this.m_moveBuffer.length; ++i) {
         queryProxy = __this.m_moveBuffer[i];

         function QueryCallback(proxy) {
            if (proxy == queryProxy) return true;
            if (__this.m_pairCount == __this.m_pairBuffer.length) {
               __this.m_pairBuffer[__this.m_pairCount] = new b2DynamicTreePair();
            }
            var pair = __this.m_pairBuffer[__this.m_pairCount];
            pair.proxyA = proxy < queryProxy ? proxy : queryProxy;
            pair.proxyB = proxy >= queryProxy ? proxy : queryProxy;++__this.m_pairCount;
            return true;
         };
         var fatAABB = __this.m_tree.GetFatAABB(queryProxy);
         __this.m_tree.Query(QueryCallback, fatAABB);
      }
      __this.m_moveBuffer.length = 0;
      for (var i = 0; i < __this.m_pairCount;) {
         var primaryPair = __this.m_pairBuffer[i];
         var userDataA = __this.m_tree.GetUserData(primaryPair.proxyA);
         var userDataB = __this.m_tree.GetUserData(primaryPair.proxyB);
         callback(userDataA, userDataB);
         ++i;
         while (i < __this.m_pairCount) {
            var pair = __this.m_pairBuffer[i];
            if (pair.proxyA != primaryPair.proxyA || pair.proxyB != primaryPair.proxyB) {
               break;
            }++i;
         }
      }
   }
   b2DynamicTreeBroadPhase.prototype.Query = function (callback, aabb) {
      this.m_tree.Query(callback, aabb);
   }
   b2DynamicTreeBroadPhase.prototype.RayCast = function (callback, input) {
      this.m_tree.RayCast(callback, input);
   }
   b2DynamicTreeBroadPhase.prototype.Validate = function () {}
   b2DynamicTreeBroadPhase.prototype.Rebalance = function (iterations) {
      if (iterations === undefined) iterations = 0;
      this.m_tree.Rebalance(iterations);
   }
   b2DynamicTreeBroadPhase.prototype.BufferMove = function (proxy) {
      this.m_moveBuffer[this.m_moveBuffer.length] = proxy;
   }
   b2DynamicTreeBroadPhase.prototype.UnBufferMove = function (proxy) {
      var i = parseInt(this.m_moveBuffer.indexOf(proxy));
      this.m_moveBuffer.splice(i, 1);
   }
   b2DynamicTreeBroadPhase.prototype.ComparePairs = function (pair1, pair2) {
      return 0;
   }
   b2DynamicTreeBroadPhase.__implements = {};
   b2DynamicTreeBroadPhase.__implements[IBroadPhase] = true;
   b2DynamicTreeNode.b2DynamicTreeNode = function () {
      this.aabb = new b2AABB();
   };
   b2DynamicTreeNode.prototype.IsLeaf = function () {
      return this.child1 == null;
   }
   b2DynamicTreePair.b2DynamicTreePair = function () {};
   b2Manifold.b2Manifold = function () {
      this.m_pointCount = 0;
   };
   b2Manifold.prototype.b2Manifold = function () {
      this.m_points = new Vector(b2Settings.b2_maxManifoldPoints);
      for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
         this.m_points[i] = new b2ManifoldPoint();
      }
      this.m_localPlaneNormal = new b2Vec2();
      this.m_localPoint = new b2Vec2();
   }
   b2Manifold.prototype.Reset = function () {
      for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
         ((this.m_points[i] instanceof b2ManifoldPoint ? this.m_points[i] : null)).Reset();
      }
      this.m_localPlaneNormal.SetZero();
      this.m_localPoint.SetZero();
      this.m_type = 0;
      this.m_pointCount = 0;
   }
   b2Manifold.prototype.Set = function (m) {
      this.m_pointCount = m.m_pointCount;
      for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
         ((this.m_points[i] instanceof b2ManifoldPoint ? this.m_points[i] : null)).Set(m.m_points[i]);
      }
      this.m_localPlaneNormal.SetV(m.m_localPlaneNormal);
      this.m_localPoint.SetV(m.m_localPoint);
      this.m_type = m.m_type;
   }
   b2Manifold.prototype.Copy = function () {
      var copy = new b2Manifold();
      copy.Set(this);
      return copy;
   }
   Box2D.postDefs.push(function () {
      Box2D.Collision.b2Manifold.e_circles = 0x0001;
      Box2D.Collision.b2Manifold.e_faceA = 0x0002;
      Box2D.Collision.b2Manifold.e_faceB = 0x0004;
   });
   b2ManifoldPoint.b2ManifoldPoint = function () {
      this.m_localPoint = new b2Vec2();
      this.m_id = new b2ContactID();
   };
   b2ManifoldPoint.prototype.b2ManifoldPoint = function () {
      this.Reset();
   }
   b2ManifoldPoint.prototype.Reset = function () {
      this.m_localPoint.SetZero();
      this.m_normalImpulse = 0.0;
      this.m_tangentImpulse = 0.0;
      this.m_id.key = 0;
   }
   b2ManifoldPoint.prototype.Set = function (m) {
      this.m_localPoint.SetV(m.m_localPoint);
      this.m_normalImpulse = m.m_normalImpulse;
      this.m_tangentImpulse = m.m_tangentImpulse;
      this.m_id.Set(m.m_id);
   }
   b2Point.b2Point = function () {
      this.p = new b2Vec2();
   };
   b2Point.prototype.Support = function (xf, vX, vY) {
      if (vX === undefined) vX = 0;
      if (vY === undefined) vY = 0;
      return this.p;
   }
   b2Point.prototype.GetFirstVertex = function (xf) {
      return this.p;
   }
   b2RayCastInput.b2RayCastInput = function () {
      this.p1 = new b2Vec2();
      this.p2 = new b2Vec2();
   };
   b2RayCastInput.prototype.b2RayCastInput = function (p1, p2, maxFraction) {
      if (p1 === undefined) p1 = null;
      if (p2 === undefined) p2 = null;
      if (maxFraction === undefined) maxFraction = 1;
      if (p1) this.p1.SetV(p1);
      if (p2) this.p2.SetV(p2);
      this.maxFraction = maxFraction;
   }
   b2RayCastOutput.b2RayCastOutput = function () {
      this.normal = new b2Vec2();
   };
   b2Segment.b2Segment = function () {
      this.p1 = new b2Vec2();
      this.p2 = new b2Vec2();
   };
   b2Segment.prototype.TestSegment = function (lambda, normal, segment, maxLambda) {
      if (maxLambda === undefined) maxLambda = 0;
      var s = segment.p1;
      var rX = segment.p2.x - s.x;
      var rY = segment.p2.y - s.y;
      var dX = this.p2.x - this.p1.x;
      var dY = this.p2.y - this.p1.y;
      var nX = dY;
      var nY = (-dX);
      var k_slop = 100.0 * FLOAT_EPSILON;
      var denom = (-(rX * nX + rY * nY));
      if (denom > k_slop) {
         var bX = s.x - this.p1.x;
         var bY = s.y - this.p1.y;
         var a = (bX * nX + bY * nY);
         if (0.0 <= a && a <= maxLambda * denom) {
            var mu2 = (-rX * bY) + rY * bX;
            if ((-k_slop * denom) <= mu2 && mu2 <= denom * (1.0 + k_slop)) {
               a /= denom;
               var nLen = Math.sqrt(nX * nX + nY * nY);
               nX /= nLen;
               nY /= nLen;
               lambda[0] = a;
               normal.Set(nX, nY);
               return true;
            }
         }
      }
      return false;
   }
   b2Segment.prototype.Extend = function (aabb) {
      this.ExtendForward(aabb);
      this.ExtendBackward(aabb);
   }
   b2Segment.prototype.ExtendForward = function (aabb) {
      var dX = this.p2.x - this.p1.x;
      var dY = this.p2.y - this.p1.y;
      var lambda = Math.min(dX > 0 ? (aabb.upperBound.x - this.p1.x) / dX : dX < 0 ? (aabb.lowerBound.x - this.p1.x) / dX : Number.POSITIVE_INFINITY,
      dY > 0 ? (aabb.upperBound.y - this.p1.y) / dY : dY < 0 ? (aabb.lowerBound.y - this.p1.y) / dY : Number.POSITIVE_INFINITY);
      this.p2.x = this.p1.x + dX * lambda;
      this.p2.y = this.p1.y + dY * lambda;
   }
   b2Segment.prototype.ExtendBackward = function (aabb) {
      var dX = (-this.p2.x) + this.p1.x;
      var dY = (-this.p2.y) + this.p1.y;
      var lambda = Math.min(dX > 0 ? (aabb.upperBound.x - this.p2.x) / dX : dX < 0 ? (aabb.lowerBound.x - this.p2.x) / dX : Number.POSITIVE_INFINITY,
      dY > 0 ? (aabb.upperBound.y - this.p2.y) / dY : dY < 0 ? (aabb.lowerBound.y - this.p2.y) / dY : Number.POSITIVE_INFINITY);
      this.p1.x = this.p2.x + dX * lambda;
      this.p1.y = this.p2.y + dY * lambda;
   }
   b2SeparationFunction.b2SeparationFunction = function () {
      this.m_localPoint = new b2Vec2();
      this.m_axis = new b2Vec2();
   };
   b2SeparationFunction.prototype.Initialize = function (cache, proxyA, transformA, proxyB, transformB) {
      this.m_proxyA = proxyA;
      this.m_proxyB = proxyB;
      var count = parseInt(cache.count);
      b2Settings.b2Assert(0 < count && count < 3);
      var localPointA;
      var localPointA1;
      var localPointA2;
      var localPointB;
      var localPointB1;
      var localPointB2;
      var pointAX = 0;
      var pointAY = 0;
      var pointBX = 0;
      var pointBY = 0;
      var normalX = 0;
      var normalY = 0;
      var tMat;
      var tVec;
      var s = 0;
      var sgn = 0;
      if (count == 1) {
         this.m_type = b2SeparationFunction.e_points;
         localPointA = this.m_proxyA.GetVertex(cache.indexA[0]);
         localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);
         tVec = localPointA;
         tMat = transformA.R;
         pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         tVec = localPointB;
         tMat = transformB.R;
         pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         this.m_axis.x = pointBX - pointAX;
         this.m_axis.y = pointBY - pointAY;
         this.m_axis.Normalize();
      }
      else if (cache.indexB[0] == cache.indexB[1]) {
         this.m_type = b2SeparationFunction.e_faceA;
         localPointA1 = this.m_proxyA.GetVertex(cache.indexA[0]);
         localPointA2 = this.m_proxyA.GetVertex(cache.indexA[1]);
         localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);
         this.m_localPoint.x = 0.5 * (localPointA1.x + localPointA2.x);
         this.m_localPoint.y = 0.5 * (localPointA1.y + localPointA2.y);
         this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointA2, localPointA1), 1.0);
         this.m_axis.Normalize();
         tVec = this.m_axis;
         tMat = transformA.R;
         normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
         normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
         tVec = this.m_localPoint;
         tMat = transformA.R;
         pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         tVec = localPointB;
         tMat = transformB.R;
         pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         s = (pointBX - pointAX) * normalX + (pointBY - pointAY) * normalY;
         if (s < 0.0) {
            this.m_axis.NegativeSelf();
         }
      }
      else if (cache.indexA[0] == cache.indexA[0]) {
         this.m_type = b2SeparationFunction.e_faceB;
         localPointB1 = this.m_proxyB.GetVertex(cache.indexB[0]);
         localPointB2 = this.m_proxyB.GetVertex(cache.indexB[1]);
         localPointA = this.m_proxyA.GetVertex(cache.indexA[0]);
         this.m_localPoint.x = 0.5 * (localPointB1.x + localPointB2.x);
         this.m_localPoint.y = 0.5 * (localPointB1.y + localPointB2.y);
         this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointB2, localPointB1), 1.0);
         this.m_axis.Normalize();
         tVec = this.m_axis;
         tMat = transformB.R;
         normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
         normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
         tVec = this.m_localPoint;
         tMat = transformB.R;
         pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         tVec = localPointA;
         tMat = transformA.R;
         pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         s = (pointAX - pointBX) * normalX + (pointAY - pointBY) * normalY;
         if (s < 0.0) {
            this.m_axis.NegativeSelf();
         }
      }
      else {
         localPointA1 = this.m_proxyA.GetVertex(cache.indexA[0]);
         localPointA2 = this.m_proxyA.GetVertex(cache.indexA[1]);
         localPointB1 = this.m_proxyB.GetVertex(cache.indexB[0]);
         localPointB2 = this.m_proxyB.GetVertex(cache.indexB[1]);
         var pA = b2Math.MulX(transformA, localPointA);
         var dA = b2Math.MulMV(transformA.R, b2Math.SubtractVV(localPointA2, localPointA1));
         var pB = b2Math.MulX(transformB, localPointB);
         var dB = b2Math.MulMV(transformB.R, b2Math.SubtractVV(localPointB2, localPointB1));
         var a = dA.x * dA.x + dA.y * dA.y;
         var e = dB.x * dB.x + dB.y * dB.y;
         var r = b2Math.SubtractVV(dB, dA);
         var c = dA.x * r.x + dA.y * r.y;
         var f = dB.x * r.x + dB.y * r.y;
         var b = dA.x * dB.x + dA.y * dB.y;
         var denom = a * e - b * b;
         s = 0.0;
         if (denom != 0.0) {
            s = b2Math.Clamp((b * f - c * e) / denom, 0.0, 1.0);
         }
         var t = (b * s + f) / e;
         if (t < 0.0) {
            t = 0.0;
            s = b2Math.Clamp((b - c) / a, 0.0, 1.0);
         }
         localPointA = new b2Vec2();
         localPointA.x = localPointA1.x + s * (localPointA2.x - localPointA1.x);
         localPointA.y = localPointA1.y + s * (localPointA2.y - localPointA1.y);
         localPointB = new b2Vec2();
         localPointB.x = localPointB1.x + s * (localPointB2.x - localPointB1.x);
         localPointB.y = localPointB1.y + s * (localPointB2.y - localPointB1.y);
         if (s == 0.0 || s == 1.0) {
            this.m_type = b2SeparationFunction.e_faceB;
            this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointB2, localPointB1), 1.0);
            this.m_axis.Normalize();
            this.m_localPoint = localPointB;
            tVec = this.m_axis;
            tMat = transformB.R;
            normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tVec = this.m_localPoint;
            tMat = transformB.R;
            pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            tVec = localPointA;
            tMat = transformA.R;
            pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            sgn = (pointAX - pointBX) * normalX + (pointAY - pointBY) * normalY;
            if (s < 0.0) {
               this.m_axis.NegativeSelf();
            }
         }
         else {
            this.m_type = b2SeparationFunction.e_faceA;
            this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointA2, localPointA1), 1.0);
            this.m_localPoint = localPointA;
            tVec = this.m_axis;
            tMat = transformA.R;
            normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tVec = this.m_localPoint;
            tMat = transformA.R;
            pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            tVec = localPointB;
            tMat = transformB.R;
            pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            sgn = (pointBX - pointAX) * normalX + (pointBY - pointAY) * normalY;
            if (s < 0.0) {
               this.m_axis.NegativeSelf();
            }
         }
      }
   }
   b2SeparationFunction.prototype.Evaluate = function (transformA, transformB) {
      var axisA;
      var axisB;
      var localPointA;
      var localPointB;
      var pointA;
      var pointB;
      var seperation = 0;
      var normal;
      switch (this.m_type) {
      case b2SeparationFunction.e_points:
         {
            axisA = b2Math.MulTMV(transformA.R, this.m_axis);
            axisB = b2Math.MulTMV(transformB.R, this.m_axis.GetNegative());
            localPointA = this.m_proxyA.GetSupportVertex(axisA);
            localPointB = this.m_proxyB.GetSupportVertex(axisB);
            pointA = b2Math.MulX(transformA, localPointA);
            pointB = b2Math.MulX(transformB, localPointB);
            seperation = (pointB.x - pointA.x) * this.m_axis.x + (pointB.y - pointA.y) * this.m_axis.y;
            return seperation;
         }
      case b2SeparationFunction.e_faceA:
         {
            normal = b2Math.MulMV(transformA.R, this.m_axis);
            pointA = b2Math.MulX(transformA, this.m_localPoint);
            axisB = b2Math.MulTMV(transformB.R, normal.GetNegative());
            localPointB = this.m_proxyB.GetSupportVertex(axisB);
            pointB = b2Math.MulX(transformB, localPointB);
            seperation = (pointB.x - pointA.x) * normal.x + (pointB.y - pointA.y) * normal.y;
            return seperation;
         }
      case b2SeparationFunction.e_faceB:
         {
            normal = b2Math.MulMV(transformB.R, this.m_axis);
            pointB = b2Math.MulX(transformB, this.m_localPoint);
            axisA = b2Math.MulTMV(transformA.R, normal.GetNegative());
            localPointA = this.m_proxyA.GetSupportVertex(axisA);
            pointA = b2Math.MulX(transformA, localPointA);
            seperation = (pointA.x - pointB.x) * normal.x + (pointA.y - pointB.y) * normal.y;
            return seperation;
         }
      default:
         b2Settings.b2Assert(false);
         return 0.0;
      }
   }
   Box2D.postDefs.push(function () {
      Box2D.Collision.b2SeparationFunction.e_points = 0x01;
      Box2D.Collision.b2SeparationFunction.e_faceA = 0x02;
      Box2D.Collision.b2SeparationFunction.e_faceB = 0x04;
   });
   b2Simplex.b2Simplex = function () {
      this.m_v1 = new b2SimplexVertex();
      this.m_v2 = new b2SimplexVertex();
      this.m_v3 = new b2SimplexVertex();
      this.m_vertices = new Vector(3);
   };
   b2Simplex.prototype.b2Simplex = function () {
      this.m_vertices[0] = this.m_v1;
      this.m_vertices[1] = this.m_v2;
      this.m_vertices[2] = this.m_v3;
   }
   b2Simplex.prototype.ReadCache = function (cache, proxyA, transformA, proxyB, transformB) {
      b2Settings.b2Assert(0 <= cache.count && cache.count <= 3);
      var wALocal;
      var wBLocal;
      this.m_count = cache.count;
      var vertices = this.m_vertices;
      for (var i = 0; i < this.m_count; i++) {
         var v = vertices[i];
         v.indexA = cache.indexA[i];
         v.indexB = cache.indexB[i];
         wALocal = proxyA.GetVertex(v.indexA);
         wBLocal = proxyB.GetVertex(v.indexB);
         v.wA = b2Math.MulX(transformA, wALocal);
         v.wB = b2Math.MulX(transformB, wBLocal);
         v.w = b2Math.SubtractVV(v.wB, v.wA);
         v.a = 0;
      }
      if (this.m_count > 1) {
         var metric1 = cache.metric;
         var metric2 = this.GetMetric();
         if (metric2 < .5 * metric1 || 2.0 * metric1 < metric2 || metric2 < FLOAT_EPSILON) {
            this.m_count = 0;
         }
      }
      if (this.m_count == 0) {
         v = vertices[0];
         v.indexA = 0;
         v.indexB = 0;
         wALocal = proxyA.GetVertex(0);
         wBLocal = proxyB.GetVertex(0);
         v.wA = b2Math.MulX(transformA, wALocal);
         v.wB = b2Math.MulX(transformB, wBLocal);
         v.w = b2Math.SubtractVV(v.wB, v.wA);
         this.m_count = 1;
      }
   }
   b2Simplex.prototype.WriteCache = function (cache) {
      cache.metric = this.GetMetric();
      cache.count = Box2D.parseUInt(this.m_count);
      var vertices = this.m_vertices;
      for (var i = 0; i < this.m_count; i++) {
         cache.indexA[i] = Box2D.parseUInt(vertices[i].indexA);
         cache.indexB[i] = Box2D.parseUInt(vertices[i].indexB);
      }
   }
   b2Simplex.prototype.GetSearchDirection = function () {
      switch (this.m_count) {
      case 1:
         return this.m_v1.w.GetNegative();
      case 2:
         {
            var e12 = b2Math.SubtractVV(this.m_v2.w, this.m_v1.w);
            var sgn = b2Math.CrossVV(e12, this.m_v1.w.GetNegative());
            if (sgn > 0.0) {
               return b2Math.CrossFV(1.0, e12);
            }
            else {
               return b2Math.CrossVF(e12, 1.0);
            }
         }
      default:
         b2Settings.b2Assert(false);
         return new b2Vec2();
      }
   }
   b2Simplex.prototype.GetClosestPoint = function () {
      switch (this.m_count) {
      case 0:
         b2Settings.b2Assert(false);
         return new b2Vec2();
      case 1:
         return this.m_v1.w;
      case 2:
         return new b2Vec2(this.m_v1.a * this.m_v1.w.x + this.m_v2.a * this.m_v2.w.x, this.m_v1.a * this.m_v1.w.y + this.m_v2.a * this.m_v2.w.y);
      default:
         b2Settings.b2Assert(false);
         return new b2Vec2();
      }
   }
   b2Simplex.prototype.GetWitnessPoints = function (pA, pB) {
      switch (this.m_count) {
      case 0:
         b2Settings.b2Assert(false);
         break;
      case 1:
         pA.SetV(this.m_v1.wA);
         pB.SetV(this.m_v1.wB);
         break;
      case 2:
         pA.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x;
         pA.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y;
         pB.x = this.m_v1.a * this.m_v1.wB.x + this.m_v2.a * this.m_v2.wB.x;
         pB.y = this.m_v1.a * this.m_v1.wB.y + this.m_v2.a * this.m_v2.wB.y;
         break;
      case 3:
         pB.x = pA.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x + this.m_v3.a * this.m_v3.wA.x;
         pB.y = pA.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y + this.m_v3.a * this.m_v3.wA.y;
         break;
      default:
         b2Settings.b2Assert(false);
         break;
      }
   }
   b2Simplex.prototype.GetMetric = function () {
      switch (this.m_count) {
      case 0:
         b2Settings.b2Assert(false);
         return 0.0;
      case 1:
         return 0.0;
      case 2:
         return b2Math.SubtractVV(this.m_v1.w, this.m_v2.w).Length();
      case 3:
         return b2Math.CrossVV(b2Math.SubtractVV(this.m_v2.w, this.m_v1.w), b2Math.SubtractVV(this.m_v3.w, this.m_v1.w));
      default:
         b2Settings.b2Assert(false);
         return 0.0;
      }
   }
   b2Simplex.prototype.Solve2 = function () {
      var w1 = this.m_v1.w;
      var w2 = this.m_v2.w;
      var e12 = b2Math.SubtractVV(w2, w1);
      var d12_2 = (-(w1.x * e12.x + w1.y * e12.y));
      if (d12_2 <= 0.0) {
         this.m_v1.a = 1.0;
         this.m_count = 1;
         return;
      }
      var d12_1 = (w2.x * e12.x + w2.y * e12.y);
      if (d12_1 <= 0.0) {
         this.m_v2.a = 1.0;
         this.m_count = 1;
         this.m_v1.Set(this.m_v2);
         return;
      }
      var inv_d12 = 1.0 / (d12_1 + d12_2);
      this.m_v1.a = d12_1 * inv_d12;
      this.m_v2.a = d12_2 * inv_d12;
      this.m_count = 2;
   }
   b2Simplex.prototype.Solve3 = function () {
      var w1 = this.m_v1.w;
      var w2 = this.m_v2.w;
      var w3 = this.m_v3.w;
      var e12 = b2Math.SubtractVV(w2, w1);
      var w1e12 = b2Math.Dot(w1, e12);
      var w2e12 = b2Math.Dot(w2, e12);
      var d12_1 = w2e12;
      var d12_2 = (-w1e12);
      var e13 = b2Math.SubtractVV(w3, w1);
      var w1e13 = b2Math.Dot(w1, e13);
      var w3e13 = b2Math.Dot(w3, e13);
      var d13_1 = w3e13;
      var d13_2 = (-w1e13);
      var e23 = b2Math.SubtractVV(w3, w2);
      var w2e23 = b2Math.Dot(w2, e23);
      var w3e23 = b2Math.Dot(w3, e23);
      var d23_1 = w3e23;
      var d23_2 = (-w2e23);
      var n123 = b2Math.CrossVV(e12, e13);
      var d123_1 = n123 * b2Math.CrossVV(w2, w3);
      var d123_2 = n123 * b2Math.CrossVV(w3, w1);
      var d123_3 = n123 * b2Math.CrossVV(w1, w2);
      if (d12_2 <= 0.0 && d13_2 <= 0.0) {
         this.m_v1.a = 1.0;
         this.m_count = 1;
         return;
      }
      if (d12_1 > 0.0 && d12_2 > 0.0 && d123_3 <= 0.0) {
         var inv_d12 = 1.0 / (d12_1 + d12_2);
         this.m_v1.a = d12_1 * inv_d12;
         this.m_v2.a = d12_2 * inv_d12;
         this.m_count = 2;
         return;
      }
      if (d13_1 > 0.0 && d13_2 > 0.0 && d123_2 <= 0.0) {
         var inv_d13 = 1.0 / (d13_1 + d13_2);
         this.m_v1.a = d13_1 * inv_d13;
         this.m_v3.a = d13_2 * inv_d13;
         this.m_count = 2;
         this.m_v2.Set(this.m_v3);
         return;
      }
      if (d12_1 <= 0.0 && d23_2 <= 0.0) {
         this.m_v2.a = 1.0;
         this.m_count = 1;
         this.m_v1.Set(this.m_v2);
         return;
      }
      if (d13_1 <= 0.0 && d23_1 <= 0.0) {
         this.m_v3.a = 1.0;
         this.m_count = 1;
         this.m_v1.Set(this.m_v3);
         return;
      }
      if (d23_1 > 0.0 && d23_2 > 0.0 && d123_1 <= 0.0) {
         var inv_d23 = 1.0 / (d23_1 + d23_2);
         this.m_v2.a = d23_1 * inv_d23;
         this.m_v3.a = d23_2 * inv_d23;
         this.m_count = 2;
         this.m_v1.Set(this.m_v3);
         return;
      }
      var inv_d123 = 1.0 / (d123_1 + d123_2 + d123_3);
      this.m_v1.a = d123_1 * inv_d123;
      this.m_v2.a = d123_2 * inv_d123;
      this.m_v3.a = d123_3 * inv_d123;
      this.m_count = 3;
   }
   b2SimplexCache.b2SimplexCache = function () {
      this.indexA = new Vector_a2j_Number(3);
      this.indexB = new Vector_a2j_Number(3);
   };
   b2SimplexVertex.b2SimplexVertex = function () {};
   b2SimplexVertex.prototype.Set = function (other) {
      this.wA.SetV(other.wA);
      this.wB.SetV(other.wB);
      this.w.SetV(other.w);
      this.a = other.a;
      this.indexA = other.indexA;
      this.indexB = other.indexB;
   }
   b2TimeOfImpact.b2TimeOfImpact = function () {};
   b2TimeOfImpact.TimeOfImpact = function (input) {
      ++b2TimeOfImpact.b2_toiCalls;
      var proxyA = input.proxyA;
      var proxyB = input.proxyB;
      var sweepA = input.sweepA;
      var sweepB = input.sweepB;
      b2Settings.b2Assert(sweepA.t0 == sweepB.t0);
      b2Settings.b2Assert(1.0 - sweepA.t0 > FLOAT_EPSILON);
      var radius = proxyA.m_radius + proxyB.m_radius;
      var tolerance = input.tolerance;
      var alpha = 0.0;
      var k_maxIterations = 1000;
      var iter = 0;
      var target = 0.0;
      b2TimeOfImpact.s_cache.count = 0;
      b2TimeOfImpact.s_distanceInput.useRadii = false;
      for (;;) {
         sweepA.GetTransform(b2TimeOfImpact.s_xfA, alpha);
         sweepB.GetTransform(b2TimeOfImpact.s_xfB, alpha);
         b2TimeOfImpact.s_distanceInput.proxyA = proxyA;
         b2TimeOfImpact.s_distanceInput.proxyB = proxyB;
         b2TimeOfImpact.s_distanceInput.transformA = b2TimeOfImpact.s_xfA;
         b2TimeOfImpact.s_distanceInput.transformB = b2TimeOfImpact.s_xfB;
         b2Distance.Distance(b2TimeOfImpact.s_distanceOutput, b2TimeOfImpact.s_cache, b2TimeOfImpact.s_distanceInput);
         if (b2TimeOfImpact.s_distanceOutput.distance <= 0.0) {
            alpha = 1.0;
            break;
         }
         b2TimeOfImpact.s_fcn.Initialize(b2TimeOfImpact.s_cache, proxyA, b2TimeOfImpact.s_xfA, proxyB, b2TimeOfImpact.s_xfB);
         var separation = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
         if (separation <= 0.0) {
            alpha = 1.0;
            break;
         }
         if (iter == 0) {
            if (separation > radius) {
               target = b2Math.Max(radius - tolerance, 0.75 * radius);
            }
            else {
               target = b2Math.Max(separation - tolerance, 0.02 * radius);
            }
         }
         if (separation - target < 0.5 * tolerance) {
            if (iter == 0) {
               alpha = 1.0;
               break;
            }
            break;
         }
         var newAlpha = alpha; {
            var x1 = alpha;
            var x2 = 1.0;
            var f1 = separation;
            sweepA.GetTransform(b2TimeOfImpact.s_xfA, x2);
            sweepB.GetTransform(b2TimeOfImpact.s_xfB, x2);
            var f2 = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
            if (f2 >= target) {
               alpha = 1.0;
               break;
            }
            var rootIterCount = 0;
            for (;;) {
               var x = 0;
               if (rootIterCount & 1) {
                  x = x1 + (target - f1) * (x2 - x1) / (f2 - f1);
               }
               else {
                  x = 0.5 * (x1 + x2);
               }
               sweepA.GetTransform(b2TimeOfImpact.s_xfA, x);
               sweepB.GetTransform(b2TimeOfImpact.s_xfB, x);
               var f = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
               if (b2Math.Abs(f - target) < 0.025 * tolerance) {
                  newAlpha = x;
                  break;
               }
               if (f > target) {
                  x1 = x;
                  f1 = f;
               }
               else {
                  x2 = x;
                  f2 = f;
               }++rootIterCount;
               ++b2TimeOfImpact.b2_toiRootIters;
               if (rootIterCount == 50) {
                  break;
               }
            }
            b2TimeOfImpact.b2_toiMaxRootIters = b2Math.Max(b2TimeOfImpact.b2_toiMaxRootIters, rootIterCount);
         }
         if (newAlpha < (1.0 + 100.0 * FLOAT_EPSILON) * alpha) {
            break;
         }
         alpha = newAlpha;
         iter++;
         ++b2TimeOfImpact.b2_toiIters;
         if (iter == k_maxIterations) {
            break;
         }
      }
      b2TimeOfImpact.b2_toiMaxIters = b2Math.Max(b2TimeOfImpact.b2_toiMaxIters, iter);
      return alpha;
   }
   Box2D.postDefs.push(function () {
      Box2D.Collision.b2TimeOfImpact.b2_toiCalls = 0;
      Box2D.Collision.b2TimeOfImpact.b2_toiIters = 0;
      Box2D.Collision.b2TimeOfImpact.b2_toiMaxIters = 0;
      Box2D.Collision.b2TimeOfImpact.b2_toiRootIters = 0;
      Box2D.Collision.b2TimeOfImpact.b2_toiMaxRootIters = 0;
      Box2D.Collision.b2TimeOfImpact.s_cache = new b2SimplexCache();
      Box2D.Collision.b2TimeOfImpact.s_distanceInput = new b2DistanceInput();
      Box2D.Collision.b2TimeOfImpact.s_xfA = new b2Transform();
      Box2D.Collision.b2TimeOfImpact.s_xfB = new b2Transform();
      Box2D.Collision.b2TimeOfImpact.s_fcn = new b2SeparationFunction();
      Box2D.Collision.b2TimeOfImpact.s_distanceOutput = new b2DistanceOutput();
   });
   b2TOIInput.b2TOIInput = function () {
      this.proxyA = new b2DistanceProxy();
      this.proxyB = new b2DistanceProxy();
      this.sweepA = new b2Sweep();
      this.sweepB = new b2Sweep();
   };
   b2WorldManifold.b2WorldManifold = function () {
      this.m_normal = new b2Vec2();
   };
   b2WorldManifold.prototype.b2WorldManifold = function () {
      this.m_points = new Vector(b2Settings.b2_maxManifoldPoints);
      for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
         this.m_points[i] = new b2Vec2();
      }
   }
   b2WorldManifold.prototype.Initialize = function (manifold, xfA, radiusA, xfB, radiusB) {
      if (radiusA === undefined) radiusA = 0;
      if (radiusB === undefined) radiusB = 0;
      if (manifold.m_pointCount == 0) {
         return;
      }
      var i = 0;
      var tVec;
      var tMat;
      var normalX = 0;
      var normalY = 0;
      var planePointX = 0;
      var planePointY = 0;
      var clipPointX = 0;
      var clipPointY = 0;
      switch (manifold.m_type) {
      case b2Manifold.e_circles:
         {
            tMat = xfA.R;
            tVec = manifold.m_localPoint;
            var pointAX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            var pointAY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tMat = xfB.R;
            tVec = manifold.m_points[0].m_localPoint;
            var pointBX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            var pointBY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            var dX = pointBX - pointAX;
            var dY = pointBY - pointAY;
            var d2 = dX * dX + dY * dY;
            if (d2 > FLOAT_EPSILON * FLOAT_EPSILON) {
               var d = Math.sqrt(d2);
               this.m_normal.x = dX / d;
               this.m_normal.y = dY / d;
            }
            else {
               this.m_normal.x = 1;
               this.m_normal.y = 0;
            }
            var cAX = pointAX + radiusA * this.m_normal.x;
            var cAY = pointAY + radiusA * this.m_normal.y;
            var cBX = pointBX - radiusB * this.m_normal.x;
            var cBY = pointBY - radiusB * this.m_normal.y;
            this.m_points[0].x = 0.5 * (cAX + cBX);
            this.m_points[0].y = 0.5 * (cAY + cBY);
         }
         break;
      case b2Manifold.e_faceA:
         {
            tMat = xfA.R;
            tVec = manifold.m_localPlaneNormal;
            normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tMat = xfA.R;
            tVec = manifold.m_localPoint;
            planePointX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            planePointY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            this.m_normal.x = normalX;
            this.m_normal.y = normalY;
            for (i = 0;
            i < manifold.m_pointCount; i++) {
               tMat = xfB.R;
               tVec = manifold.m_points[i].m_localPoint;
               clipPointX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
               clipPointY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
               this.m_points[i].x = clipPointX + 0.5 * (radiusA - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusB) * normalX;
               this.m_points[i].y = clipPointY + 0.5 * (radiusA - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusB) * normalY;
            }
         }
         break;
      case b2Manifold.e_faceB:
         {
            tMat = xfB.R;
            tVec = manifold.m_localPlaneNormal;
            normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tMat = xfB.R;
            tVec = manifold.m_localPoint;
            planePointX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            planePointY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            this.m_normal.x = (-normalX);
            this.m_normal.y = (-normalY);
            for (i = 0;
            i < manifold.m_pointCount; i++) {
               tMat = xfA.R;
               tVec = manifold.m_points[i].m_localPoint;
               clipPointX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
               clipPointY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
               this.m_points[i].x = clipPointX + 0.5 * (radiusB - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusA) * normalX;
               this.m_points[i].y = clipPointY + 0.5 * (radiusB - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusA) * normalY;
            }
         }
         break;
      }
   }
   ClipVertex.ClipVertex = function () {
      this.v = new b2Vec2();
      this.id = new b2ContactID();
   };
   ClipVertex.prototype.Set = function (other) {
      this.v.SetV(other.v);
      this.id.Set(other.id);
   }
   Features.Features = function () {};
   Object.defineProperty(Features.prototype, 'referenceEdge', {
      enumerable: false,
      configurable: true,
      get: function () {
         return this._referenceEdge;
      }
   });
   Object.defineProperty(Features.prototype, 'referenceEdge', {
      enumerable: false,
      configurable: true,
      set: function (value) {
         if (value === undefined) value = 0;
         this._referenceEdge = value;
         this._m_id._key = (this._m_id._key & 0xffffff00) | (this._referenceEdge & 0x000000ff);
      }
   });
   Object.defineProperty(Features.prototype, 'incidentEdge', {
      enumerable: false,
      configurable: true,
      get: function () {
         return this._incidentEdge;
      }
   });
   Object.defineProperty(Features.prototype, 'incidentEdge', {
      enumerable: false,
      configurable: true,
      set: function (value) {
         if (value === undefined) value = 0;
         this._incidentEdge = value;
         this._m_id._key = (this._m_id._key & 0xffff00ff) | ((this._incidentEdge << 8) & 0x0000ff00);
      }
   });
   Object.defineProperty(Features.prototype, 'incidentVertex', {
      enumerable: false,
      configurable: true,
      get: function () {
         return this._incidentVertex;
      }
   });
   Object.defineProperty(Features.prototype, 'incidentVertex', {
      enumerable: false,
      configurable: true,
      set: function (value) {
         if (value === undefined) value = 0;
         this._incidentVertex = value;
         this._m_id._key = (this._m_id._key & 0xff00ffff) | ((this._incidentVertex << 16) & 0x00ff0000);
      }
   });
   Object.defineProperty(Features.prototype, 'flip', {
      enumerable: false,
      configurable: true,
      get: function () {
         return this._flip;
      }
   });
   Object.defineProperty(Features.prototype, 'flip', {
      enumerable: false,
      configurable: true,
      set: function (value) {
         if (value === undefined) value = 0;
         this._flip = value;
         this._m_id._key = (this._m_id._key & 0x00ffffff) | ((this._flip << 24) & 0xff000000);
      }
   });
})();
(function () {
   var b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
      b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
      b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
      b2MassData = Box2D.Collision.Shapes.b2MassData,
      b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
      b2Shape = Box2D.Collision.Shapes.b2Shape,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3,
      b2Body = Box2D.Dynamics.b2Body,
      b2BodyDef = Box2D.Dynamics.b2BodyDef,
      b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
      b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
      b2ContactListener = Box2D.Dynamics.b2ContactListener,
      b2ContactManager = Box2D.Dynamics.b2ContactManager,
      b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
      b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
      b2FilterData = Box2D.Dynamics.b2FilterData,
      b2Fixture = Box2D.Dynamics.b2Fixture,
      b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
      b2Island = Box2D.Dynamics.b2Island,
      b2TimeStep = Box2D.Dynamics.b2TimeStep,
      b2World = Box2D.Dynamics.b2World,
      b2AABB = Box2D.Collision.b2AABB,
      b2Bound = Box2D.Collision.b2Bound,
      b2BoundValues = Box2D.Collision.b2BoundValues,
      b2Collision = Box2D.Collision.b2Collision,
      b2ContactID = Box2D.Collision.b2ContactID,
      b2ContactPoint = Box2D.Collision.b2ContactPoint,
      b2Distance = Box2D.Collision.b2Distance,
      b2DistanceInput = Box2D.Collision.b2DistanceInput,
      b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
      b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
      b2DynamicTree = Box2D.Collision.b2DynamicTree,
      b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
      b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
      b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
      b2Manifold = Box2D.Collision.b2Manifold,
      b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
      b2Point = Box2D.Collision.b2Point,
      b2RayCastInput = Box2D.Collision.b2RayCastInput,
      b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
      b2Segment = Box2D.Collision.b2Segment,
      b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
      b2Simplex = Box2D.Collision.b2Simplex,
      b2SimplexCache = Box2D.Collision.b2SimplexCache,
      b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
      b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
      b2TOIInput = Box2D.Collision.b2TOIInput,
      b2WorldManifold = Box2D.Collision.b2WorldManifold,
      ClipVertex = Box2D.Collision.ClipVertex,
      Features = Box2D.Collision.Features,
      IBroadPhase = Box2D.Collision.IBroadPhase;

   Box2D.inherit(b2CircleShape, Box2D.Collision.Shapes.b2Shape);
   b2CircleShape.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype;
   b2CircleShape.b2CircleShape = function () {
      Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments);
      this.m_p = new b2Vec2();
   };
   b2CircleShape.prototype.Copy = function () {
      var s = new b2CircleShape();
      s.Set(this);
      return s;
   }
   b2CircleShape.prototype.Set = function (other) {
      this.__super.Set.call(this, other);
      if (Box2D.is(other, b2CircleShape)) {
         var other2 = (other instanceof b2CircleShape ? other : null);
         this.m_p.SetV(other2.m_p);
      }
   }
   b2CircleShape.prototype.TestPoint = function (transform, p) {
      var tMat = transform.R;
      var dX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
      var dY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
      dX = p.x - dX;
      dY = p.y - dY;
      return (dX * dX + dY * dY) <= this.m_radius * this.m_radius;
   }
   b2CircleShape.prototype.RayCast = function (output, input, transform) {
      var tMat = transform.R;
      var positionX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
      var positionY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
      var sX = input.p1.x - positionX;
      var sY = input.p1.y - positionY;
      var b = (sX * sX + sY * sY) - this.m_radius * this.m_radius;
      var rX = input.p2.x - input.p1.x;
      var rY = input.p2.y - input.p1.y;
      var c = (sX * rX + sY * rY);
      var rr = (rX * rX + rY * rY);
      var sigma = c * c - rr * b;
      if (sigma < 0.0 || rr < FLOAT_EPSILON) {
         return false;
      }
      var a = (-(c + Math.sqrt(sigma)));
      if (0.0 <= a && a <= input.maxFraction * rr) {
         a /= rr;
         output.fraction = a;
         output.normal.x = sX + a * rX;
         output.normal.y = sY + a * rY;
         output.normal.Normalize();
         return true;
      }
      return false;
   }
   b2CircleShape.prototype.ComputeAABB = function (aabb, transform) {
      var tMat = transform.R;
      var pX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
      var pY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
      aabb.lowerBound.Set(pX - this.m_radius, pY - this.m_radius);
      aabb.upperBound.Set(pX + this.m_radius, pY + this.m_radius);
   }
   b2CircleShape.prototype.ComputeMass = function (massData, density) {
      if (density === undefined) density = 0;
      massData.mass = density * b2Settings.b2_pi * this.m_radius * this.m_radius;
      massData.center.SetV(this.m_p);
      massData.I = massData.mass * (0.5 * this.m_radius * this.m_radius + (this.m_p.x * this.m_p.x + this.m_p.y * this.m_p.y));
   }
   b2CircleShape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c) {
      if (offset === undefined) offset = 0;
      var p = b2Math.MulX(xf, this.m_p);
      var l = (-(b2Math.Dot(normal, p) - offset));
      if (l < (-this.m_radius) + FLOAT_EPSILON) {
         return 0;
      }
      if (l > this.m_radius) {
         c.SetV(p);
         return Math.PI * this.m_radius * this.m_radius;
      }
      var r2 = this.m_radius * this.m_radius;
      var l2 = l * l;
      var area = r2 * (Math.asin(l / this.m_radius) + Math.PI / 2) + l * Math.sqrt(r2 - l2);
      var com = (-2 / 3 * Math.pow(r2 - l2, 1.5) / area);
      c.x = p.x + normal.x * com;
      c.y = p.y + normal.y * com;
      return area;
   }
   b2CircleShape.prototype.GetLocalPosition = function () {
      return this.m_p;
   }
   b2CircleShape.prototype.SetLocalPosition = function (position) {
      this.m_p.SetV(position);
   }
   b2CircleShape.prototype.GetRadius = function () {
      return this.m_radius;
   }
   b2CircleShape.prototype.SetRadius = function (radius) {
      if (radius === undefined) radius = 0;
      this.m_radius = radius;
   }
   b2CircleShape.prototype.b2CircleShape = function (radius) {
      if (radius === undefined) radius = 0;
      this.__super.b2Shape.call(this);
      this.m_type = b2Shape.e_circleShape;
      this.m_radius = radius;
   }
   b2EdgeChainDef.b2EdgeChainDef = function () {};
   b2EdgeChainDef.prototype.b2EdgeChainDef = function () {
      this.vertexCount = 0;
      this.isALoop = true;
      this.vertices = [];
   }
   Box2D.inherit(b2EdgeShape, Box2D.Collision.Shapes.b2Shape);
   b2EdgeShape.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype;
   b2EdgeShape.b2EdgeShape = function () {
      Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments);
      this.s_supportVec = new b2Vec2();
      this.m_v1 = new b2Vec2();
      this.m_v2 = new b2Vec2();
      this.m_coreV1 = new b2Vec2();
      this.m_coreV2 = new b2Vec2();
      this.m_normal = new b2Vec2();
      this.m_direction = new b2Vec2();
      this.m_cornerDir1 = new b2Vec2();
      this.m_cornerDir2 = new b2Vec2();
   };
   b2EdgeShape.prototype.TestPoint = function (transform, p) {
      return false;
   }
   b2EdgeShape.prototype.RayCast = function (output, input, transform) {
      var tMat;
      var rX = input.p2.x - input.p1.x;
      var rY = input.p2.y - input.p1.y;
      tMat = transform.R;
      var v1X = transform.position.x + (tMat.col1.x * this.m_v1.x + tMat.col2.x * this.m_v1.y);
      var v1Y = transform.position.y + (tMat.col1.y * this.m_v1.x + tMat.col2.y * this.m_v1.y);
      var nX = transform.position.y + (tMat.col1.y * this.m_v2.x + tMat.col2.y * this.m_v2.y) - v1Y;
      var nY = (-(transform.position.x + (tMat.col1.x * this.m_v2.x + tMat.col2.x * this.m_v2.y) - v1X));
      var k_slop = 100.0 * FLOAT_EPSILON;
      var denom = (-(rX * nX + rY * nY));
      if (denom > k_slop) {
         var bX = input.p1.x - v1X;
         var bY = input.p1.y - v1Y;
         var a = (bX * nX + bY * nY);
         if (0.0 <= a && a <= input.maxFraction * denom) {
            var mu2 = (-rX * bY) + rY * bX;
            if ((-k_slop * denom) <= mu2 && mu2 <= denom * (1.0 + k_slop)) {
               a /= denom;
               output.fraction = a;
               var nLen = Math.sqrt(nX * nX + nY * nY);
               output.normal.x = nX / nLen;
               output.normal.y = nY / nLen;
               return true;
            }
         }
      }
      return false;
   }
   b2EdgeShape.prototype.ComputeAABB = function (aabb, transform) {
      var tMat = transform.R;
      var v1X = transform.position.x + (tMat.col1.x * this.m_v1.x + tMat.col2.x * this.m_v1.y);
      var v1Y = transform.position.y + (tMat.col1.y * this.m_v1.x + tMat.col2.y * this.m_v1.y);
      var v2X = transform.position.x + (tMat.col1.x * this.m_v2.x + tMat.col2.x * this.m_v2.y);
      var v2Y = transform.position.y + (tMat.col1.y * this.m_v2.x + tMat.col2.y * this.m_v2.y);
      if (v1X < v2X) {
         aabb.lowerBound.x = v1X;
         aabb.upperBound.x = v2X;
      }
      else {
         aabb.lowerBound.x = v2X;
         aabb.upperBound.x = v1X;
      }
      if (v1Y < v2Y) {
         aabb.lowerBound.y = v1Y;
         aabb.upperBound.y = v2Y;
      }
      else {
         aabb.lowerBound.y = v2Y;
         aabb.upperBound.y = v1Y;
      }
   }
   b2EdgeShape.prototype.ComputeMass = function (massData, density) {
      if (density === undefined) density = 0;
      massData.mass = 0;
      massData.center.SetV(this.m_v1);
      massData.I = 0;
   }
   b2EdgeShape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c) {
      if (offset === undefined) offset = 0;
      var v0 = new b2Vec2(normal.x * offset, normal.y * offset);
      var v1 = b2Math.MulX(xf, this.m_v1);
      var v2 = b2Math.MulX(xf, this.m_v2);
      var d1 = b2Math.Dot(normal, v1) - offset;
      var d2 = b2Math.Dot(normal, v2) - offset;
      if (d1 > 0) {
         if (d2 > 0) {
            return 0;
         }
         else {
            v1.x = (-d2 / (d1 - d2) * v1.x) + d1 / (d1 - d2) * v2.x;
            v1.y = (-d2 / (d1 - d2) * v1.y) + d1 / (d1 - d2) * v2.y;
         }
      }
      else {
         if (d2 > 0) {
            v2.x = (-d2 / (d1 - d2) * v1.x) + d1 / (d1 - d2) * v2.x;
            v2.y = (-d2 / (d1 - d2) * v1.y) + d1 / (d1 - d2) * v2.y;
         }
         else {}
      }
      c.x = (v0.x + v1.x + v2.x) / 3;
      c.y = (v0.y + v1.y + v2.y) / 3;
      return 0.5 * ((v1.x - v0.x) * (v2.y - v0.y) - (v1.y - v0.y) * (v2.x - v0.x));
   }
   b2EdgeShape.prototype.GetLength = function () {
      return this.m_length;
   }
   b2EdgeShape.prototype.GetVertex1 = function () {
      return this.m_v1;
   }
   b2EdgeShape.prototype.GetVertex2 = function () {
      return this.m_v2;
   }
   b2EdgeShape.prototype.GetCoreVertex1 = function () {
      return this.m_coreV1;
   }
   b2EdgeShape.prototype.GetCoreVertex2 = function () {
      return this.m_coreV2;
   }
   b2EdgeShape.prototype.GetNormalVector = function () {
      return this.m_normal;
   }
   b2EdgeShape.prototype.GetDirectionVector = function () {
      return this.m_direction;
   }
   b2EdgeShape.prototype.GetCorner1Vector = function () {
      return this.m_cornerDir1;
   }
   b2EdgeShape.prototype.GetCorner2Vector = function () {
      return this.m_cornerDir2;
   }
   b2EdgeShape.prototype.Corner1IsConvex = function () {
      return this.m_cornerConvex1;
   }
   b2EdgeShape.prototype.Corner2IsConvex = function () {
      return this.m_cornerConvex2;
   }
   b2EdgeShape.prototype.GetFirstVertex = function (xf) {
      var tMat = xf.R;
      return new b2Vec2(xf.position.x + (tMat.col1.x * this.m_coreV1.x + tMat.col2.x * this.m_coreV1.y), xf.position.y + (tMat.col1.y * this.m_coreV1.x + tMat.col2.y * this.m_coreV1.y));
   }
   b2EdgeShape.prototype.GetNextEdge = function () {
      return this.m_nextEdge;
   }
   b2EdgeShape.prototype.GetPrevEdge = function () {
      return this.m_prevEdge;
   }
   b2EdgeShape.prototype.Support = function (xf, dX, dY) {
      if (dX === undefined) dX = 0;
      if (dY === undefined) dY = 0;
      var tMat = xf.R;
      var v1X = xf.position.x + (tMat.col1.x * this.m_coreV1.x + tMat.col2.x * this.m_coreV1.y);
      var v1Y = xf.position.y + (tMat.col1.y * this.m_coreV1.x + tMat.col2.y * this.m_coreV1.y);
      var v2X = xf.position.x + (tMat.col1.x * this.m_coreV2.x + tMat.col2.x * this.m_coreV2.y);
      var v2Y = xf.position.y + (tMat.col1.y * this.m_coreV2.x + tMat.col2.y * this.m_coreV2.y);
      if ((v1X * dX + v1Y * dY) > (v2X * dX + v2Y * dY)) {
         this.s_supportVec.x = v1X;
         this.s_supportVec.y = v1Y;
      }
      else {
         this.s_supportVec.x = v2X;
         this.s_supportVec.y = v2Y;
      }
      return this.s_supportVec;
   }
   b2EdgeShape.prototype.b2EdgeShape = function (v1, v2) {
      this.__super.b2Shape.call(this);
      this.m_type = b2Shape.e_edgeShape;
      this.m_prevEdge = null;
      this.m_nextEdge = null;
      this.m_v1 = v1;
      this.m_v2 = v2;
      this.m_direction.Set(this.m_v2.x - this.m_v1.x, this.m_v2.y - this.m_v1.y);
      this.m_length = this.m_direction.Normalize();
      this.m_normal.Set(this.m_direction.y, (-this.m_direction.x));
      this.m_coreV1.Set((-b2Settings.b2_toiSlop * (this.m_normal.x - this.m_direction.x)) + this.m_v1.x, (-b2Settings.b2_toiSlop * (this.m_normal.y - this.m_direction.y)) + this.m_v1.y);
      this.m_coreV2.Set((-b2Settings.b2_toiSlop * (this.m_normal.x + this.m_direction.x)) + this.m_v2.x, (-b2Settings.b2_toiSlop * (this.m_normal.y + this.m_direction.y)) + this.m_v2.y);
      this.m_cornerDir1 = this.m_normal;
      this.m_cornerDir2.Set((-this.m_normal.x), (-this.m_normal.y));
   }
   b2EdgeShape.prototype.SetPrevEdge = function (edge, core, cornerDir, convex) {
      this.m_prevEdge = edge;
      this.m_coreV1 = core;
      this.m_cornerDir1 = cornerDir;
      this.m_cornerConvex1 = convex;
   }
   b2EdgeShape.prototype.SetNextEdge = function (edge, core, cornerDir, convex) {
      this.m_nextEdge = edge;
      this.m_coreV2 = core;
      this.m_cornerDir2 = cornerDir;
      this.m_cornerConvex2 = convex;
   }
   b2MassData.b2MassData = function () {
      this.mass = 0.0;
      this.center = new b2Vec2(0, 0);
      this.I = 0.0;
   };
   Box2D.inherit(b2PolygonShape, Box2D.Collision.Shapes.b2Shape);
   b2PolygonShape.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype;
   b2PolygonShape.b2PolygonShape = function () {
      Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments);
   };
   b2PolygonShape.prototype.Copy = function () {
      var s = new b2PolygonShape();
      s.Set(this);
      return s;
   }
   b2PolygonShape.prototype.Set = function (other) {
      this.__super.Set.call(this, other);
      if (Box2D.is(other, b2PolygonShape)) {
         var other2 = (other instanceof b2PolygonShape ? other : null);
         this.m_centroid.SetV(other2.m_centroid);
         this.m_vertexCount = other2.m_vertexCount;
         this.Reserve(this.m_vertexCount);
         for (var i = 0; i < this.m_vertexCount; i++) {
            this.m_vertices[i].SetV(other2.m_vertices[i]);
            this.m_normals[i].SetV(other2.m_normals[i]);
         }
      }
   }
   b2PolygonShape.prototype.SetAsArray = function (vertices, vertexCount) {
      if (vertexCount === undefined) vertexCount = 0;
      var v = new Vector();
      var i = 0,
         tVec;
      for (i = 0;
      i < vertices.length; ++i) {
         tVec = vertices[i];
         v.push(tVec);
      }
      this.SetAsVector(v, vertexCount);
   }
   b2PolygonShape.AsArray = function (vertices, vertexCount) {
      if (vertexCount === undefined) vertexCount = 0;
      var polygonShape = new b2PolygonShape();
      polygonShape.SetAsArray(vertices, vertexCount);
      return polygonShape;
   }
   b2PolygonShape.prototype.SetAsVector = function (vertices, vertexCount) {
      if (vertexCount === undefined) vertexCount = 0;
      if (vertexCount == 0) vertexCount = vertices.length;
      b2Settings.b2Assert(2 <= vertexCount);
      this.m_vertexCount = vertexCount;
      this.Reserve(vertexCount);
      var i = 0;
      for (i = 0;
      i < this.m_vertexCount; i++) {
         this.m_vertices[i].SetV(vertices[i]);
      }
      for (i = 0;
      i < this.m_vertexCount; ++i) {
         var i1 = parseInt(i);
         var i2 = parseInt(i + 1 < this.m_vertexCount ? i + 1 : 0);
         var edge = b2Math.SubtractVV(this.m_vertices[i2], this.m_vertices[i1]);
         b2Settings.b2Assert(edge.LengthSquared() > FLOAT_EPSILON);
         this.m_normals[i].SetV(b2Math.CrossVF(edge, 1.0));
         this.m_normals[i].Normalize();
      }
      this.m_centroid = b2PolygonShape.ComputeCentroid(this.m_vertices, this.m_vertexCount);
   }
   b2PolygonShape.AsVector = function (vertices, vertexCount) {
      if (vertexCount === undefined) vertexCount = 0;
      var polygonShape = new b2PolygonShape();
      polygonShape.SetAsVector(vertices, vertexCount);
      return polygonShape;
   }
   b2PolygonShape.prototype.SetAsBox = function (hx, hy) {
      if (hx === undefined) hx = 0;
      if (hy === undefined) hy = 0;
      this.m_vertexCount = 4;
      this.Reserve(4);
      this.m_vertices[0].Set((-hx), (-hy));
      this.m_vertices[1].Set(hx, (-hy));
      this.m_vertices[2].Set(hx, hy);
      this.m_vertices[3].Set((-hx), hy);
      this.m_normals[0].Set(0.0, (-1.0));
      this.m_normals[1].Set(1.0, 0.0);
      this.m_normals[2].Set(0.0, 1.0);
      this.m_normals[3].Set((-1.0), 0.0);
      this.m_centroid.SetZero();
   }
   b2PolygonShape.AsBox = function (hx, hy) {
      if (hx === undefined) hx = 0;
      if (hy === undefined) hy = 0;
      var polygonShape = new b2PolygonShape();
      polygonShape.SetAsBox(hx, hy);
      return polygonShape;
   }
   b2PolygonShape.prototype.SetAsOrientedBox = function (hx, hy, center, angle) {
      if (hx === undefined) hx = 0;
      if (hy === undefined) hy = 0;
      if (center === undefined) center = null;
      if (angle === undefined) angle = 0.0;
      this.m_vertexCount = 4;
      this.Reserve(4);
      this.m_vertices[0].Set((-hx), (-hy));
      this.m_vertices[1].Set(hx, (-hy));
      this.m_vertices[2].Set(hx, hy);
      this.m_vertices[3].Set((-hx), hy);
      this.m_normals[0].Set(0.0, (-1.0));
      this.m_normals[1].Set(1.0, 0.0);
      this.m_normals[2].Set(0.0, 1.0);
      this.m_normals[3].Set((-1.0), 0.0);
      this.m_centroid = center;
      var xf = new b2Transform();
      xf.position = center;
      xf.R.Set(angle);
      for (var i = 0; i < this.m_vertexCount; ++i) {
         this.m_vertices[i] = b2Math.MulX(xf, this.m_vertices[i]);
         this.m_normals[i] = b2Math.MulMV(xf.R, this.m_normals[i]);
      }
   }
   b2PolygonShape.AsOrientedBox = function (hx, hy, center, angle) {
      if (hx === undefined) hx = 0;
      if (hy === undefined) hy = 0;
      if (center === undefined) center = null;
      if (angle === undefined) angle = 0.0;
      var polygonShape = new b2PolygonShape();
      polygonShape.SetAsOrientedBox(hx, hy, center, angle);
      return polygonShape;
   }
   b2PolygonShape.prototype.SetAsEdge = function (v1, v2) {
      this.m_vertexCount = 2;
      this.Reserve(2);
      this.m_vertices[0].SetV(v1);
      this.m_vertices[1].SetV(v2);
      this.m_centroid.x = 0.5 * (v1.x + v2.x);
      this.m_centroid.y = 0.5 * (v1.y + v2.y);
      this.m_normals[0] = b2Math.CrossVF(b2Math.SubtractVV(v2, v1), 1.0);
      this.m_normals[0].Normalize();
      this.m_normals[1].x = (-this.m_normals[0].x);
      this.m_normals[1].y = (-this.m_normals[0].y);
   }
   b2PolygonShape.AsEdge = function (v1, v2) {
      var polygonShape = new b2PolygonShape();
      polygonShape.SetAsEdge(v1, v2);
      return polygonShape;
   }
   b2PolygonShape.prototype.TestPoint = function (xf, p) {
      var tVec;
      var tMat = xf.R;
      var tX = p.x - xf.position.x;
      var tY = p.y - xf.position.y;
      var pLocalX = (tX * tMat.col1.x + tY * tMat.col1.y);
      var pLocalY = (tX * tMat.col2.x + tY * tMat.col2.y);
      for (var i = 0; i < this.m_vertexCount; ++i) {
         tVec = this.m_vertices[i];
         tX = pLocalX - tVec.x;
         tY = pLocalY - tVec.y;
         tVec = this.m_normals[i];
         var dot = (tVec.x * tX + tVec.y * tY);
         if (dot > 0.0) {
            return false;
         }
      }
      return true;
   }
   b2PolygonShape.prototype.RayCast = function (output, input, transform) {
      var lower = 0.0;
      var upper = input.maxFraction;
      var tX = 0;
      var tY = 0;
      var tMat;
      var tVec;
      tX = input.p1.x - transform.position.x;
      tY = input.p1.y - transform.position.y;
      tMat = transform.R;
      var p1X = (tX * tMat.col1.x + tY * tMat.col1.y);
      var p1Y = (tX * tMat.col2.x + tY * tMat.col2.y);
      tX = input.p2.x - transform.position.x;
      tY = input.p2.y - transform.position.y;
      tMat = transform.R;
      var p2X = (tX * tMat.col1.x + tY * tMat.col1.y);
      var p2Y = (tX * tMat.col2.x + tY * tMat.col2.y);
      var dX = p2X - p1X;
      var dY = p2Y - p1Y;
      var index = parseInt((-1));
      for (var i = 0; i < this.m_vertexCount; ++i) {
         tVec = this.m_vertices[i];
         tX = tVec.x - p1X;
         tY = tVec.y - p1Y;
         tVec = this.m_normals[i];
         var numerator = (tVec.x * tX + tVec.y * tY);
         var denominator = (tVec.x * dX + tVec.y * dY);
         if (denominator == 0.0) {
            if (numerator < 0.0) {
               return false;
            }
         }
         else {
            if (denominator < 0.0 && numerator < lower * denominator) {
               lower = numerator / denominator;
               index = i;
            }
            else if (denominator > 0.0 && numerator < upper * denominator) {
               upper = numerator / denominator;
            }
         }
         if (upper < lower - FLOAT_EPSILON) {
            return false;
         }
      }
      if (index >= 0) {
         output.fraction = lower;
         tMat = transform.R;
         tVec = this.m_normals[index];
         output.normal.x = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         output.normal.y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         return true;
      }
      return false;
   }
   b2PolygonShape.prototype.ComputeAABB = function (aabb, xf) {
      var tMat = xf.R;
      var tVec = this.m_vertices[0];
      var lowerX = xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var lowerY = xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      var upperX = lowerX;
      var upperY = lowerY;
      for (var i = 1; i < this.m_vertexCount; ++i) {
         tVec = this.m_vertices[i];
         var vX = xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         var vY = xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         lowerX = lowerX < vX ? lowerX : vX;
         lowerY = lowerY < vY ? lowerY : vY;
         upperX = upperX > vX ? upperX : vX;
         upperY = upperY > vY ? upperY : vY;
      }
      aabb.lowerBound.x = lowerX - this.m_radius;
      aabb.lowerBound.y = lowerY - this.m_radius;
      aabb.upperBound.x = upperX + this.m_radius;
      aabb.upperBound.y = upperY + this.m_radius;
   }
   b2PolygonShape.prototype.ComputeMass = function (massData, density) {
      if (density === undefined) density = 0;
      if (this.m_vertexCount == 2) {
         massData.center.x = 0.5 * (this.m_vertices[0].x + this.m_vertices[1].x);
         massData.center.y = 0.5 * (this.m_vertices[0].y + this.m_vertices[1].y);
         massData.mass = 0.0;
         massData.I = 0.0;
         return;
      }
      var centerX = 0.0;
      var centerY = 0.0;
      var area = 0.0;
      var I = 0.0;
      var p1X = 0.0;
      var p1Y = 0.0;
      var k_inv3 = 1.0 / 3.0;
      for (var i = 0; i < this.m_vertexCount; ++i) {
         var p2 = this.m_vertices[i];
         var p3 = i + 1 < this.m_vertexCount ? this.m_vertices[parseInt(i + 1)] : this.m_vertices[0];
         var e1X = p2.x - p1X;
         var e1Y = p2.y - p1Y;
         var e2X = p3.x - p1X;
         var e2Y = p3.y - p1Y;
         var D = e1X * e2Y - e1Y * e2X;
         var triangleArea = 0.5 * D;area += triangleArea;
         centerX += triangleArea * k_inv3 * (p1X + p2.x + p3.x);
         centerY += triangleArea * k_inv3 * (p1Y + p2.y + p3.y);
         var px = p1X;
         var py = p1Y;
         var ex1 = e1X;
         var ey1 = e1Y;
         var ex2 = e2X;
         var ey2 = e2Y;
         var intx2 = k_inv3 * (0.25 * (ex1 * ex1 + ex2 * ex1 + ex2 * ex2) + (px * ex1 + px * ex2)) + 0.5 * px * px;
         var inty2 = k_inv3 * (0.25 * (ey1 * ey1 + ey2 * ey1 + ey2 * ey2) + (py * ey1 + py * ey2)) + 0.5 * py * py;I += D * (intx2 + inty2);
      }
      massData.mass = density * area;
      centerX *= 1.0 / area;
      centerY *= 1.0 / area;
      massData.center.Set(centerX, centerY);
      massData.I = density * I;
   }
   b2PolygonShape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c) {
      if (offset === undefined) offset = 0;
      var normalL = b2Math.MulTMV(xf.R, normal);
      var offsetL = offset - b2Math.Dot(normal, xf.position);
      var depths = new Vector_a2j_Number();
      var diveCount = 0;
      var intoIndex = parseInt((-1));
      var outoIndex = parseInt((-1));
      var lastSubmerged = false;
      var i = 0;
      for (i = 0;
      i < this.m_vertexCount; ++i) {
         depths[i] = b2Math.Dot(normalL, this.m_vertices[i]) - offsetL;
         var isSubmerged = depths[i] < (-FLOAT_EPSILON);
         if (i > 0) {
            if (isSubmerged) {
               if (!lastSubmerged) {
                  intoIndex = i - 1;
                  diveCount++;
               }
            }
            else {
               if (lastSubmerged) {
                  outoIndex = i - 1;
                  diveCount++;
               }
            }
         }
         lastSubmerged = isSubmerged;
      }
      switch (diveCount) {
      case 0:
         if (lastSubmerged) {
            var md = new b2MassData();
            this.ComputeMass(md, 1);
            c.SetV(b2Math.MulX(xf, md.center));
            return md.mass;
         }
         else {
            return 0;
         }
         break;
      case 1:
         if (intoIndex == (-1)) {
            intoIndex = this.m_vertexCount - 1;
         }
         else {
            outoIndex = this.m_vertexCount - 1;
         }
         break;
      }
      var intoIndex2 = parseInt((intoIndex + 1) % this.m_vertexCount);
      var outoIndex2 = parseInt((outoIndex + 1) % this.m_vertexCount);
      var intoLamdda = (0 - depths[intoIndex]) / (depths[intoIndex2] - depths[intoIndex]);
      var outoLamdda = (0 - depths[outoIndex]) / (depths[outoIndex2] - depths[outoIndex]);
      var intoVec = new b2Vec2(this.m_vertices[intoIndex].x * (1 - intoLamdda) + this.m_vertices[intoIndex2].x * intoLamdda, this.m_vertices[intoIndex].y * (1 - intoLamdda) + this.m_vertices[intoIndex2].y * intoLamdda);
      var outoVec = new b2Vec2(this.m_vertices[outoIndex].x * (1 - outoLamdda) + this.m_vertices[outoIndex2].x * outoLamdda, this.m_vertices[outoIndex].y * (1 - outoLamdda) + this.m_vertices[outoIndex2].y * outoLamdda);
      var area = 0;
      var center = new b2Vec2();
      var p2 = this.m_vertices[intoIndex2];
      var p3;
      i = intoIndex2;
      while (i != outoIndex2) {
         i = (i + 1) % this.m_vertexCount;
         if (i == outoIndex2) p3 = outoVec;
         else p3 = this.m_vertices[i];
         var triangleArea = 0.5 * ((p2.x - intoVec.x) * (p3.y - intoVec.y) - (p2.y - intoVec.y) * (p3.x - intoVec.x));
         area += triangleArea;
         center.x += triangleArea * (intoVec.x + p2.x + p3.x) / 3;
         center.y += triangleArea * (intoVec.y + p2.y + p3.y) / 3;
         p2 = p3;
      }
      center.Multiply(1 / area);
      c.SetV(b2Math.MulX(xf, center));
      return area;
   }
   b2PolygonShape.prototype.GetVertexCount = function () {
      return this.m_vertexCount;
   }
   b2PolygonShape.prototype.GetVertices = function () {
      return this.m_vertices;
   }
   b2PolygonShape.prototype.GetNormals = function () {
      return this.m_normals;
   }
   b2PolygonShape.prototype.GetSupport = function (d) {
      var bestIndex = 0;
      var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
      for (var i = 1; i < this.m_vertexCount; ++i) {
         var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
         if (value > bestValue) {
            bestIndex = i;
            bestValue = value;
         }
      }
      return bestIndex;
   }
   b2PolygonShape.prototype.GetSupportVertex = function (d) {
      var bestIndex = 0;
      var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
      for (var i = 1; i < this.m_vertexCount; ++i) {
         var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
         if (value > bestValue) {
            bestIndex = i;
            bestValue = value;
         }
      }
      return this.m_vertices[bestIndex];
   }
   b2PolygonShape.prototype.Validate = function () {
      return false;
   }
   b2PolygonShape.prototype.b2PolygonShape = function () {
      this.__super.b2Shape.call(this);
      this.m_type = b2Shape.e_polygonShape;
      this.m_centroid = new b2Vec2();
      this.m_vertices = new Vector();
      this.m_normals = new Vector();
   }
   b2PolygonShape.prototype.Reserve = function (count) {
      if (count === undefined) count = 0;
      for (var i = parseInt(this.m_vertices.length); i < count; i++) {
         this.m_vertices[i] = new b2Vec2();
         this.m_normals[i] = new b2Vec2();
      }
   }
   b2PolygonShape.ComputeCentroid = function (vs, count) {
      if (count === undefined) count = 0;
      var c = new b2Vec2();
      var area = 0.0;
      var p1X = 0.0;
      var p1Y = 0.0;
      var inv3 = 1.0 / 3.0;
      for (var i = 0; i < count; ++i) {
         var p2 = vs[i];
         var p3 = i + 1 < count ? vs[parseInt(i + 1)] : vs[0];
         var e1X = p2.x - p1X;
         var e1Y = p2.y - p1Y;
         var e2X = p3.x - p1X;
         var e2Y = p3.y - p1Y;
         var D = (e1X * e2Y - e1Y * e2X);
         var triangleArea = 0.5 * D;area += triangleArea;
         c.x += triangleArea * inv3 * (p1X + p2.x + p3.x);
         c.y += triangleArea * inv3 * (p1Y + p2.y + p3.y);
      }
      c.x *= 1.0 / area;
      c.y *= 1.0 / area;
      return c;
   }
   b2PolygonShape.ComputeOBB = function (obb, vs, count) {
      if (count === undefined) count = 0;
      var i = 0;
      var p = new Vector(count + 1);
      for (i = 0;
      i < count; ++i) {
         p[i] = vs[i];
      }
      p[count] = p[0];
      var minArea = Number.MAX_VALUE;
      for (i = 1;
      i <= count; ++i) {
         var root = p[parseInt(i - 1)];
         var uxX = p[i].x - root.x;
         var uxY = p[i].y - root.y;
         var length = Math.sqrt(uxX * uxX + uxY * uxY);
         uxX /= length;
         uxY /= length;
         var uyX = (-uxY);
         var uyY = uxX;
         var lowerX = Number.MAX_VALUE;
         var lowerY = Number.MAX_VALUE;
         var upperX = (-Number.MAX_VALUE);
         var upperY = (-Number.MAX_VALUE);
         for (var j = 0; j < count; ++j) {
            var dX = p[j].x - root.x;
            var dY = p[j].y - root.y;
            var rX = (uxX * dX + uxY * dY);
            var rY = (uyX * dX + uyY * dY);
            if (rX < lowerX) lowerX = rX;
            if (rY < lowerY) lowerY = rY;
            if (rX > upperX) upperX = rX;
            if (rY > upperY) upperY = rY;
         }
         var area = (upperX - lowerX) * (upperY - lowerY);
         if (area < 0.95 * minArea) {
            minArea = area;
            obb.R.col1.x = uxX;
            obb.R.col1.y = uxY;
            obb.R.col2.x = uyX;
            obb.R.col2.y = uyY;
            var centerX = 0.5 * (lowerX + upperX);
            var centerY = 0.5 * (lowerY + upperY);
            var tMat = obb.R;
            obb.center.x = root.x + (tMat.col1.x * centerX + tMat.col2.x * centerY);
            obb.center.y = root.y + (tMat.col1.y * centerX + tMat.col2.y * centerY);
            obb.extents.x = 0.5 * (upperX - lowerX);
            obb.extents.y = 0.5 * (upperY - lowerY);
         }
      }
   }
   Box2D.postDefs.push(function () {
      Box2D.Collision.Shapes.b2PolygonShape.s_mat = new b2Mat22();
   });
   b2Shape.b2Shape = function () {};
   b2Shape.prototype.Copy = function () {
      return null;
   }
   b2Shape.prototype.Set = function (other) {
      this.m_radius = other.m_radius;
   }
   b2Shape.prototype.GetType = function () {
      return this.m_type;
   }
   b2Shape.prototype.TestPoint = function (xf, p) {
      return false;
   }
   b2Shape.prototype.RayCast = function (output, input, transform) {
      return false;
   }
   b2Shape.prototype.ComputeAABB = function (aabb, xf) {}
   b2Shape.prototype.ComputeMass = function (massData, density) {
      if (density === undefined) density = 0;
   }
   b2Shape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c) {
      if (offset === undefined) offset = 0;
      return 0;
   }
   b2Shape.TestOverlap = function (shape1, transform1, shape2, transform2) {
      var input = new b2DistanceInput();
      input.proxyA = new b2DistanceProxy();
      input.proxyA.Set(shape1);
      input.proxyB = new b2DistanceProxy();
      input.proxyB.Set(shape2);
      input.transformA = transform1;
      input.transformB = transform2;
      input.useRadii = true;
      var simplexCache = new b2SimplexCache();
      simplexCache.count = 0;
      var output = new b2DistanceOutput();
      b2Distance.Distance(output, simplexCache, input);
      return output.distance < 10.0 * FLOAT_EPSILON;
   }
   b2Shape.prototype.b2Shape = function () {
      this.m_type = b2Shape.e_unknownShape;
      this.m_radius = b2Settings.b2_linearSlop;
   }
   Box2D.postDefs.push(function () {
      Box2D.Collision.Shapes.b2Shape.e_unknownShape = parseInt((-1));
      Box2D.Collision.Shapes.b2Shape.e_circleShape = 0;
      Box2D.Collision.Shapes.b2Shape.e_polygonShape = 1;
      Box2D.Collision.Shapes.b2Shape.e_edgeShape = 2;
      Box2D.Collision.Shapes.b2Shape.e_shapeTypeCount = 3;
      Box2D.Collision.Shapes.b2Shape.e_hitCollide = 1;
      Box2D.Collision.Shapes.b2Shape.e_missCollide = 0;
      Box2D.Collision.Shapes.b2Shape.e_startsInsideCollide = parseInt((-1));
   });
})();
(function () {
   var b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3;

   b2Color.b2Color = function () {
      this._r = 0;
      this._g = 0;
      this._b = 0;
   };
   b2Color.prototype.b2Color = function (rr, gg, bb) {
      if (rr === undefined) rr = 0;
      if (gg === undefined) gg = 0;
      if (bb === undefined) bb = 0;
      this._r = Box2D.parseUInt(255 * b2Math.Clamp(rr, 0.0, 1.0));
      this._g = Box2D.parseUInt(255 * b2Math.Clamp(gg, 0.0, 1.0));
      this._b = Box2D.parseUInt(255 * b2Math.Clamp(bb, 0.0, 1.0));
   }
   b2Color.prototype.Set = function (rr, gg, bb) {
      if (rr === undefined) rr = 0;
      if (gg === undefined) gg = 0;
      if (bb === undefined) bb = 0;
      this._r = Box2D.parseUInt(255 * b2Math.Clamp(rr, 0.0, 1.0));
      this._g = Box2D.parseUInt(255 * b2Math.Clamp(gg, 0.0, 1.0));
      this._b = Box2D.parseUInt(255 * b2Math.Clamp(bb, 0.0, 1.0));
   }
   Object.defineProperty(b2Color.prototype, 'r', {
      enumerable: false,
      configurable: true,
      set: function (rr) {
         if (rr === undefined) rr = 0;
         this._r = Box2D.parseUInt(255 * b2Math.Clamp(rr, 0.0, 1.0));
      }
   });
   Object.defineProperty(b2Color.prototype, 'g', {
      enumerable: false,
      configurable: true,
      set: function (gg) {
         if (gg === undefined) gg = 0;
         this._g = Box2D.parseUInt(255 * b2Math.Clamp(gg, 0.0, 1.0));
      }
   });
   Object.defineProperty(b2Color.prototype, 'b', {
      enumerable: false,
      configurable: true,
      set: function (bb) {
         if (bb === undefined) bb = 0;
         this._b = Box2D.parseUInt(255 * b2Math.Clamp(bb, 0.0, 1.0));
      }
   });
   Object.defineProperty(b2Color.prototype, 'color', {
      enumerable: false,
      configurable: true,
      get: function () {
         return (this._r << 16) | (this._g << 8) | (this._b);
      }
   });
   b2Settings.b2Settings = function () {};
   b2Settings.b2MixFriction = function (friction1, friction2) {
      if (friction1 === undefined) friction1 = 0;
      if (friction2 === undefined) friction2 = 0;
      return Math.sqrt(friction1 * friction2);
   }
   b2Settings.b2MixRestitution = function (restitution1, restitution2) {
      if (restitution1 === undefined) restitution1 = 0;
      if (restitution2 === undefined) restitution2 = 0;
      return restitution1 > restitution2 ? restitution1 : restitution2;
   }
   b2Settings.b2Assert = function (a) {
      if (!a) {
         throw "Assertion Failed";
      }
   }
   Box2D.postDefs.push(function () {
      Box2D.Common.b2Settings.VERSION = "2.1alpha";
      Box2D.Common.b2Settings.USHRT_MAX = 0x0000ffff;
      Box2D.Common.b2Settings.b2_pi = Math.PI;
      Box2D.Common.b2Settings.b2_maxManifoldPoints = 2;
      Box2D.Common.b2Settings.b2_aabbExtension = 0.1;
      Box2D.Common.b2Settings.b2_aabbMultiplier = 2.0;
      Box2D.Common.b2Settings.b2_polygonRadius = 2.0 * b2Settings.b2_linearSlop;
      Box2D.Common.b2Settings.b2_linearSlop = 0.005;
      Box2D.Common.b2Settings.b2_angularSlop = 2.0 / 180.0 * b2Settings.b2_pi;
      Box2D.Common.b2Settings.b2_toiSlop = 8.0 * b2Settings.b2_linearSlop;
      Box2D.Common.b2Settings.b2_maxTOIContactsPerIsland = 32;
      Box2D.Common.b2Settings.b2_maxTOIJointsPerIsland = 32;
      Box2D.Common.b2Settings.b2_velocityThreshold = 1.0;
      Box2D.Common.b2Settings.b2_maxLinearCorrection = 0.2;
      Box2D.Common.b2Settings.b2_maxAngularCorrection = 8.0 / 180.0 * b2Settings.b2_pi;
      Box2D.Common.b2Settings.b2_maxTranslation = 2.0;
      Box2D.Common.b2Settings.b2_maxTranslationSquared = b2Settings.b2_maxTranslation * b2Settings.b2_maxTranslation;
      Box2D.Common.b2Settings.b2_maxRotation = 0.5 * b2Settings.b2_pi;
      Box2D.Common.b2Settings.b2_maxRotationSquared = b2Settings.b2_maxRotation * b2Settings.b2_maxRotation;
      Box2D.Common.b2Settings.b2_contactBaumgarte = 0.2;
      Box2D.Common.b2Settings.b2_timeToSleep = 0.5;
      Box2D.Common.b2Settings.b2_linearSleepTolerance = 0.01;
      Box2D.Common.b2Settings.b2_angularSleepTolerance = 2.0 / 180.0 * b2Settings.b2_pi;
   });
})();
(function () {
   var b2AABB = Box2D.Collision.b2AABB,
      b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3;

   b2Mat22.b2Mat22 = function () {
      this.col1 = new b2Vec2();
      this.col2 = new b2Vec2();
   };
   b2Mat22.prototype.b2Mat22 = function () {
      this.SetIdentity();
   }
   b2Mat22.FromAngle = function (angle) {
      if (angle === undefined) angle = 0;
      var mat = new b2Mat22();
      mat.Set(angle);
      return mat;
   }
   b2Mat22.FromVV = function (c1, c2) {
      var mat = new b2Mat22();
      mat.SetVV(c1, c2);
      return mat;
   }
   b2Mat22.prototype.Set = function (angle) {
      if (angle === undefined) angle = 0;
      var c = Math.cos(angle);
      var s = Math.sin(angle);
      this.col1.x = c;
      this.col2.x = (-s);
      this.col1.y = s;
      this.col2.y = c;
   }
   b2Mat22.prototype.SetVV = function (c1, c2) {
      this.col1.SetV(c1);
      this.col2.SetV(c2);
   }
   b2Mat22.prototype.Copy = function () {
      var mat = new b2Mat22();
      mat.SetM(this);
      return mat;
   }
   b2Mat22.prototype.SetM = function (m) {
      this.col1.SetV(m.col1);
      this.col2.SetV(m.col2);
   }
   b2Mat22.prototype.AddM = function (m) {
      this.col1.x += m.col1.x;
      this.col1.y += m.col1.y;
      this.col2.x += m.col2.x;
      this.col2.y += m.col2.y;
   }
   b2Mat22.prototype.SetIdentity = function () {
      this.col1.x = 1.0;
      this.col2.x = 0.0;
      this.col1.y = 0.0;
      this.col2.y = 1.0;
   }
   b2Mat22.prototype.SetZero = function () {
      this.col1.x = 0.0;
      this.col2.x = 0.0;
      this.col1.y = 0.0;
      this.col2.y = 0.0;
   }
   b2Mat22.prototype.GetAngle = function () {
      return Math.atan2(this.col1.y, this.col1.x);
   }
   b2Mat22.prototype.GetInverse = function (out) {
      var a = this.col1.x;
      var b = this.col2.x;
      var c = this.col1.y;
      var d = this.col2.y;
      var det = a * d - b * c;
      if (det != 0.0) {
         det = 1.0 / det;
      }
      out.col1.x = det * d;
      out.col2.x = (-det * b);
      out.col1.y = (-det * c);
      out.col2.y = det * a;
      return out;
   }
   b2Mat22.prototype.Solve = function (out, bX, bY) {
      if (bX === undefined) bX = 0;
      if (bY === undefined) bY = 0;
      var a11 = this.col1.x;
      var a12 = this.col2.x;
      var a21 = this.col1.y;
      var a22 = this.col2.y;
      var det = a11 * a22 - a12 * a21;
      if (det != 0.0) {
         det = 1.0 / det;
      }
      out.x = det * (a22 * bX - a12 * bY);
      out.y = det * (a11 * bY - a21 * bX);
      return out;
   }
   b2Mat22.prototype.Abs = function () {
      this.col1.Abs();
      this.col2.Abs();
   }
   b2Mat33.b2Mat33 = function () {
      this.col1 = new b2Vec3();
      this.col2 = new b2Vec3();
      this.col3 = new b2Vec3();
   };
   b2Mat33.prototype.b2Mat33 = function (c1, c2, c3) {
      if (c1 === undefined) c1 = null;
      if (c2 === undefined) c2 = null;
      if (c3 === undefined) c3 = null;
      if (!c1 && !c2 && !c3) {
         this.col1.SetZero();
         this.col2.SetZero();
         this.col3.SetZero();
      }
      else {
         this.col1.SetV(c1);
         this.col2.SetV(c2);
         this.col3.SetV(c3);
      }
   }
   b2Mat33.prototype.SetVVV = function (c1, c2, c3) {
      this.col1.SetV(c1);
      this.col2.SetV(c2);
      this.col3.SetV(c3);
   }
   b2Mat33.prototype.Copy = function () {
      return new b2Mat33(this.col1, this.col2, this.col3);
   }
   b2Mat33.prototype.SetM = function (m) {
      this.col1.SetV(m.col1);
      this.col2.SetV(m.col2);
      this.col3.SetV(m.col3);
   }
   b2Mat33.prototype.AddM = function (m) {
      this.col1.x += m.col1.x;
      this.col1.y += m.col1.y;
      this.col1.z += m.col1.z;
      this.col2.x += m.col2.x;
      this.col2.y += m.col2.y;
      this.col2.z += m.col2.z;
      this.col3.x += m.col3.x;
      this.col3.y += m.col3.y;
      this.col3.z += m.col3.z;
   }
   b2Mat33.prototype.SetIdentity = function () {
      this.col1.x = 1.0;
      this.col2.x = 0.0;
      this.col3.x = 0.0;
      this.col1.y = 0.0;
      this.col2.y = 1.0;
      this.col3.y = 0.0;
      this.col1.z = 0.0;
      this.col2.z = 0.0;
      this.col3.z = 1.0;
   }
   b2Mat33.prototype.SetZero = function () {
      this.col1.x = 0.0;
      this.col2.x = 0.0;
      this.col3.x = 0.0;
      this.col1.y = 0.0;
      this.col2.y = 0.0;
      this.col3.y = 0.0;
      this.col1.z = 0.0;
      this.col2.z = 0.0;
      this.col3.z = 0.0;
   }
   b2Mat33.prototype.Solve22 = function (out, bX, bY) {
      if (bX === undefined) bX = 0;
      if (bY === undefined) bY = 0;
      var a11 = this.col1.x;
      var a12 = this.col2.x;
      var a21 = this.col1.y;
      var a22 = this.col2.y;
      var det = a11 * a22 - a12 * a21;
      if (det != 0.0) {
         det = 1.0 / det;
      }
      out.x = det * (a22 * bX - a12 * bY);
      out.y = det * (a11 * bY - a21 * bX);
      return out;
   }
   b2Mat33.prototype.Solve33 = function (out, bX, bY, bZ) {
      if (bX === undefined) bX = 0;
      if (bY === undefined) bY = 0;
      if (bZ === undefined) bZ = 0;
      var a11 = this.col1.x;
      var a21 = this.col1.y;
      var a31 = this.col1.z;
      var a12 = this.col2.x;
      var a22 = this.col2.y;
      var a32 = this.col2.z;
      var a13 = this.col3.x;
      var a23 = this.col3.y;
      var a33 = this.col3.z;
      var det = a11 * (a22 * a33 - a32 * a23) + a21 * (a32 * a13 - a12 * a33) + a31 * (a12 * a23 - a22 * a13);
      if (det != 0.0) {
         det = 1.0 / det;
      }
      out.x = det * (bX * (a22 * a33 - a32 * a23) + bY * (a32 * a13 - a12 * a33) + bZ * (a12 * a23 - a22 * a13));
      out.y = det * (a11 * (bY * a33 - bZ * a23) + a21 * (bZ * a13 - bX * a33) + a31 * (bX * a23 - bY * a13));
      out.z = det * (a11 * (a22 * bZ - a32 * bY) + a21 * (a32 * bX - a12 * bZ) + a31 * (a12 * bY - a22 * bX));
      return out;
   }
   b2Math.b2Math = function () {};
   b2Math.IsValid = function (x) {
      if (x === undefined) x = 0;
      return isFinite(x);
   }
   b2Math.Dot = function (a, b) {
      return a.x * b.x + a.y * b.y;
   }
   b2Math.CrossVV = function (a, b) {
      return a.x * b.y - a.y * b.x;
   }
   b2Math.CrossVF = function (a, s) {
      if (s === undefined) s = 0;
      var v = new b2Vec2(s * a.y, (-s * a.x));
      return v;
   }
   b2Math.CrossFV = function (s, a) {
      if (s === undefined) s = 0;
      var v = new b2Vec2((-s * a.y), s * a.x);
      return v;
   }
   b2Math.MulMV = function (A, v) {
      var u = new b2Vec2(A.col1.x * v.x + A.col2.x * v.y, A.col1.y * v.x + A.col2.y * v.y);
      return u;
   }
   b2Math.MulTMV = function (A, v) {
      var u = new b2Vec2(b2Math.Dot(v, A.col1), b2Math.Dot(v, A.col2));
      return u;
   }
   b2Math.MulX = function (T, v) {
      var a = b2Math.MulMV(T.R, v);
      a.x += T.position.x;
      a.y += T.position.y;
      return a;
   }
   b2Math.MulXT = function (T, v) {
      var a = b2Math.SubtractVV(v, T.position);
      var tX = (a.x * T.R.col1.x + a.y * T.R.col1.y);
      a.y = (a.x * T.R.col2.x + a.y * T.R.col2.y);
      a.x = tX;
      return a;
   }
   b2Math.AddVV = function (a, b) {
      var v = new b2Vec2(a.x + b.x, a.y + b.y);
      return v;
   }
   b2Math.SubtractVV = function (a, b) {
      var v = new b2Vec2(a.x - b.x, a.y - b.y);
      return v;
   }
   b2Math.Distance = function (a, b) {
      var cX = a.x - b.x;
      var cY = a.y - b.y;
      return Math.sqrt(cX * cX + cY * cY);
   }
   b2Math.DistanceSquared = function (a, b) {
      var cX = a.x - b.x;
      var cY = a.y - b.y;
      return (cX * cX + cY * cY);
   }
   b2Math.MulFV = function (s, a) {
      if (s === undefined) s = 0;
      var v = new b2Vec2(s * a.x, s * a.y);
      return v;
   }
   b2Math.AddMM = function (A, B) {
      var C = b2Mat22.FromVV(b2Math.AddVV(A.col1, B.col1), b2Math.AddVV(A.col2, B.col2));
      return C;
   }
   b2Math.MulMM = function (A, B) {
      var C = b2Mat22.FromVV(b2Math.MulMV(A, B.col1), b2Math.MulMV(A, B.col2));
      return C;
   }
   b2Math.MulTMM = function (A, B) {
      var c1 = new b2Vec2(b2Math.Dot(A.col1, B.col1), b2Math.Dot(A.col2, B.col1));
      var c2 = new b2Vec2(b2Math.Dot(A.col1, B.col2), b2Math.Dot(A.col2, B.col2));
      var C = b2Mat22.FromVV(c1, c2);
      return C;
   }
   b2Math.Abs = function (a) {
      if (a === undefined) a = 0;
      return a > 0.0 ? a : (-a);
   }
   b2Math.AbsV = function (a) {
      var b = new b2Vec2(b2Math.Abs(a.x), b2Math.Abs(a.y));
      return b;
   }
   b2Math.AbsM = function (A) {
      var B = b2Mat22.FromVV(b2Math.AbsV(A.col1), b2Math.AbsV(A.col2));
      return B;
   }
   b2Math.Min = function (a, b) {
      if (a === undefined) a = 0;
      if (b === undefined) b = 0;
      return a < b ? a : b;
   }
   b2Math.MinV = function (a, b) {
      var c = new b2Vec2(b2Math.Min(a.x, b.x), b2Math.Min(a.y, b.y));
      return c;
   }
   b2Math.Max = function (a, b) {
      if (a === undefined) a = 0;
      if (b === undefined) b = 0;
      return a > b ? a : b;
   }
   b2Math.MaxV = function (a, b) {
      var c = new b2Vec2(b2Math.Max(a.x, b.x), b2Math.Max(a.y, b.y));
      return c;
   }
   b2Math.Clamp = function (a, low, high) {
      if (a === undefined) a = 0;
      if (low === undefined) low = 0;
      if (high === undefined) high = 0;
      return a < low ? low : a > high ? high : a;
   }
   b2Math.ClampV = function (a, low, high) {
      return b2Math.MaxV(low, b2Math.MinV(a, high));
   }
   b2Math.Swap = function (a, b) {
      var tmp = a[0];
      a[0] = b[0];
      b[0] = tmp;
   }
   b2Math.Random = function () {
      return Math.random() * 2 - 1;
   }
   b2Math.RandomRange = function (lo, hi) {
      if (lo === undefined) lo = 0;
      if (hi === undefined) hi = 0;
      var r = Math.random();
      r = (hi - lo) * r + lo;
      return r;
   }
   b2Math.NextPowerOfTwo = function (x) {
      if (x === undefined) x = 0;
      x |= (x >> 1) & 0x7FFFFFFF;
      x |= (x >> 2) & 0x3FFFFFFF;
      x |= (x >> 4) & 0x0FFFFFFF;
      x |= (x >> 8) & 0x00FFFFFF;
      x |= (x >> 16) & 0x0000FFFF;
      return x + 1;
   }
   b2Math.IsPowerOfTwo = function (x) {
      if (x === undefined) x = 0;
      var result = x > 0 && (x & (x - 1)) == 0;
      return result;
   }
   Box2D.postDefs.push(function () {
      Box2D.Common.Math.b2Math.b2Vec2_zero = new b2Vec2(0.0, 0.0);
      Box2D.Common.Math.b2Math.b2Mat22_identity = b2Mat22.FromVV(new b2Vec2(1.0, 0.0), new b2Vec2(0.0, 1.0));
      Box2D.Common.Math.b2Math.b2Transform_identity = new b2Transform(b2Math.b2Vec2_zero, b2Math.b2Mat22_identity);
   });
   b2Sweep.b2Sweep = function () {
      this.localCenter = new b2Vec2();
      this.c0 = new b2Vec2;
      this.c = new b2Vec2();
   };
   b2Sweep.prototype.Set = function (other) {
      this.localCenter.SetV(other.localCenter);
      this.c0.SetV(other.c0);
      this.c.SetV(other.c);
      this.a0 = other.a0;
      this.a = other.a;
      this.t0 = other.t0;
   }
   b2Sweep.prototype.Copy = function () {
      var copy = new b2Sweep();
      copy.localCenter.SetV(this.localCenter);
      copy.c0.SetV(this.c0);
      copy.c.SetV(this.c);
      copy.a0 = this.a0;
      copy.a = this.a;
      copy.t0 = this.t0;
      return copy;
   }
   b2Sweep.prototype.GetTransform = function (xf, alpha) {
      if (alpha === undefined) alpha = 0;
      xf.position.x = (1.0 - alpha) * this.c0.x + alpha * this.c.x;
      xf.position.y = (1.0 - alpha) * this.c0.y + alpha * this.c.y;
      var angle = (1.0 - alpha) * this.a0 + alpha * this.a;
      xf.R.Set(angle);
      var tMat = xf.R;
      xf.position.x -= (tMat.col1.x * this.localCenter.x + tMat.col2.x * this.localCenter.y);
      xf.position.y -= (tMat.col1.y * this.localCenter.x + tMat.col2.y * this.localCenter.y);
   }
   b2Sweep.prototype.Advance = function (t) {
      if (t === undefined) t = 0;
      if (this.t0 < t && 1.0 - this.t0 > FLOAT_EPSILON) {
         var alpha = (t - this.t0) / (1.0 - this.t0);
         this.c0.x = (1.0 - alpha) * this.c0.x + alpha * this.c.x;
         this.c0.y = (1.0 - alpha) * this.c0.y + alpha * this.c.y;
         this.a0 = (1.0 - alpha) * this.a0 + alpha * this.a;
         this.t0 = t;
      }
   }
   b2Transform.b2Transform = function () {
      this.position = new b2Vec2;
      this.R = new b2Mat22();
   };
   b2Transform.prototype.b2Transform = function (pos, r) {
      if (pos === undefined) pos = null;
      if (r === undefined) r = null;
      if (pos) {
         this.position.SetV(pos);
         this.R.SetM(r);
      }
   }
   b2Transform.prototype.Initialize = function (pos, r) {
      this.position.SetV(pos);
      this.R.SetM(r);
   }
   b2Transform.prototype.SetIdentity = function () {
      this.position.SetZero();
      this.R.SetIdentity();
   }
   b2Transform.prototype.Set = function (x) {
      this.position.SetV(x.position);
      this.R.SetM(x.R);
   }
   b2Transform.prototype.GetAngle = function () {
      return Math.atan2(this.R.col1.y, this.R.col1.x);
   }
   b2Vec2.b2Vec2 = function () {};
   b2Vec2.prototype.b2Vec2 = function (x_, y_) {
      if (x_ === undefined) x_ = 0;
      if (y_ === undefined) y_ = 0;
      this.x = x_;
      this.y = y_;
   }
   b2Vec2.prototype.SetZero = function () {
      this.x = 0.0;
      this.y = 0.0;
   }
   b2Vec2.prototype.Set = function (x_, y_) {
      if (x_ === undefined) x_ = 0;
      if (y_ === undefined) y_ = 0;
      this.x = x_;
      this.y = y_;
   }
   b2Vec2.prototype.SetV = function (v) {
      this.x = v.x;
      this.y = v.y;
   }
   b2Vec2.prototype.GetNegative = function () {
      return new b2Vec2((-this.x), (-this.y));
   }
   b2Vec2.prototype.NegativeSelf = function () {
      this.x = (-this.x);
      this.y = (-this.y);
   }
   b2Vec2.Make = function (x_, y_) {
      if (x_ === undefined) x_ = 0;
      if (y_ === undefined) y_ = 0;
      return new b2Vec2(x_, y_);
   }
   b2Vec2.prototype.Copy = function () {
      return new b2Vec2(this.x, this.y);
   }
   b2Vec2.prototype.Add = function (v) {
      this.x += v.x;
      this.y += v.y;
   }
   b2Vec2.prototype.Subtract = function (v) {
      this.x -= v.x;
      this.y -= v.y;
   }
   b2Vec2.prototype.Multiply = function (a) {
      if (a === undefined) a = 0;
      this.x *= a;
      this.y *= a;
   }
   b2Vec2.prototype.MulM = function (A) {
      var tX = this.x;
      this.x = A.col1.x * tX + A.col2.x * this.y;
      this.y = A.col1.y * tX + A.col2.y * this.y;
   }
   b2Vec2.prototype.MulTM = function (A) {
      var tX = b2Math.Dot(this, A.col1);
      this.y = b2Math.Dot(this, A.col2);
      this.x = tX;
   }
   b2Vec2.prototype.CrossVF = function (s) {
      if (s === undefined) s = 0;
      var tX = this.x;
      this.x = s * this.y;
      this.y = (-s * tX);
   }
   b2Vec2.prototype.CrossFV = function (s) {
      if (s === undefined) s = 0;
      var tX = this.x;
      this.x = (-s * this.y);
      this.y = s * tX;
   }
   b2Vec2.prototype.MinV = function (b) {
      this.x = this.x < b.x ? this.x : b.x;
      this.y = this.y < b.y ? this.y : b.y;
   }
   b2Vec2.prototype.MaxV = function (b) {
      this.x = this.x > b.x ? this.x : b.x;
      this.y = this.y > b.y ? this.y : b.y;
   }
   b2Vec2.prototype.Abs = function () {
      if (this.x < 0) this.x = (-this.x);
      if (this.y < 0) this.y = (-this.y);
   }
   b2Vec2.prototype.Length = function () {
      return Math.sqrt(this.x * this.x + this.y * this.y);
   }
   b2Vec2.prototype.LengthSquared = function () {
      return (this.x * this.x + this.y * this.y);
   }
   b2Vec2.prototype.Normalize = function () {
      var length = Math.sqrt(this.x * this.x + this.y * this.y);
      if (length < FLOAT_EPSILON) {
         return 0.0;
      }
      var invLength = 1.0 / length;
      this.x *= invLength;
      this.y *= invLength;
      return length;
   }
   b2Vec2.prototype.IsValid = function () {
      return b2Math.IsValid(this.x) && b2Math.IsValid(this.y);
   }
   b2Vec3.b2Vec3 = function () {};
   b2Vec3.prototype.b2Vec3 = function (x, y, z) {
      if (x === undefined) x = 0;
      if (y === undefined) y = 0;
      if (z === undefined) z = 0;
      this.x = x;
      this.y = y;
      this.z = z;
   }
   b2Vec3.prototype.SetZero = function () {
      this.x = this.y = this.z = 0.0;
   }
   b2Vec3.prototype.Set = function (x, y, z) {
      if (x === undefined) x = 0;
      if (y === undefined) y = 0;
      if (z === undefined) z = 0;
      this.x = x;
      this.y = y;
      this.z = z;
   }
   b2Vec3.prototype.SetV = function (v) {
      this.x = v.x;
      this.y = v.y;
      this.z = v.z;
   }
   b2Vec3.prototype.GetNegative = function () {
      return new b2Vec3((-this.x), (-this.y), (-this.z));
   }
   b2Vec3.prototype.NegativeSelf = function () {
      this.x = (-this.x);
      this.y = (-this.y);
      this.z = (-this.z);
   }
   b2Vec3.prototype.Copy = function () {
      return new b2Vec3(this.x, this.y, this.z);
   }
   b2Vec3.prototype.Add = function (v) {
      this.x += v.x;
      this.y += v.y;
      this.z += v.z;
   }
   b2Vec3.prototype.Subtract = function (v) {
      this.x -= v.x;
      this.y -= v.y;
      this.z -= v.z;
   }
   b2Vec3.prototype.Multiply = function (a) {
      if (a === undefined) a = 0;
      this.x *= a;
      this.y *= a;
      this.z *= a;
   }
})();
(function () {
   var b2ControllerEdge = Box2D.Dynamics.Controllers.b2ControllerEdge,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3,
      b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2AABB = Box2D.Collision.b2AABB,
      b2Bound = Box2D.Collision.b2Bound,
      b2BoundValues = Box2D.Collision.b2BoundValues,
      b2Collision = Box2D.Collision.b2Collision,
      b2ContactID = Box2D.Collision.b2ContactID,
      b2ContactPoint = Box2D.Collision.b2ContactPoint,
      b2Distance = Box2D.Collision.b2Distance,
      b2DistanceInput = Box2D.Collision.b2DistanceInput,
      b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
      b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
      b2DynamicTree = Box2D.Collision.b2DynamicTree,
      b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
      b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
      b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
      b2Manifold = Box2D.Collision.b2Manifold,
      b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
      b2Point = Box2D.Collision.b2Point,
      b2RayCastInput = Box2D.Collision.b2RayCastInput,
      b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
      b2Segment = Box2D.Collision.b2Segment,
      b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
      b2Simplex = Box2D.Collision.b2Simplex,
      b2SimplexCache = Box2D.Collision.b2SimplexCache,
      b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
      b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
      b2TOIInput = Box2D.Collision.b2TOIInput,
      b2WorldManifold = Box2D.Collision.b2WorldManifold,
      ClipVertex = Box2D.Collision.ClipVertex,
      Features = Box2D.Collision.Features,
      IBroadPhase = Box2D.Collision.IBroadPhase,
      b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
      b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
      b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
      b2MassData = Box2D.Collision.Shapes.b2MassData,
      b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
      b2Shape = Box2D.Collision.Shapes.b2Shape,
      b2Body = Box2D.Dynamics.b2Body,
      b2BodyDef = Box2D.Dynamics.b2BodyDef,
      b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
      b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
      b2ContactListener = Box2D.Dynamics.b2ContactListener,
      b2ContactManager = Box2D.Dynamics.b2ContactManager,
      b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
      b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
      b2FilterData = Box2D.Dynamics.b2FilterData,
      b2Fixture = Box2D.Dynamics.b2Fixture,
      b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
      b2Island = Box2D.Dynamics.b2Island,
      b2TimeStep = Box2D.Dynamics.b2TimeStep,
      b2World = Box2D.Dynamics.b2World,
      b2CircleContact = Box2D.Dynamics.Contacts.b2CircleContact,
      b2Contact = Box2D.Dynamics.Contacts.b2Contact,
      b2ContactConstraint = Box2D.Dynamics.Contacts.b2ContactConstraint,
      b2ContactConstraintPoint = Box2D.Dynamics.Contacts.b2ContactConstraintPoint,
      b2ContactEdge = Box2D.Dynamics.Contacts.b2ContactEdge,
      b2ContactFactory = Box2D.Dynamics.Contacts.b2ContactFactory,
      b2ContactRegister = Box2D.Dynamics.Contacts.b2ContactRegister,
      b2ContactResult = Box2D.Dynamics.Contacts.b2ContactResult,
      b2ContactSolver = Box2D.Dynamics.Contacts.b2ContactSolver,
      b2EdgeAndCircleContact = Box2D.Dynamics.Contacts.b2EdgeAndCircleContact,
      b2NullContact = Box2D.Dynamics.Contacts.b2NullContact,
      b2PolyAndCircleContact = Box2D.Dynamics.Contacts.b2PolyAndCircleContact,
      b2PolyAndEdgeContact = Box2D.Dynamics.Contacts.b2PolyAndEdgeContact,
      b2PolygonContact = Box2D.Dynamics.Contacts.b2PolygonContact,
      b2PositionSolverManifold = Box2D.Dynamics.Contacts.b2PositionSolverManifold,
      b2Controller = Box2D.Dynamics.Controllers.b2Controller,
      b2DistanceJoint = Box2D.Dynamics.Joints.b2DistanceJoint,
      b2DistanceJointDef = Box2D.Dynamics.Joints.b2DistanceJointDef,
      b2FrictionJoint = Box2D.Dynamics.Joints.b2FrictionJoint,
      b2FrictionJointDef = Box2D.Dynamics.Joints.b2FrictionJointDef,
      b2GearJoint = Box2D.Dynamics.Joints.b2GearJoint,
      b2GearJointDef = Box2D.Dynamics.Joints.b2GearJointDef,
      b2Jacobian = Box2D.Dynamics.Joints.b2Jacobian,
      b2Joint = Box2D.Dynamics.Joints.b2Joint,
      b2JointDef = Box2D.Dynamics.Joints.b2JointDef,
      b2JointEdge = Box2D.Dynamics.Joints.b2JointEdge,
      b2LineJoint = Box2D.Dynamics.Joints.b2LineJoint,
      b2LineJointDef = Box2D.Dynamics.Joints.b2LineJointDef,
      b2MouseJoint = Box2D.Dynamics.Joints.b2MouseJoint,
      b2MouseJointDef = Box2D.Dynamics.Joints.b2MouseJointDef,
      b2PrismaticJoint = Box2D.Dynamics.Joints.b2PrismaticJoint,
      b2PrismaticJointDef = Box2D.Dynamics.Joints.b2PrismaticJointDef,
      b2PulleyJoint = Box2D.Dynamics.Joints.b2PulleyJoint,
      b2PulleyJointDef = Box2D.Dynamics.Joints.b2PulleyJointDef,
      b2RevoluteJoint = Box2D.Dynamics.Joints.b2RevoluteJoint,
      b2RevoluteJointDef = Box2D.Dynamics.Joints.b2RevoluteJointDef,
      b2WeldJoint = Box2D.Dynamics.Joints.b2WeldJoint,
      b2WeldJointDef = Box2D.Dynamics.Joints.b2WeldJointDef;

   b2Body.b2Body = function () {
      this.m_xf = new b2Transform();
      this.m_sweep = new b2Sweep();
      this.m_linearVelocity = new b2Vec2();
      this.m_force = new b2Vec2();
   };
   b2Body.prototype.connectEdges = function (s1, s2, angle1) {
      if (angle1 === undefined) angle1 = 0;
      var angle2 = Math.atan2(s2.GetDirectionVector().y, s2.GetDirectionVector().x);
      var coreOffset = Math.tan((angle2 - angle1) * 0.5);
      var core = b2Math.MulFV(coreOffset, s2.GetDirectionVector());
      core = b2Math.SubtractVV(core, s2.GetNormalVector());
      core = b2Math.MulFV(b2Settings.b2_toiSlop, core);
      core = b2Math.AddVV(core, s2.GetVertex1());
      var cornerDir = b2Math.AddVV(s1.GetDirectionVector(), s2.GetDirectionVector());
      cornerDir.Normalize();
      var convex = b2Math.Dot(s1.GetDirectionVector(), s2.GetNormalVector()) > 0.0;
      s1.SetNextEdge(s2, core, cornerDir, convex);
      s2.SetPrevEdge(s1, core, cornerDir, convex);
      return angle2;
   }
   b2Body.prototype.CreateFixture = function (def) {
      if (this.m_world.IsLocked() == true) {
         return null;
      }
      var fixture = new b2Fixture();
      fixture.Create(this, this.m_xf, def);
      if (this.m_flags & b2Body.e_activeFlag) {
         var broadPhase = this.m_world.m_contactManager.m_broadPhase;
         fixture.CreateProxy(broadPhase, this.m_xf);
      }
      fixture.m_next = this.m_fixtureList;
      this.m_fixtureList = fixture;
      ++this.m_fixtureCount;
      fixture.m_body = this;
      if (fixture.m_density > 0.0) {
         this.ResetMassData();
      }
      this.m_world.m_flags |= b2World.e_newFixture;
      return fixture;
   }
   b2Body.prototype.CreateFixture2 = function (shape, density) {
      if (density === undefined) density = 0.0;
      var def = new b2FixtureDef();
      def.shape = shape;
      def.density = density;
      return this.CreateFixture(def);
   }
   b2Body.prototype.DestroyFixture = function (fixture) {
      if (this.m_world.IsLocked() == true) {
         return;
      }
      var node = this.m_fixtureList;
      var ppF = null;
      var found = false;
      while (node != null) {
         if (node == fixture) {
            if (ppF) ppF.m_next = fixture.m_next;
            else this.m_fixtureList = fixture.m_next;
            found = true;
            break;
         }
         ppF = node;
         node = node.m_next;
      }
      var edge = this.m_contactList;
      while (edge) {
         var c = edge.contact;
         edge = edge.next;
         var fixtureA = c.GetFixtureA();
         var fixtureB = c.GetFixtureB();
         if (fixture == fixtureA || fixture == fixtureB) {
            this.m_world.m_contactManager.Destroy(c);
         }
      }
      if (this.m_flags & b2Body.e_activeFlag) {
         var broadPhase = this.m_world.m_contactManager.m_broadPhase;
         fixture.DestroyProxy(broadPhase);
      }
      else {}
      fixture.Destroy();
      fixture.m_body = null;
      fixture.m_next = null;
      --this.m_fixtureCount;
      this.ResetMassData();
   }
   b2Body.prototype.SetPositionAndAngle = function (position, angle) {
      if (angle === undefined) angle = 0;
      var f;
      if (this.m_world.IsLocked() == true) {
         return;
      }
      this.m_xf.R.Set(angle);
      this.m_xf.position.SetV(position);
      var tMat = this.m_xf.R;
      var tVec = this.m_sweep.localCenter;
      this.m_sweep.c.x = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      this.m_sweep.c.y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      this.m_sweep.c.x += this.m_xf.position.x;
      this.m_sweep.c.y += this.m_xf.position.y;
      this.m_sweep.c0.SetV(this.m_sweep.c);
      this.m_sweep.a0 = this.m_sweep.a = angle;
      var broadPhase = this.m_world.m_contactManager.m_broadPhase;
      for (f = this.m_fixtureList;
      f; f = f.m_next) {
         f.Synchronize(broadPhase, this.m_xf, this.m_xf);
      }
      this.m_world.m_contactManager.FindNewContacts();
   }
   b2Body.prototype.SetTransform = function (xf) {
      this.SetPositionAndAngle(xf.position, xf.GetAngle());
   }
   b2Body.prototype.GetTransform = function () {
      return this.m_xf;
   }
   b2Body.prototype.GetPosition = function () {
      return this.m_xf.position;
   }
   b2Body.prototype.SetPosition = function (position) {
      this.SetPositionAndAngle(position, this.GetAngle());
   }
   b2Body.prototype.GetAngle = function () {
      return this.m_sweep.a;
   }
   b2Body.prototype.SetAngle = function (angle) {
      if (angle === undefined) angle = 0;
      this.SetPositionAndAngle(this.GetPosition(), angle);
   }
   b2Body.prototype.GetWorldCenter = function () {
      return this.m_sweep.c;
   }
   b2Body.prototype.GetLocalCenter = function () {
      return this.m_sweep.localCenter;
   }
   b2Body.prototype.SetLinearVelocity = function (v) {
      if (this.m_type == b2Body.b2_staticBody) {
         return;
      }
      this.m_linearVelocity.SetV(v);
   }
   b2Body.prototype.GetLinearVelocity = function () {
      return this.m_linearVelocity;
   }
   b2Body.prototype.SetAngularVelocity = function (omega) {
      if (omega === undefined) omega = 0;
      if (this.m_type == b2Body.b2_staticBody) {
         return;
      }
      this.m_angularVelocity = omega;
   }
   b2Body.prototype.GetAngularVelocity = function () {
      return this.m_angularVelocity;
   }
   b2Body.prototype.GetDefinition = function () {
      var bd = new b2BodyDef();
      bd.type = this.GetType();
      bd.allowSleep = (this.m_flags & b2Body.e_allowSleepFlag) == b2Body.e_allowSleepFlag;
      bd.angle = this.GetAngle();
      bd.angularDamping = this.m_angularDamping;
      bd.angularVelocity = this.m_angularVelocity;
      bd.fixedRotation = (this.m_flags & b2Body.e_fixedRotationFlag) == b2Body.e_fixedRotationFlag;
      bd.bullet = (this.m_flags & b2Body.e_bulletFlag) == b2Body.e_bulletFlag;
      bd.awake = (this.m_flags & b2Body.e_awakeFlag) == b2Body.e_awakeFlag;
      bd.linearDamping = this.m_linearDamping;
      bd.linearVelocity.SetV(this.GetLinearVelocity());
      bd.position = this.GetPosition();
      bd.userData = this.GetUserData();
      return bd;
   }
   b2Body.prototype.ApplyForce = function (force, point) {
      if (this.m_type != b2Body.b2_dynamicBody) {
         return;
      }
      if (this.IsAwake() == false) {
         this.SetAwake(true);
      }
      this.m_force.x += force.x;
      this.m_force.y += force.y;
      this.m_torque += ((point.x - this.m_sweep.c.x) * force.y - (point.y - this.m_sweep.c.y) * force.x);
   }
   b2Body.prototype.ApplyTorque = function (torque) {
      if (torque === undefined) torque = 0;
      if (this.m_type != b2Body.b2_dynamicBody) {
         return;
      }
      if (this.IsAwake() == false) {
         this.SetAwake(true);
      }
      this.m_torque += torque;
   }
   b2Body.prototype.ApplyImpulse = function (impulse, point) {
      if (this.m_type != b2Body.b2_dynamicBody) {
         return;
      }
      if (this.IsAwake() == false) {
         this.SetAwake(true);
      }
      this.m_linearVelocity.x += this.m_invMass * impulse.x;
      this.m_linearVelocity.y += this.m_invMass * impulse.y;
      this.m_angularVelocity += this.m_invI * ((point.x - this.m_sweep.c.x) * impulse.y - (point.y - this.m_sweep.c.y) * impulse.x);
   }
   b2Body.prototype.Split = function (callback) {
      var linearVelocity = this.GetLinearVelocity().Copy();
      var angularVelocity = this.GetAngularVelocity();
      var center = this.GetWorldCenter();
      var body1 = this;
      var body2 = this.m_world.CreateBody(this.GetDefinition());
      var prev;
      for (var f = body1.m_fixtureList; f;) {
         if (callback(f)) {
            var next = f.m_next;
            if (prev) {
               prev.m_next = next;
            }
            else {
               body1.m_fixtureList = next;
            }
            body1.m_fixtureCount--;
            f.m_next = body2.m_fixtureList;
            body2.m_fixtureList = f;
            body2.m_fixtureCount++;
            f.m_body = body2;
            f = next;
         }
         else {
            prev = f;
            f = f.m_next;
         }
      }
      body1.ResetMassData();
      body2.ResetMassData();
      var center1 = body1.GetWorldCenter();
      var center2 = body2.GetWorldCenter();
      var velocity1 = b2Math.AddVV(linearVelocity, b2Math.CrossFV(angularVelocity, b2Math.SubtractVV(center1, center)));
      var velocity2 = b2Math.AddVV(linearVelocity, b2Math.CrossFV(angularVelocity, b2Math.SubtractVV(center2, center)));
      body1.SetLinearVelocity(velocity1);
      body2.SetLinearVelocity(velocity2);
      body1.SetAngularVelocity(angularVelocity);
      body2.SetAngularVelocity(angularVelocity);
      body1.SynchronizeFixtures();
      body2.SynchronizeFixtures();
      return body2;
   }
   b2Body.prototype.Merge = function (other) {
      var f;
      for (f = other.m_fixtureList;
      f;) {
         var next = f.m_next;
         other.m_fixtureCount--;
         f.m_next = this.m_fixtureList;
         this.m_fixtureList = f;
         this.m_fixtureCount++;
         f.m_body = body2;
         f = next;
      }
      body1.m_fixtureCount = 0;
      var body1 = this;
      var body2 = other;
      var center1 = body1.GetWorldCenter();
      var center2 = body2.GetWorldCenter();
      var velocity1 = body1.GetLinearVelocity().Copy();
      var velocity2 = body2.GetLinearVelocity().Copy();
      var angular1 = body1.GetAngularVelocity();
      var angular = body2.GetAngularVelocity();
      body1.ResetMassData();
      this.SynchronizeFixtures();
   }
   b2Body.prototype.GetMass = function () {
      return this.m_mass;
   }
   b2Body.prototype.GetInertia = function () {
      return this.m_I;
   }
   b2Body.prototype.GetMassData = function (data) {
      data.mass = this.m_mass;
      data.I = this.m_I;
      data.center.SetV(this.m_sweep.localCenter);
   }
   b2Body.prototype.SetMassData = function (massData) {
      b2Settings.b2Assert(this.m_world.IsLocked() == false);
      if (this.m_world.IsLocked() == true) {
         return;
      }
      if (this.m_type != b2Body.b2_dynamicBody) {
         return;
      }
      this.m_invMass = 0.0;
      this.m_I = 0.0;
      this.m_invI = 0.0;
      this.m_mass = massData.mass;
      if (this.m_mass <= 0.0) {
         this.m_mass = 1.0;
      }
      this.m_invMass = 1.0 / this.m_mass;
      if (massData.I > 0.0 && (this.m_flags & b2Body.e_fixedRotationFlag) == 0) {
         this.m_I = massData.I - this.m_mass * (massData.center.x * massData.center.x + massData.center.y * massData.center.y);
         this.m_invI = 1.0 / this.m_I;
      }
      var oldCenter = this.m_sweep.c.Copy();
      this.m_sweep.localCenter.SetV(massData.center);
      this.m_sweep.c0.SetV(b2Math.MulX(this.m_xf, this.m_sweep.localCenter));
      this.m_sweep.c.SetV(this.m_sweep.c0);
      this.m_linearVelocity.x += this.m_angularVelocity * (-(this.m_sweep.c.y - oldCenter.y));
      this.m_linearVelocity.y += this.m_angularVelocity * (+(this.m_sweep.c.x - oldCenter.x));
   }
   b2Body.prototype.ResetMassData = function () {
      this.m_mass = 0.0;
      this.m_invMass = 0.0;
      this.m_I = 0.0;
      this.m_invI = 0.0;
      this.m_sweep.localCenter.SetZero();
      if (this.m_type == b2Body.b2_staticBody || this.m_type == b2Body.b2_kinematicBody) {
         return;
      }
      var center = b2Vec2.Make(0, 0);
      for (var f = this.m_fixtureList; f; f = f.m_next) {
         if (f.m_density == 0.0) {
            continue;
         }
         var massData = f.GetMassData();
         this.m_mass += massData.mass;
         center.x += massData.center.x * massData.mass;
         center.y += massData.center.y * massData.mass;
         this.m_I += massData.I;
      }
      if (this.m_mass > 0.0) {
         this.m_invMass = 1.0 / this.m_mass;
         center.x *= this.m_invMass;
         center.y *= this.m_invMass;
      }
      else {
         this.m_mass = 1.0;
         this.m_invMass = 1.0;
      }
      if (this.m_I > 0.0 && (this.m_flags & b2Body.e_fixedRotationFlag) == 0) {
         this.m_I -= this.m_mass * (center.x * center.x + center.y * center.y);
         this.m_I *= this.m_inertiaScale;
         b2Settings.b2Assert(this.m_I > 0);
         this.m_invI = 1.0 / this.m_I;
      }
      else {
         this.m_I = 0.0;
         this.m_invI = 0.0;
      }
      var oldCenter = this.m_sweep.c.Copy();
      this.m_sweep.localCenter.SetV(center);
      this.m_sweep.c0.SetV(b2Math.MulX(this.m_xf, this.m_sweep.localCenter));
      this.m_sweep.c.SetV(this.m_sweep.c0);
      this.m_linearVelocity.x += this.m_angularVelocity * (-(this.m_sweep.c.y - oldCenter.y));
      this.m_linearVelocity.y += this.m_angularVelocity * (+(this.m_sweep.c.x - oldCenter.x));
   }
   b2Body.prototype.GetWorldPoint = function (localPoint) {
      var A = this.m_xf.R;
      var u = new b2Vec2(A.col1.x * localPoint.x + A.col2.x * localPoint.y, A.col1.y * localPoint.x + A.col2.y * localPoint.y);
      u.x += this.m_xf.position.x;
      u.y += this.m_xf.position.y;
      return u;
   }
   b2Body.prototype.GetWorldVector = function (localVector) {
      return b2Math.MulMV(this.m_xf.R, localVector);
   }
   b2Body.prototype.GetLocalPoint = function (worldPoint) {
      return b2Math.MulXT(this.m_xf, worldPoint);
   }
   b2Body.prototype.GetLocalVector = function (worldVector) {
      return b2Math.MulTMV(this.m_xf.R, worldVector);
   }
   b2Body.prototype.GetLinearVelocityFromWorldPoint = function (worldPoint) {
      return new b2Vec2(this.m_linearVelocity.x - this.m_angularVelocity * (worldPoint.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (worldPoint.x - this.m_sweep.c.x));
   }
   b2Body.prototype.GetLinearVelocityFromLocalPoint = function (localPoint) {
      var A = this.m_xf.R;
      var worldPoint = new b2Vec2(A.col1.x * localPoint.x + A.col2.x * localPoint.y, A.col1.y * localPoint.x + A.col2.y * localPoint.y);
      worldPoint.x += this.m_xf.position.x;
      worldPoint.y += this.m_xf.position.y;
      return new b2Vec2(this.m_linearVelocity.x - this.m_angularVelocity * (worldPoint.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (worldPoint.x - this.m_sweep.c.x));
   }
   b2Body.prototype.GetLinearDamping = function () {
      return this.m_linearDamping;
   }
   b2Body.prototype.SetLinearDamping = function (linearDamping) {
      if (linearDamping === undefined) linearDamping = 0;
      this.m_linearDamping = linearDamping;
   }
   b2Body.prototype.GetAngularDamping = function () {
      return this.m_angularDamping;
   }
   b2Body.prototype.SetAngularDamping = function (angularDamping) {
      if (angularDamping === undefined) angularDamping = 0;
      this.m_angularDamping = angularDamping;
   }
   b2Body.prototype.SetType = function (type) {
      if (type === undefined) type = 0;
      if (this.m_type == type) {
         return;
      }
      this.m_type = type;
      this.ResetMassData();
      if (this.m_type == b2Body.b2_staticBody) {
         this.m_linearVelocity.SetZero();
         this.m_angularVelocity = 0.0;
      }
      this.SetAwake(true);
      this.m_force.SetZero();
      this.m_torque = 0.0;
      for (var ce = this.m_contactList; ce; ce = ce.next) {
         ce.contact.FlagForFiltering();
      }
   }
   b2Body.prototype.GetType = function () {
      return this.m_type;
   }
   b2Body.prototype.SetBullet = function (flag) {
      if (flag) {
         this.m_flags |= b2Body.e_bulletFlag;
      }
      else {
         this.m_flags &= ~b2Body.e_bulletFlag;
      }
   }
   b2Body.prototype.IsBullet = function () {
      return (this.m_flags & b2Body.e_bulletFlag) == b2Body.e_bulletFlag;
   }
   b2Body.prototype.SetSleepingAllowed = function (flag) {
      if (flag) {
         this.m_flags |= b2Body.e_allowSleepFlag;
      }
      else {
         this.m_flags &= ~b2Body.e_allowSleepFlag;
         this.SetAwake(true);
      }
   }
   b2Body.prototype.SetAwake = function (flag) {
      if (flag) {
         this.m_flags |= b2Body.e_awakeFlag;
         this.m_sleepTime = 0.0;
      }
      else {
         this.m_flags &= ~b2Body.e_awakeFlag;
         this.m_sleepTime = 0.0;
         this.m_linearVelocity.SetZero();
         this.m_angularVelocity = 0.0;
         this.m_force.SetZero();
         this.m_torque = 0.0;
      }
   }
   b2Body.prototype.IsAwake = function () {
      return (this.m_flags & b2Body.e_awakeFlag) == b2Body.e_awakeFlag;
   }
   b2Body.prototype.SetFixedRotation = function (fixed) {
      if (fixed) {
         this.m_flags |= b2Body.e_fixedRotationFlag;
      }
      else {
         this.m_flags &= ~b2Body.e_fixedRotationFlag;
      }
      this.ResetMassData();
   }
   b2Body.prototype.IsFixedRotation = function () {
      return (this.m_flags & b2Body.e_fixedRotationFlag) == b2Body.e_fixedRotationFlag;
   }
   b2Body.prototype.SetActive = function (flag) {
      if (flag == this.IsActive()) {
         return;
      }
      var broadPhase;
      var f;
      if (flag) {
         this.m_flags |= b2Body.e_activeFlag;
         broadPhase = this.m_world.m_contactManager.m_broadPhase;
         for (f = this.m_fixtureList;
         f; f = f.m_next) {
            f.CreateProxy(broadPhase, this.m_xf);
         }
      }
      else {
         this.m_flags &= ~b2Body.e_activeFlag;
         broadPhase = this.m_world.m_contactManager.m_broadPhase;
         for (f = this.m_fixtureList;
         f; f = f.m_next) {
            f.DestroyProxy(broadPhase);
         }
         var ce = this.m_contactList;
         while (ce) {
            var ce0 = ce;
            ce = ce.next;
            this.m_world.m_contactManager.Destroy(ce0.contact);
         }
         this.m_contactList = null;
      }
   }
   b2Body.prototype.IsActive = function () {
      return (this.m_flags & b2Body.e_activeFlag) == b2Body.e_activeFlag;
   }
   b2Body.prototype.IsSleepingAllowed = function () {
      return (this.m_flags & b2Body.e_allowSleepFlag) == b2Body.e_allowSleepFlag;
   }
   b2Body.prototype.GetFixtureList = function () {
      return this.m_fixtureList;
   }
   b2Body.prototype.GetJointList = function () {
      return this.m_jointList;
   }
   b2Body.prototype.GetControllerList = function () {
      return this.m_controllerList;
   }
   b2Body.prototype.GetContactList = function () {
      return this.m_contactList;
   }
   b2Body.prototype.GetNext = function () {
      return this.m_next;
   }
   b2Body.prototype.GetUserData = function () {
      return this.m_userData;
   }
   b2Body.prototype.SetUserData = function (data) {
      this.m_userData = data;
   }
   b2Body.prototype.GetWorld = function () {
      return this.m_world;
   }
   b2Body.prototype.b2Body = function (bd, world) {
      this.m_flags = 0;
      if (bd.bullet) {
         this.m_flags |= b2Body.e_bulletFlag;
      }
      if (bd.fixedRotation) {
         this.m_flags |= b2Body.e_fixedRotationFlag;
      }
      if (bd.allowSleep) {
         this.m_flags |= b2Body.e_allowSleepFlag;
      }
      if (bd.awake) {
         this.m_flags |= b2Body.e_awakeFlag;
      }
      if (bd.active) {
         this.m_flags |= b2Body.e_activeFlag;
      }
      this.m_world = world;
      this.m_xf.position.SetV(bd.position);
      this.m_xf.R.Set(bd.angle);
      this.m_sweep.localCenter.SetZero();
      this.m_sweep.t0 = 1.0;
      this.m_sweep.a0 = this.m_sweep.a = bd.angle;
      var tMat = this.m_xf.R;
      var tVec = this.m_sweep.localCenter;
      this.m_sweep.c.x = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      this.m_sweep.c.y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      this.m_sweep.c.x += this.m_xf.position.x;
      this.m_sweep.c.y += this.m_xf.position.y;
      this.m_sweep.c0.SetV(this.m_sweep.c);
      this.m_jointList = null;
      this.m_controllerList = null;
      this.m_contactList = null;
      this.m_controllerCount = 0;
      this.m_prev = null;
      this.m_next = null;
      this.m_linearVelocity.SetV(bd.linearVelocity);
      this.m_angularVelocity = bd.angularVelocity;
      this.m_linearDamping = bd.linearDamping;
      this.m_angularDamping = bd.angularDamping;
      this.m_force.Set(0.0, 0.0);
      this.m_torque = 0.0;
      this.m_sleepTime = 0.0;
      this.m_type = bd.type;
      if (this.m_type == b2Body.b2_dynamicBody) {
         this.m_mass = 1.0;
         this.m_invMass = 1.0;
      }
      else {
         this.m_mass = 0.0;
         this.m_invMass = 0.0;
      }
      this.m_I = 0.0;
      this.m_invI = 0.0;
      this.m_inertiaScale = bd.inertiaScale;
      this.m_userData = bd.userData;
      this.m_fixtureList = null;
      this.m_fixtureCount = 0;
   }
   b2Body.prototype.SynchronizeFixtures = function () {
      var xf1 = b2Body.s_xf1;
      xf1.R.Set(this.m_sweep.a0);
      var tMat = xf1.R;
      var tVec = this.m_sweep.localCenter;
      xf1.position.x = this.m_sweep.c0.x - (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      xf1.position.y = this.m_sweep.c0.y - (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      var f;
      var broadPhase = this.m_world.m_contactManager.m_broadPhase;
      for (f = this.m_fixtureList;
      f; f = f.m_next) {
         f.Synchronize(broadPhase, xf1, this.m_xf);
      }
   }
   b2Body.prototype.SynchronizeTransform = function () {
      this.m_xf.R.Set(this.m_sweep.a);
      var tMat = this.m_xf.R;
      var tVec = this.m_sweep.localCenter;
      this.m_xf.position.x = this.m_sweep.c.x - (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      this.m_xf.position.y = this.m_sweep.c.y - (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
   }
   b2Body.prototype.ShouldCollide = function (other) {
      if (this.m_type != b2Body.b2_dynamicBody && other.m_type != b2Body.b2_dynamicBody) {
         return false;
      }
      for (var jn = this.m_jointList; jn; jn = jn.next) {
         if (jn.other == other) if (jn.joint.m_collideConnected == false) {
            return false;
         }
      }
      return true;
   }
   b2Body.prototype.Advance = function (t) {
      if (t === undefined) t = 0;
      this.m_sweep.Advance(t);
      this.m_sweep.c.SetV(this.m_sweep.c0);
      this.m_sweep.a = this.m_sweep.a0;
      this.SynchronizeTransform();
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.b2Body.s_xf1 = new b2Transform();
      Box2D.Dynamics.b2Body.e_islandFlag = 0x0001;
      Box2D.Dynamics.b2Body.e_awakeFlag = 0x0002;
      Box2D.Dynamics.b2Body.e_allowSleepFlag = 0x0004;
      Box2D.Dynamics.b2Body.e_bulletFlag = 0x0008;
      Box2D.Dynamics.b2Body.e_fixedRotationFlag = 0x0010;
      Box2D.Dynamics.b2Body.e_activeFlag = 0x0020;
      Box2D.Dynamics.b2Body.b2_staticBody = 0;
      Box2D.Dynamics.b2Body.b2_kinematicBody = 1;
      Box2D.Dynamics.b2Body.b2_dynamicBody = 2;
   });
   b2BodyDef.b2BodyDef = function () {
      this.position = new b2Vec2();
      this.linearVelocity = new b2Vec2();
   };
   b2BodyDef.prototype.b2BodyDef = function () {
      this.userData = null;
      this.position.Set(0.0, 0.0);
      this.angle = 0.0;
      this.linearVelocity.Set(0, 0);
      this.angularVelocity = 0.0;
      this.linearDamping = 0.0;
      this.angularDamping = 0.0;
      this.allowSleep = true;
      this.awake = true;
      this.fixedRotation = false;
      this.bullet = false;
      this.type = b2Body.b2_staticBody;
      this.active = true;
      this.inertiaScale = 1.0;
   }
   b2ContactFilter.b2ContactFilter = function () {};
   b2ContactFilter.prototype.ShouldCollide = function (fixtureA, fixtureB) {
      var filter1 = fixtureA.GetFilterData();
      var filter2 = fixtureB.GetFilterData();
      if (filter1.groupIndex == filter2.groupIndex && filter1.groupIndex != 0) {
         return filter1.groupIndex > 0;
      }
      var collide = (filter1.maskBits & filter2.categoryBits) != 0 && (filter1.categoryBits & filter2.maskBits) != 0;
      return collide;
   }
   b2ContactFilter.prototype.RayCollide = function (userData, fixture) {
      if (!userData) return true;
      return this.ShouldCollide((userData instanceof b2Fixture ? userData : null), fixture);
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.b2ContactFilter.b2_defaultFilter = new b2ContactFilter();
   });
   b2ContactImpulse.b2ContactImpulse = function () {
      this.normalImpulses = new Vector_a2j_Number(b2Settings.b2_maxManifoldPoints);
      this.tangentImpulses = new Vector_a2j_Number(b2Settings.b2_maxManifoldPoints);
   };
   b2ContactListener.b2ContactListener = function () {};
   b2ContactListener.prototype.BeginContact = function (contact) {}
   b2ContactListener.prototype.EndContact = function (contact) {}
   b2ContactListener.prototype.PreSolve = function (contact, oldManifold) {}
   b2ContactListener.prototype.PostSolve = function (contact, impulse) {}
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.b2ContactListener.b2_defaultListener = new b2ContactListener();
   });
   b2ContactManager.b2ContactManager = function () {};
   b2ContactManager.prototype.b2ContactManager = function () {
      this.m_world = null;
      this.m_contactCount = 0;
      this.m_contactFilter = b2ContactFilter.b2_defaultFilter;
      this.m_contactListener = b2ContactListener.b2_defaultListener;
      this.m_contactFactory = new b2ContactFactory(this.m_allocator);
      this.m_broadPhase = new b2DynamicTreeBroadPhase();
   }
   b2ContactManager.prototype.AddPair = function (proxyUserDataA, proxyUserDataB) {
      var fixtureA = (proxyUserDataA instanceof b2Fixture ? proxyUserDataA : null);
      var fixtureB = (proxyUserDataB instanceof b2Fixture ? proxyUserDataB : null);
      var bodyA = fixtureA.GetBody();
      var bodyB = fixtureB.GetBody();
      if (bodyA == bodyB) return;
      var edge = bodyB.GetContactList();
      while (edge) {
         if (edge.other == bodyA) {
            var fA = edge.contact.GetFixtureA();
            var fB = edge.contact.GetFixtureB();
            if (fA == fixtureA && fB == fixtureB) return;
            if (fA == fixtureB && fB == fixtureA) return;
         }
         edge = edge.next;
      }
      if (bodyB.ShouldCollide(bodyA) == false) {
         return;
      }
      if (this.m_contactFilter.ShouldCollide(fixtureA, fixtureB) == false) {
         return;
      }
      var c = this.m_contactFactory.Create(fixtureA, fixtureB);
      fixtureA = c.GetFixtureA();
      fixtureB = c.GetFixtureB();
      bodyA = fixtureA.m_body;
      bodyB = fixtureB.m_body;
      c.m_prev = null;
      c.m_next = this.m_world.m_contactList;
      if (this.m_world.m_contactList != null) {
         this.m_world.m_contactList.m_prev = c;
      }
      this.m_world.m_contactList = c;
      c.m_nodeA.contact = c;
      c.m_nodeA.other = bodyB;
      c.m_nodeA.prev = null;
      c.m_nodeA.next = bodyA.m_contactList;
      if (bodyA.m_contactList != null) {
         bodyA.m_contactList.prev = c.m_nodeA;
      }
      bodyA.m_contactList = c.m_nodeA;
      c.m_nodeB.contact = c;
      c.m_nodeB.other = bodyA;
      c.m_nodeB.prev = null;
      c.m_nodeB.next = bodyB.m_contactList;
      if (bodyB.m_contactList != null) {
         bodyB.m_contactList.prev = c.m_nodeB;
      }
      bodyB.m_contactList = c.m_nodeB;
      ++this.m_world.m_contactCount;
      return;
   }
   b2ContactManager.prototype.FindNewContacts = function () {
      this.m_broadPhase.UpdatePairs(Box2D.generateCallback(this, this.AddPair));
   }
   b2ContactManager.prototype.Destroy = function (c) {
      var fixtureA = c.GetFixtureA();
      var fixtureB = c.GetFixtureB();
      var bodyA = fixtureA.GetBody();
      var bodyB = fixtureB.GetBody();
      if (c.IsTouching()) {
         this.m_contactListener.EndContact(c);
      }
      if (c.m_prev) {
         c.m_prev.m_next = c.m_next;
      }
      if (c.m_next) {
         c.m_next.m_prev = c.m_prev;
      }
      if (c == this.m_world.m_contactList) {
         this.m_world.m_contactList = c.m_next;
      }
      if (c.m_nodeA.prev) {
         c.m_nodeA.prev.next = c.m_nodeA.next;
      }
      if (c.m_nodeA.next) {
         c.m_nodeA.next.prev = c.m_nodeA.prev;
      }
      if (c.m_nodeA == bodyA.m_contactList) {
         bodyA.m_contactList = c.m_nodeA.next;
      }
      if (c.m_nodeB.prev) {
         c.m_nodeB.prev.next = c.m_nodeB.next;
      }
      if (c.m_nodeB.next) {
         c.m_nodeB.next.prev = c.m_nodeB.prev;
      }
      if (c.m_nodeB == bodyB.m_contactList) {
         bodyB.m_contactList = c.m_nodeB.next;
      }
      this.m_contactFactory.Destroy(c);
      --this.m_contactCount;
   }
   b2ContactManager.prototype.Collide = function () {
      var c = this.m_world.m_contactList;
      while (c) {
         var fixtureA = c.GetFixtureA();
         var fixtureB = c.GetFixtureB();
         var bodyA = fixtureA.GetBody();
         var bodyB = fixtureB.GetBody();
         var activeA = bodyA.IsAwake() && bodyA.m_type != b2Body.b2_staticBody;
         var activeB = bodyB.IsAwake() && bodyB.m_type != b2Body.b2_staticBody;
         // At least one body must be awake and it must be dynamic or kinematic.
         if (activeA == false && activeB == false) {
            c = c.GetNext();
            continue;
         }
         if (c.m_flags & b2Contact.e_filterFlag) {
            if (bodyB.ShouldCollide(bodyA) == false) {
               var cNuke = c;
               c = cNuke.GetNext();
               this.Destroy(cNuke);
               continue;
            }
            if (this.m_contactFilter.ShouldCollide(fixtureA, fixtureB) == false) {
               cNuke = c;
               c = cNuke.GetNext();
               this.Destroy(cNuke);
               continue;
            }
            c.m_flags &= ~b2Contact.e_filterFlag;
         }
         var proxyA = fixtureA.m_proxy;
         var proxyB = fixtureB.m_proxy;
         var overlap = this.m_broadPhase.TestOverlap(proxyA, proxyB);
         if (overlap == false) {
            cNuke = c;
            c = cNuke.GetNext();
            this.Destroy(cNuke);
            continue;
         }
         c.Update(this.m_contactListener);
         c = c.GetNext();
      }
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.b2ContactManager.s_evalCP = new b2ContactPoint();
   });
   b2DebugDraw.b2DebugDraw = function () {};
   b2DebugDraw.prototype.b2DebugDraw = function () {}
   b2DebugDraw.prototype.SetFlags = function (flags) {
      if (flags === undefined) flags = 0;
   }
   b2DebugDraw.prototype.GetFlags = function () {}
   b2DebugDraw.prototype.AppendFlags = function (flags) {
      if (flags === undefined) flags = 0;
   }
   b2DebugDraw.prototype.ClearFlags = function (flags) {
      if (flags === undefined) flags = 0;
   }
   b2DebugDraw.prototype.SetSprite = function (sprite) {}
   b2DebugDraw.prototype.GetSprite = function () {}
   b2DebugDraw.prototype.SetDrawScale = function (drawScale) {
      if (drawScale === undefined) drawScale = 0;
   }
   b2DebugDraw.prototype.GetDrawScale = function () {}
   b2DebugDraw.prototype.SetLineThickness = function (lineThickness) {
      if (lineThickness === undefined) lineThickness = 0;
   }
   b2DebugDraw.prototype.GetLineThickness = function () {}
   b2DebugDraw.prototype.SetAlpha = function (alpha) {
      if (alpha === undefined) alpha = 0;
   }
   b2DebugDraw.prototype.GetAlpha = function () {}
   b2DebugDraw.prototype.SetFillAlpha = function (alpha) {
      if (alpha === undefined) alpha = 0;
   }
   b2DebugDraw.prototype.GetFillAlpha = function () {}
   b2DebugDraw.prototype.SetXFormScale = function (xformScale) {
      if (xformScale === undefined) xformScale = 0;
   }
   b2DebugDraw.prototype.GetXFormScale = function () {}
   b2DebugDraw.prototype.DrawPolygon = function (vertices, vertexCount, color) {
      if (vertexCount === undefined) vertexCount = 0;
   }
   b2DebugDraw.prototype.DrawSolidPolygon = function (vertices, vertexCount, color) {
      if (vertexCount === undefined) vertexCount = 0;
   }
   b2DebugDraw.prototype.DrawCircle = function (center, radius, color) {
      if (radius === undefined) radius = 0;
   }
   b2DebugDraw.prototype.DrawSolidCircle = function (center, radius, axis, color) {
      if (radius === undefined) radius = 0;
   }
   b2DebugDraw.prototype.DrawSegment = function (p1, p2, color) {}
   b2DebugDraw.prototype.DrawTransform = function (xf) {}
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.b2DebugDraw.e_shapeBit = 0x0001;
      Box2D.Dynamics.b2DebugDraw.e_jointBit = 0x0002;
      Box2D.Dynamics.b2DebugDraw.e_aabbBit = 0x0004;
      Box2D.Dynamics.b2DebugDraw.e_pairBit = 0x0008;
      Box2D.Dynamics.b2DebugDraw.e_centerOfMassBit = 0x0010;
      Box2D.Dynamics.b2DebugDraw.e_controllerBit = 0x0020;
   });
   b2DestructionListener.b2DestructionListener = function () {};
   b2DestructionListener.prototype.SayGoodbyeJoint = function (joint) {}
   b2DestructionListener.prototype.SayGoodbyeFixture = function (fixture) {}
   b2FilterData.b2FilterData = function () {
      this.categoryBits = 0x0001;
      this.maskBits = 0xFFFF;
      this.groupIndex = 0;
   };
   b2FilterData.prototype.Copy = function () {
      var copy = new b2FilterData();
      copy.categoryBits = this.categoryBits;
      copy.maskBits = this.maskBits;
      copy.groupIndex = this.groupIndex;
      return copy;
   }
   b2Fixture.b2Fixture = function () {
      this.m_filter = new b2FilterData();
   };
   b2Fixture.prototype.GetType = function () {
      return this.m_shape.GetType();
   }
   b2Fixture.prototype.GetShape = function () {
      return this.m_shape;
   }
   b2Fixture.prototype.SetSensor = function (sensor) {
      if (this.m_isSensor == sensor) return;
      this.m_isSensor = sensor;
      if (this.m_body == null) return;
      var edge = this.m_body.GetContactList();
      while (edge) {
         var contact = edge.contact;
         var fixtureA = contact.GetFixtureA();
         var fixtureB = contact.GetFixtureB();
         if (fixtureA == this || fixtureB == this) contact.SetSensor(fixtureA.IsSensor() || fixtureB.IsSensor());
         edge = edge.next;
      }
   }
   b2Fixture.prototype.IsSensor = function () {
      return this.m_isSensor;
   }
   b2Fixture.prototype.SetFilterData = function (filter) {
      this.m_filter = filter.Copy();
      if (this.m_body) return;
      var edge = this.m_body.GetContactList();
      while (edge) {
         var contact = edge.contact;
         var fixtureA = contact.GetFixtureA();
         var fixtureB = contact.GetFixtureB();
         if (fixtureA == this || fixtureB == this) contact.FlagForFiltering();
         edge = edge.next;
      }
   }
   b2Fixture.prototype.GetFilterData = function () {
      return this.m_filter.Copy();
   }
   b2Fixture.prototype.GetBody = function () {
      return this.m_body;
   }
   b2Fixture.prototype.GetNext = function () {
      return this.m_next;
   }
   b2Fixture.prototype.GetUserData = function () {
      return this.m_userData;
   }
   b2Fixture.prototype.SetUserData = function (data) {
      this.m_userData = data;
   }
   b2Fixture.prototype.TestPoint = function (p) {
      return this.m_shape.TestPoint(this.m_body.GetTransform(), p);
   }
   b2Fixture.prototype.RayCast = function (output, input) {
      return this.m_shape.RayCast(output, input, this.m_body.GetTransform());
   }
   b2Fixture.prototype.GetMassData = function (massData) {
      if (massData === undefined) massData = null;
      if (massData == null) {
         massData = new b2MassData();
      }
      this.m_shape.ComputeMass(massData, this.m_density);
      return massData;
   }
   b2Fixture.prototype.SetDensity = function (density) {
      if (density === undefined) density = 0;
      this.m_density = density;
   }
   b2Fixture.prototype.GetDensity = function () {
      return this.m_density;
   }
   b2Fixture.prototype.GetFriction = function () {
      return this.m_friction;
   }
   b2Fixture.prototype.SetFriction = function (friction) {
      if (friction === undefined) friction = 0;
      this.m_friction = friction;
   }
   b2Fixture.prototype.GetRestitution = function () {
      return this.m_restitution;
   }
   b2Fixture.prototype.SetRestitution = function (restitution) {
      if (restitution === undefined) restitution = 0;
      this.m_restitution = restitution;
   }
   b2Fixture.prototype.GetAABB = function () {
      return this.m_aabb;
   }
   b2Fixture.prototype.b2Fixture = function () {
      this.m_aabb = new b2AABB();
      this.m_userData = null;
      this.m_body = null;
      this.m_next = null;
      this.m_shape = null;
      this.m_density = 0.0;
      this.m_friction = 0.0;
      this.m_restitution = 0.0;
   }
   b2Fixture.prototype.Create = function (body, xf, def) {
      this.m_userData = def.userData;
      this.m_friction = def.friction;
      this.m_restitution = def.restitution;
      this.m_body = body;
      this.m_next = null;
      this.m_filter = def.filter.Copy();
      this.m_isSensor = def.isSensor;
      this.m_shape = def.shape.Copy();
      this.m_density = def.density;
   }
   b2Fixture.prototype.Destroy = function () {
      this.m_shape = null;
   }
   b2Fixture.prototype.CreateProxy = function (broadPhase, xf) {
      this.m_shape.ComputeAABB(this.m_aabb, xf);
      this.m_proxy = broadPhase.CreateProxy(this.m_aabb, this);
   }
   b2Fixture.prototype.DestroyProxy = function (broadPhase) {
      if (this.m_proxy == null) {
         return;
      }
      broadPhase.DestroyProxy(this.m_proxy);
      this.m_proxy = null;
   }
   b2Fixture.prototype.Synchronize = function (broadPhase, transform1, transform2) {
      if (!this.m_proxy) return;
      var aabb1 = new b2AABB();
      var aabb2 = new b2AABB();
      this.m_shape.ComputeAABB(aabb1, transform1);
      this.m_shape.ComputeAABB(aabb2, transform2);
      this.m_aabb.Combine(aabb1, aabb2);
      var displacement = b2Math.SubtractVV(transform2.position, transform1.position);
      broadPhase.MoveProxy(this.m_proxy, this.m_aabb, displacement);
   }
   b2FixtureDef.b2FixtureDef = function () {
      this.filter = new b2FilterData();
   };
   b2FixtureDef.prototype.b2FixtureDef = function () {
      this.shape = null;
      this.userData = null;
      this.friction = 0.2;
      this.restitution = 0.0;
      this.density = 0.0;
      this.filter.categoryBits = 0x0001;
      this.filter.maskBits = 0xFFFF;
      this.filter.groupIndex = 0;
      this.isSensor = false;
   }
   b2Island.b2Island = function () {};
   b2Island.prototype.b2Island = function () {
      this.m_bodies = new Vector();
      this.m_contacts = new Vector();
      this.m_joints = new Vector();
   }
   b2Island.prototype.Initialize = function (bodyCapacity, contactCapacity, jointCapacity, allocator, listener, contactSolver) {
      if (bodyCapacity === undefined) bodyCapacity = 0;
      if (contactCapacity === undefined) contactCapacity = 0;
      if (jointCapacity === undefined) jointCapacity = 0;
      var i = 0;
      this.m_bodyCapacity = bodyCapacity;
      this.m_contactCapacity = contactCapacity;
      this.m_jointCapacity = jointCapacity;
      this.m_bodyCount = 0;
      this.m_contactCount = 0;
      this.m_jointCount = 0;
      this.m_allocator = allocator;
      this.m_listener = listener;
      this.m_contactSolver = contactSolver;
      for (i = this.m_bodies.length;
      i < bodyCapacity; i++)
      this.m_bodies[i] = null;
      for (i = this.m_contacts.length;
      i < contactCapacity; i++)
      this.m_contacts[i] = null;
      for (i = this.m_joints.length;
      i < jointCapacity; i++)
      this.m_joints[i] = null;
   }
   b2Island.prototype.Clear = function () {
      this.m_bodyCount = 0;
      this.m_contactCount = 0;
      this.m_jointCount = 0;
   }
   b2Island.prototype.Solve = function (step, gravity, allowSleep) {
      var i = 0;
      var j = 0;
      var b;
      var joint;
      for (i = 0;
      i < this.m_bodyCount; ++i) {
         b = this.m_bodies[i];
         if (b.GetType() != b2Body.b2_dynamicBody) continue;
         b.m_linearVelocity.x += step.dt * (gravity.x + b.m_invMass * b.m_force.x);
         b.m_linearVelocity.y += step.dt * (gravity.y + b.m_invMass * b.m_force.y);
         b.m_angularVelocity += step.dt * b.m_invI * b.m_torque;
         b.m_linearVelocity.Multiply(b2Math.Clamp(1.0 - step.dt * b.m_linearDamping, 0.0, 1.0));
         b.m_angularVelocity *= b2Math.Clamp(1.0 - step.dt * b.m_angularDamping, 0.0, 1.0);
      }
      this.m_contactSolver.Initialize(step, this.m_contacts, this.m_contactCount, this.m_allocator);
      var contactSolver = this.m_contactSolver;
      contactSolver.InitVelocityConstraints(step);
      for (i = 0;
      i < this.m_jointCount; ++i) {
         joint = this.m_joints[i];
         joint.InitVelocityConstraints(step);
      }
      for (i = 0;
      i < step.velocityIterations; ++i) {
         for (j = 0;
         j < this.m_jointCount; ++j) {
            joint = this.m_joints[j];
            joint.SolveVelocityConstraints(step);
         }
         contactSolver.SolveVelocityConstraints();
      }
      for (i = 0;
      i < this.m_jointCount; ++i) {
         joint = this.m_joints[i];
         joint.FinalizeVelocityConstraints();
      }
      contactSolver.FinalizeVelocityConstraints();
      for (i = 0;
      i < this.m_bodyCount; ++i) {
         b = this.m_bodies[i];
         if (b.GetType() == b2Body.b2_staticBody) continue;
         var translationX = step.dt * b.m_linearVelocity.x;
         var translationY = step.dt * b.m_linearVelocity.y;
         if ((translationX * translationX + translationY * translationY) > b2Settings.b2_maxTranslationSquared) {
            b.m_linearVelocity.Normalize();
            b.m_linearVelocity.x *= b2Settings.b2_maxTranslation * step.inv_dt;
            b.m_linearVelocity.y *= b2Settings.b2_maxTranslation * step.inv_dt;
         }
         var rotation = step.dt * b.m_angularVelocity;
         if (rotation * rotation > b2Settings.b2_maxRotationSquared) {
            if (b.m_angularVelocity < 0.0) {
               b.m_angularVelocity = (-b2Settings.b2_maxRotation * step.inv_dt);
            }
            else {
               b.m_angularVelocity = b2Settings.b2_maxRotation * step.inv_dt;
            }
         }
         b.m_sweep.c0.SetV(b.m_sweep.c);
         b.m_sweep.a0 = b.m_sweep.a;
         b.m_sweep.c.x += step.dt * b.m_linearVelocity.x;
         b.m_sweep.c.y += step.dt * b.m_linearVelocity.y;
         b.m_sweep.a += step.dt * b.m_angularVelocity;
         b.SynchronizeTransform();
      }
      for (i = 0;
      i < step.positionIterations; ++i) {
         var contactsOkay = contactSolver.SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
         var jointsOkay = true;
         for (j = 0;
         j < this.m_jointCount; ++j) {
            joint = this.m_joints[j];
            var jointOkay = joint.SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
            jointsOkay = jointsOkay && jointOkay;
         }
         if (contactsOkay && jointsOkay) {
            break;
         }
      }
      this.Report(contactSolver.m_constraints);
      if (allowSleep) {
         var minSleepTime = Number.MAX_VALUE;
         var linTolSqr = b2Settings.b2_linearSleepTolerance * b2Settings.b2_linearSleepTolerance;
         var angTolSqr = b2Settings.b2_angularSleepTolerance * b2Settings.b2_angularSleepTolerance;
         for (i = 0;
         i < this.m_bodyCount; ++i) {
            b = this.m_bodies[i];
            if (b.m_type == b2Body.b2_staticBody) {
               continue;
            }
            if ((b.m_flags & b2Body.e_allowSleepFlag) == 0 || b.m_angularVelocity * b.m_angularVelocity > angTolSqr || b2Math.Dot(b.m_linearVelocity, b.m_linearVelocity) > linTolSqr) {
               b.m_sleepTime = 0.0;
               minSleepTime = 0.0;
            }
            else {
               b.m_sleepTime += step.dt;
               minSleepTime = b2Math.Min(minSleepTime, b.m_sleepTime);
            }
         }
         if (minSleepTime >= b2Settings.b2_timeToSleep) {
            for (i = 0;
            i < this.m_bodyCount; ++i) {
               b = this.m_bodies[i];
               b.SetAwake(false);
            }
         }
      }
   }
   b2Island.prototype.SolveTOI = function (subStep) {
      var i = 0;
      var j = 0;
      this.m_contactSolver.Initialize(subStep, this.m_contacts, this.m_contactCount, this.m_allocator);
      var contactSolver = this.m_contactSolver;
      for (i = 0;
      i < this.m_jointCount; ++i) {
         this.m_joints[i].InitVelocityConstraints(subStep);
      }
      for (i = 0;
      i < subStep.velocityIterations; ++i) {
         contactSolver.SolveVelocityConstraints();
         for (j = 0;
         j < this.m_jointCount; ++j) {
            this.m_joints[j].SolveVelocityConstraints(subStep);
         }
      }
      for (i = 0;
      i < this.m_bodyCount; ++i) {
         var b = this.m_bodies[i];
         if (b.GetType() == b2Body.b2_staticBody) continue;
         var translationX = subStep.dt * b.m_linearVelocity.x;
         var translationY = subStep.dt * b.m_linearVelocity.y;
         if ((translationX * translationX + translationY * translationY) > b2Settings.b2_maxTranslationSquared) {
            b.m_linearVelocity.Normalize();
            b.m_linearVelocity.x *= b2Settings.b2_maxTranslation * subStep.inv_dt;
            b.m_linearVelocity.y *= b2Settings.b2_maxTranslation * subStep.inv_dt;
         }
         var rotation = subStep.dt * b.m_angularVelocity;
         if (rotation * rotation > b2Settings.b2_maxRotationSquared) {
            if (b.m_angularVelocity < 0.0) {
               b.m_angularVelocity = (-b2Settings.b2_maxRotation * subStep.inv_dt);
            }
            else {
               b.m_angularVelocity = b2Settings.b2_maxRotation * subStep.inv_dt;
            }
         }
         b.m_sweep.c0.SetV(b.m_sweep.c);
         b.m_sweep.a0 = b.m_sweep.a;
         b.m_sweep.c.x += subStep.dt * b.m_linearVelocity.x;
         b.m_sweep.c.y += subStep.dt * b.m_linearVelocity.y;
         b.m_sweep.a += subStep.dt * b.m_angularVelocity;
         b.SynchronizeTransform();
      }
      var k_toiBaumgarte = 0.75;
      for (i = 0;
      i < subStep.positionIterations; ++i) {
         var contactsOkay = contactSolver.SolvePositionConstraints(k_toiBaumgarte);
         var jointsOkay = true;
         for (j = 0;
         j < this.m_jointCount; ++j) {
            var jointOkay = this.m_joints[j].SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
            jointsOkay = jointsOkay && jointOkay;
         }
         if (contactsOkay && jointsOkay) {
            break;
         }
      }
      this.Report(contactSolver.m_constraints);
   }
   b2Island.prototype.Report = function (constraints) {
      if (this.m_listener == null) {
         return;
      }
      for (var i = 0; i < this.m_contactCount; ++i) {
         var c = this.m_contacts[i];
         var cc = constraints[i];
         for (var j = 0; j < cc.pointCount; ++j) {
            b2Island.s_impulse.normalImpulses[j] = cc.points[j].normalImpulse;
            b2Island.s_impulse.tangentImpulses[j] = cc.points[j].tangentImpulse;
         }
         this.m_listener.PostSolve(c, b2Island.s_impulse);
      }
   }
   b2Island.prototype.AddBody = function (body) {
      body.m_islandIndex = this.m_bodyCount;
      this.m_bodies[this.m_bodyCount++] = body;
   }
   b2Island.prototype.AddContact = function (contact) {
      this.m_contacts[this.m_contactCount++] = contact;
   }
   b2Island.prototype.AddJoint = function (joint) {
      this.m_joints[this.m_jointCount++] = joint;
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.b2Island.s_impulse = new b2ContactImpulse();
   });
   b2TimeStep.b2TimeStep = function () {};
   b2TimeStep.prototype.Set = function (step) {
      this.dt = step.dt;
      this.inv_dt = step.inv_dt;
      this.positionIterations = step.positionIterations;
      this.velocityIterations = step.velocityIterations;
      this.warmStarting = step.warmStarting;
   }
   b2World.b2World = function () {
      this.s_stack = new Vector();
      this.m_contactManager = new b2ContactManager();
      this.m_contactSolver = new b2ContactSolver();
      this.m_island = new b2Island();
   };
   b2World.prototype.b2World = function (gravity, doSleep) {
      this.m_destructionListener = null;
      this.m_debugDraw = null;
      this.m_bodyList = null;
      this.m_contactList = null;
      this.m_jointList = null;
      this.m_controllerList = null;
      this.m_bodyCount = 0;
      this.m_contactCount = 0;
      this.m_jointCount = 0;
      this.m_controllerCount = 0;
      b2World.m_warmStarting = true;
      b2World.m_continuousPhysics = true;
      this.m_allowSleep = doSleep;
      this.m_gravity = gravity;
      this.m_inv_dt0 = 0.0;
      this.m_contactManager.m_world = this;
      var bd = new b2BodyDef();
      this.m_groundBody = this.CreateBody(bd);
   }
   b2World.prototype.SetDestructionListener = function (listener) {
      this.m_destructionListener = listener;
   }
   b2World.prototype.SetContactFilter = function (filter) {
      this.m_contactManager.m_contactFilter = filter;
   }
   b2World.prototype.SetContactListener = function (listener) {
      this.m_contactManager.m_contactListener = listener;
   }
   b2World.prototype.SetDebugDraw = function (debugDraw) {
      this.m_debugDraw = debugDraw;
   }
   b2World.prototype.SetBroadPhase = function (broadPhase) {
      var oldBroadPhase = this.m_contactManager.m_broadPhase;
      this.m_contactManager.m_broadPhase = broadPhase;
      for (var b = this.m_bodyList; b; b = b.m_next) {
         for (var f = b.m_fixtureList; f; f = f.m_next) {
            f.m_proxy = broadPhase.CreateProxy(oldBroadPhase.GetFatAABB(f.m_proxy), f);
         }
      }
   }
   b2World.prototype.Validate = function () {
      this.m_contactManager.m_broadPhase.Validate();
   }
   b2World.prototype.GetProxyCount = function () {
      return this.m_contactManager.m_broadPhase.GetProxyCount();
   }
   b2World.prototype.CreateBody = function (def) {
      if (this.IsLocked() == true) {
         return null;
      }
      var b = new b2Body(def, this);
      b.m_prev = null;
      b.m_next = this.m_bodyList;
      if (this.m_bodyList) {
         this.m_bodyList.m_prev = b;
      }
      this.m_bodyList = b;
      ++this.m_bodyCount;
      return b;
   }
   b2World.prototype.DestroyBody = function (b) {
      if (this.IsLocked() == true) {
         return;
      }
      var jn = b.m_jointList;
      while (jn) {
         var jn0 = jn;
         jn = jn.next;
         if (this.m_destructionListener) {
            this.m_destructionListener.SayGoodbyeJoint(jn0.joint);
         }
         this.DestroyJoint(jn0.joint);
      }
      var coe = b.m_controllerList;
      while (coe) {
         var coe0 = coe;
         coe = coe.nextController;
         coe0.controller.RemoveBody(b);
      }
      var ce = b.m_contactList;
      while (ce) {
         var ce0 = ce;
         ce = ce.next;
         this.m_contactManager.Destroy(ce0.contact);
      }
      b.m_contactList = null;
      var f = b.m_fixtureList;
      while (f) {
         var f0 = f;
         f = f.m_next;
         if (this.m_destructionListener) {
            this.m_destructionListener.SayGoodbyeFixture(f0);
         }
         f0.DestroyProxy(this.m_contactManager.m_broadPhase);
         f0.Destroy();
      }
      b.m_fixtureList = null;
      b.m_fixtureCount = 0;
      if (b.m_prev) {
         b.m_prev.m_next = b.m_next;
      }
      if (b.m_next) {
         b.m_next.m_prev = b.m_prev;
      }
      if (b == this.m_bodyList) {
         this.m_bodyList = b.m_next;
      }--this.m_bodyCount;
   }
   b2World.prototype.CreateJoint = function (def) {
      var j = b2Joint.Create(def, null);
      j.m_prev = null;
      j.m_next = this.m_jointList;
      if (this.m_jointList) {
         this.m_jointList.m_prev = j;
      }
      this.m_jointList = j;
      ++this.m_jointCount;
      j.m_edgeA.joint = j;
      j.m_edgeA.other = j.m_bodyB;
      j.m_edgeA.prev = null;
      j.m_edgeA.next = j.m_bodyA.m_jointList;
      if (j.m_bodyA.m_jointList) j.m_bodyA.m_jointList.prev = j.m_edgeA;
      j.m_bodyA.m_jointList = j.m_edgeA;
      j.m_edgeB.joint = j;
      j.m_edgeB.other = j.m_bodyA;
      j.m_edgeB.prev = null;
      j.m_edgeB.next = j.m_bodyB.m_jointList;
      if (j.m_bodyB.m_jointList) j.m_bodyB.m_jointList.prev = j.m_edgeB;
      j.m_bodyB.m_jointList = j.m_edgeB;
      var bodyA = def.bodyA;
      var bodyB = def.bodyB;
      if (def.collideConnected == false) {
         var edge = bodyB.GetContactList();
         while (edge) {
            if (edge.other == bodyA) {
               edge.contact.FlagForFiltering();
            }
            edge = edge.next;
         }
      }
      return j;
   }
   b2World.prototype.DestroyJoint = function (j) {
      var collideConnected = j.m_collideConnected;
      if (j.m_prev) {
         j.m_prev.m_next = j.m_next;
      }
      if (j.m_next) {
         j.m_next.m_prev = j.m_prev;
      }
      if (j == this.m_jointList) {
         this.m_jointList = j.m_next;
      }
      var bodyA = j.m_bodyA;
      var bodyB = j.m_bodyB;
      bodyA.SetAwake(true);
      bodyB.SetAwake(true);
      if (j.m_edgeA.prev) {
         j.m_edgeA.prev.next = j.m_edgeA.next;
      }
      if (j.m_edgeA.next) {
         j.m_edgeA.next.prev = j.m_edgeA.prev;
      }
      if (j.m_edgeA == bodyA.m_jointList) {
         bodyA.m_jointList = j.m_edgeA.next;
      }
      j.m_edgeA.prev = null;
      j.m_edgeA.next = null;
      if (j.m_edgeB.prev) {
         j.m_edgeB.prev.next = j.m_edgeB.next;
      }
      if (j.m_edgeB.next) {
         j.m_edgeB.next.prev = j.m_edgeB.prev;
      }
      if (j.m_edgeB == bodyB.m_jointList) {
         bodyB.m_jointList = j.m_edgeB.next;
      }
      j.m_edgeB.prev = null;
      j.m_edgeB.next = null;
      b2Joint.Destroy(j, null);
      --this.m_jointCount;
      if (collideConnected == false) {
         var edge = bodyB.GetContactList();
         while (edge) {
            if (edge.other == bodyA) {
               edge.contact.FlagForFiltering();
            }
            edge = edge.next;
         }
      }
   }
   b2World.prototype.AddController = function (c) {
      c.m_next = this.m_controllerList;
      c.m_prev = null;
      this.m_controllerList = c;
      c.m_world = this;
      this.m_controllerCount++;
      return c;
   }
   b2World.prototype.RemoveController = function (c) {
      if (c.m_prev) c.m_prev.m_next = c.m_next;
      if (c.m_next) c.m_next.m_prev = c.m_prev;
      if (this.m_controllerList == c) this.m_controllerList = c.m_next;
      this.m_controllerCount--;
   }
   b2World.prototype.CreateController = function (controller) {
      if (controller.m_world != this) throw new Error("Controller can only be a member of one world");
      controller.m_next = this.m_controllerList;
      controller.m_prev = null;
      if (this.m_controllerList) this.m_controllerList.m_prev = controller;
      this.m_controllerList = controller;
      ++this.m_controllerCount;
      controller.m_world = this;
      return controller;
   }
   b2World.prototype.DestroyController = function (controller) {
      controller.Clear();
      if (controller.m_next) controller.m_next.m_prev = controller.m_prev;
      if (controller.m_prev) controller.m_prev.m_next = controller.m_next;
      if (controller == this.m_controllerList) this.m_controllerList = controller.m_next;
      --this.m_controllerCount;
   }
   b2World.prototype.SetWarmStarting = function (flag) {
      b2World.m_warmStarting = flag;
   }
   b2World.prototype.SetContinuousPhysics = function (flag) {
      b2World.m_continuousPhysics = flag;
   }
   b2World.prototype.GetBodyCount = function () {
      return this.m_bodyCount;
   }
   b2World.prototype.GetJointCount = function () {
      return this.m_jointCount;
   }
   b2World.prototype.GetContactCount = function () {
      return this.m_contactCount;
   }
   b2World.prototype.SetGravity = function (gravity) {
      this.m_gravity = gravity;
   }
   b2World.prototype.GetGravity = function () {
      return this.m_gravity;
   }
   b2World.prototype.GetGroundBody = function () {
      return this.m_groundBody;
   }
   b2World.prototype.Step = function (dt, velocityIterations, positionIterations) {
      if (dt === undefined) dt = 0;
      if (velocityIterations === undefined) velocityIterations = 0;
      if (positionIterations === undefined) positionIterations = 0;
      if (this.m_flags & b2World.e_newFixture) {
         this.m_contactManager.FindNewContacts();
         this.m_flags &= ~b2World.e_newFixture;
      }
      this.m_flags |= b2World.e_locked;
      var step = b2World.s_timestep2;
      step.dt = dt;
      step.velocityIterations = velocityIterations;
      step.positionIterations = positionIterations;
      if (dt > 0.0) {
         step.inv_dt = 1.0 / dt;
      }
      else {
         step.inv_dt = 0.0;
      }
      step.dtRatio = this.m_inv_dt0 * dt;
      step.warmStarting = b2World.m_warmStarting;
      this.m_contactManager.Collide();
      if (step.dt > 0.0) {
         this.Solve(step);
      }
      if (b2World.m_continuousPhysics && step.dt > 0.0) {
         this.SolveTOI(step);
      }
      if (step.dt > 0.0) {
         this.m_inv_dt0 = step.inv_dt;
      }
      this.m_flags &= ~b2World.e_locked;
   }
   b2World.prototype.ClearForces = function () {
      for (var body = this.m_bodyList; body; body = body.m_next) {
         body.m_force.SetZero();
         body.m_torque = 0.0;
      }
   }
   b2World.prototype.DrawDebugData = function () {
      if (this.m_debugDraw == null) {
         return;
      }
      this.m_debugDraw.m_sprite.graphics.clear();
      var flags = this.m_debugDraw.GetFlags();
      var i = 0;
      var b;
      var f;
      var s;
      var j;
      var bp;
      var invQ = new b2Vec2;
      var x1 = new b2Vec2;
      var x2 = new b2Vec2;
      var xf;
      var b1 = new b2AABB();
      var b2 = new b2AABB();
      var vs = [new b2Vec2(), new b2Vec2(), new b2Vec2(), new b2Vec2()];
      var color = new b2Color(0, 0, 0);
      if (flags & b2DebugDraw.e_shapeBit) {
         for (b = this.m_bodyList;
         b; b = b.m_next) {
            xf = b.m_xf;
            for (f = b.GetFixtureList();
            f; f = f.m_next) {
               s = f.GetShape();
               if (b.IsActive() == false) {
                  color.Set(0.5, 0.5, 0.3);
                  this.DrawShape(s, xf, color);
               }
               else if (b.GetType() == b2Body.b2_staticBody) {
                  color.Set(0.5, 0.9, 0.5);
                  this.DrawShape(s, xf, color);
               }
               else if (b.GetType() == b2Body.b2_kinematicBody) {
                  color.Set(0.5, 0.5, 0.9);
                  this.DrawShape(s, xf, color);
               }
               else if (b.IsAwake() == false) {
                  color.Set(0.6, 0.6, 0.6);
                  this.DrawShape(s, xf, color);
               }
               else {
                  color.Set(0.9, 0.7, 0.7);
                  this.DrawShape(s, xf, color);
               }
            }
         }
      }
      if (flags & b2DebugDraw.e_jointBit) {
         for (j = this.m_jointList;
         j; j = j.m_next) {
            this.DrawJoint(j);
         }
      }
      if (flags & b2DebugDraw.e_controllerBit) {
         for (var c = this.m_controllerList; c; c = c.m_next) {
            c.Draw(this.m_debugDraw);
         }
      }
      if (flags & b2DebugDraw.e_pairBit) {
         color.Set(0.3, 0.9, 0.9);
         for (var contact = this.m_contactManager.m_contactList; contact; contact = contact.GetNext()) {
            var fixtureA = contact.GetFixtureA();
            var fixtureB = contact.GetFixtureB();
            var cA = fixtureA.GetAABB().GetCenter();
            var cB = fixtureB.GetAABB().GetCenter();
            this.m_debugDraw.DrawSegment(cA, cB, color);
         }
      }
      if (flags & b2DebugDraw.e_aabbBit) {
         bp = this.m_contactManager.m_broadPhase;
         vs = [new b2Vec2(), new b2Vec2(), new b2Vec2(), new b2Vec2()];
         for (b = this.m_bodyList;
         b; b = b.GetNext()) {
            if (b.IsActive() == false) {
               continue;
            }
            for (f = b.GetFixtureList();
            f; f = f.GetNext()) {
               var aabb = bp.GetFatAABB(f.m_proxy);
               vs[0].Set(aabb.lowerBound.x, aabb.lowerBound.y);
               vs[1].Set(aabb.upperBound.x, aabb.lowerBound.y);
               vs[2].Set(aabb.upperBound.x, aabb.upperBound.y);
               vs[3].Set(aabb.lowerBound.x, aabb.upperBound.y);
               this.m_debugDraw.DrawPolygon(vs, 4, color);
            }
         }
      }
      if (flags & b2DebugDraw.e_centerOfMassBit) {
         for (b = this.m_bodyList;
         b; b = b.m_next) {
            xf = b2World.s_xf;
            xf.R = b.m_xf.R;
            xf.position = b.GetWorldCenter();
            this.m_debugDraw.DrawTransform(xf);
         }
      }
   }
   b2World.prototype.QueryAABB = function (callback, aabb) {
      var __this = this;
      var broadPhase = __this.m_contactManager.m_broadPhase;

      function WorldQueryWrapper(proxy) {
         return callback(broadPhase.GetUserData(proxy));
      };
      broadPhase.Query(WorldQueryWrapper, aabb);
   }
   b2World.prototype.QueryShape = function (callback, shape, transform) {
      var __this = this;
      if (transform === undefined) transform = null;
      if (transform == null) {
         transform = new b2Transform();
         transform.SetIdentity();
      }
      var broadPhase = __this.m_contactManager.m_broadPhase;

      function WorldQueryWrapper(proxy) {
         var fixture = (broadPhase.GetUserData(proxy) instanceof b2Fixture ? broadPhase.GetUserData(proxy) : null);
         if (b2Shape.TestOverlap(shape, transform, fixture.GetShape(), fixture.GetBody().GetTransform())) return callback(fixture);
         return true;
      };
      var aabb = new b2AABB();
      shape.ComputeAABB(aabb, transform);
      broadPhase.Query(WorldQueryWrapper, aabb);
   }
   b2World.prototype.QueryPoint = function (callback, p) {
      var __this = this;
      var broadPhase = __this.m_contactManager.m_broadPhase;

      function WorldQueryWrapper(proxy) {
         var fixture = (broadPhase.GetUserData(proxy) instanceof b2Fixture ? broadPhase.GetUserData(proxy) : null);
         if (fixture.TestPoint(p)) return callback(fixture);
         return true;
      };
      var aabb = new b2AABB();
      aabb.lowerBound.Set(p.x - b2Settings.b2_linearSlop, p.y - b2Settings.b2_linearSlop);
      aabb.upperBound.Set(p.x + b2Settings.b2_linearSlop, p.y + b2Settings.b2_linearSlop);
      broadPhase.Query(WorldQueryWrapper, aabb);
   }
   b2World.prototype.RayCast = function (callback, point1, point2) {
      var __this = this;
      var broadPhase = __this.m_contactManager.m_broadPhase;
      var output = new b2RayCastOutput;

      function RayCastWrapper(input, proxy) {
         var userData = broadPhase.GetUserData(proxy);
         var fixture = (userData instanceof b2Fixture ? userData : null);
         var hit = fixture.RayCast(output, input);
         if (hit) {
            var fraction = output.fraction;
            var point = new b2Vec2((1.0 - fraction) * point1.x + fraction * point2.x, (1.0 - fraction) * point1.y + fraction * point2.y);
            return callback(fixture, point, output.normal, fraction);
         }
         return input.maxFraction;
      };
      var input = new b2RayCastInput(point1, point2);
      broadPhase.RayCast(RayCastWrapper, input);
   }
   b2World.prototype.RayCastOne = function (point1, point2) {
      var __this = this;
      var result;

      function RayCastOneWrapper(fixture, point, normal, fraction) {
         if (fraction === undefined) fraction = 0;
         result = fixture;
         return fraction;
      };
      __this.RayCast(RayCastOneWrapper, point1, point2);
      return result;
   }
   b2World.prototype.RayCastAll = function (point1, point2) {
      var __this = this;
      var result = new Vector();

      function RayCastAllWrapper(fixture, point, normal, fraction) {
         if (fraction === undefined) fraction = 0;
         result[result.length] = fixture;
         return 1;
      };
      __this.RayCast(RayCastAllWrapper, point1, point2);
      return result;
   }
   b2World.prototype.GetBodyList = function () {
      return this.m_bodyList;
   }
   b2World.prototype.GetJointList = function () {
      return this.m_jointList;
   }
   b2World.prototype.GetContactList = function () {
      return this.m_contactList;
   }
   b2World.prototype.IsLocked = function () {
      return (this.m_flags & b2World.e_locked) > 0;
   }
   b2World.prototype.Solve = function (step) {
      var b;
      for (var controller = this.m_controllerList; controller; controller = controller.m_next) {
         controller.Step(step);
      }
      var island = this.m_island;
      island.Initialize(this.m_bodyCount, this.m_contactCount, this.m_jointCount, null, this.m_contactManager.m_contactListener, this.m_contactSolver);
      for (b = this.m_bodyList;
      b; b = b.m_next) {
         b.m_flags &= ~b2Body.e_islandFlag;
      }
      for (var c = this.m_contactList; c; c = c.m_next) {
         c.m_flags &= ~b2Contact.e_islandFlag;
      }
      for (var j = this.m_jointList; j; j = j.m_next) {
         j.m_islandFlag = false;
      }
      var stackSize = parseInt(this.m_bodyCount);
      var stack = this.s_stack;
      for (var seed = this.m_bodyList; seed; seed = seed.m_next) {
         if (seed.m_flags & b2Body.e_islandFlag) {
            continue;
         }
         if (seed.IsAwake() == false || seed.IsActive() == false) {
            continue;
         }
         if (seed.GetType() == b2Body.b2_staticBody) {
            continue;
         }
         island.Clear();
         var stackCount = 0;
         stack[stackCount++] = seed;
         seed.m_flags |= b2Body.e_islandFlag;
         while (stackCount > 0) {
            b = stack[--stackCount];
            island.AddBody(b);
            if (b.IsAwake() == false) {
               b.SetAwake(true);
            }
            if (b.GetType() == b2Body.b2_staticBody) {
               continue;
            }
            var other;
            for (var ce = b.m_contactList; ce; ce = ce.next) {
               if (ce.contact.m_flags & b2Contact.e_islandFlag) {
                  continue;
               }
               if (ce.contact.IsSensor() == true || ce.contact.IsEnabled() == false || ce.contact.IsTouching() == false) {
                  continue;
               }
               island.AddContact(ce.contact);
               ce.contact.m_flags |= b2Contact.e_islandFlag;
               other = ce.other;
               if (other.m_flags & b2Body.e_islandFlag) {
                  continue;
               }
               stack[stackCount++] = other;
               other.m_flags |= b2Body.e_islandFlag;
            }
            for (var jn = b.m_jointList; jn; jn = jn.next) {
               if (jn.joint.m_islandFlag == true) {
                  continue;
               }
               other = jn.other;
               if (other.IsActive() == false) {
                  continue;
               }
               island.AddJoint(jn.joint);
               jn.joint.m_islandFlag = true;
               if (other.m_flags & b2Body.e_islandFlag) {
                  continue;
               }
               stack[stackCount++] = other;
               other.m_flags |= b2Body.e_islandFlag;
            }
         }
         island.Solve(step, this.m_gravity, this.m_allowSleep);
         for (var i = 0; i < island.m_bodyCount; ++i) {
            b = island.m_bodies[i];
            if (b.GetType() == b2Body.b2_staticBody) {
               b.m_flags &= ~b2Body.e_islandFlag;
            }
         }
      }
      for (i = 0;
      i < stack.length; ++i) {
         if (!stack[i]) break;
         stack[i] = null;
      }
      for (b = this.m_bodyList;
      b; b = b.m_next) {
         if (b.IsAwake() == false || b.IsActive() == false) {
            continue;
         }
         if (b.GetType() == b2Body.b2_staticBody) {
            continue;
         }
         b.SynchronizeFixtures();
      }
      this.m_contactManager.FindNewContacts();
   }
   b2World.prototype.SolveTOI = function (step) {
      var b;
      var fA;
      var fB;
      var bA;
      var bB;
      var cEdge;
      var j;
      var island = this.m_island;
      island.Initialize(this.m_bodyCount, b2Settings.b2_maxTOIContactsPerIsland, b2Settings.b2_maxTOIJointsPerIsland, null, this.m_contactManager.m_contactListener, this.m_contactSolver);
      var queue = b2World.s_queue;
      for (b = this.m_bodyList;
      b; b = b.m_next) {
         b.m_flags &= ~b2Body.e_islandFlag;
         b.m_sweep.t0 = 0.0;
      }
      var c;
      for (c = this.m_contactList;
      c; c = c.m_next) {
         c.m_flags &= ~ (b2Contact.e_toiFlag | b2Contact.e_islandFlag);
      }
      for (j = this.m_jointList;
      j; j = j.m_next) {
         j.m_islandFlag = false;
      }
      for (;;) {
         var minContact = null;
         var minTOI = 1.0;
         for (c = this.m_contactList;
         c; c = c.m_next) {
            if (c.IsSensor() == true || c.IsEnabled() == false || c.IsContinuous() == false) {
               continue;
            }
            var toi = 1.0;
            if (c.m_flags & b2Contact.e_toiFlag) {
               toi = c.m_toi;
            }
            else {
               fA = c.m_fixtureA;
               fB = c.m_fixtureB;
               bA = fA.m_body;
               bB = fB.m_body;
               var activeA = bA.IsAwake() && bA.m_type != b2Body.b2_staticBody;
               var activeB = bB.IsAwake() && bB.m_type != b2Body.b2_staticBody;
               if (activeA == false && activeB == false) {
                  continue;
               }
               var t0 = bA.m_sweep.t0;
               if (bA.m_sweep.t0 < bB.m_sweep.t0) {
                  t0 = bB.m_sweep.t0;
                  bA.m_sweep.Advance(t0);
               }
               else if (bB.m_sweep.t0 < bA.m_sweep.t0) {
                  t0 = bA.m_sweep.t0;
                  bB.m_sweep.Advance(t0);
               }
               toi = c.ComputeTOI(bA.m_sweep, bB.m_sweep);
               b2Settings.b2Assert(0.0 <= toi && toi <= 1.0);
               if (toi > 0.0 && toi < 1.0) {
                  toi = (1.0 - toi) * t0 + toi;
                  if (toi > 1) toi = 1;
               }
               c.m_toi = toi;
               c.m_flags |= b2Contact.e_toiFlag;
            }
            if (FLOAT_EPSILON < toi && toi < minTOI) {
               minContact = c;
               minTOI = toi;
            }
         }
         if (minContact == null || 1.0 - 100.0 * FLOAT_EPSILON < minTOI) {
            break;
         }
         fA = minContact.m_fixtureA;
         fB = minContact.m_fixtureB;
         bA = fA.m_body;
         bB = fB.m_body;
         b2World.s_backupA.Set(bA.m_sweep);
         b2World.s_backupB.Set(bB.m_sweep);
         bA.Advance(minTOI);
         bB.Advance(minTOI);
         minContact.Update(this.m_contactManager.m_contactListener);
         minContact.m_flags &= ~b2Contact.e_toiFlag;
         if (minContact.IsSensor() == true || minContact.IsEnabled() == false) {
            bA.m_sweep.Set(b2World.s_backupA);
            bB.m_sweep.Set(b2World.s_backupB);
            bA.SynchronizeTransform();
            bB.SynchronizeTransform();
            continue;
         }
         if (minContact.IsTouching() == false) {
            continue;
         }
         var seed = bA;
         if (seed.GetType() != b2Body.b2_dynamicBody) {
            seed = bB;
         }
         island.Clear();
         var queueStart = 0;
         var queueSize = 0;
         queue[queueStart + queueSize++] = seed;
         seed.m_flags |= b2Body.e_islandFlag;
         while (queueSize > 0) {
            b = queue[queueStart++];
            --queueSize;
            island.AddBody(b);
            if (b.IsAwake() == false) {
               b.SetAwake(true);
            }
            if (b.GetType() != b2Body.b2_dynamicBody) {
               continue;
            }
            for (cEdge = b.m_contactList;
            cEdge; cEdge = cEdge.next) {
               if (island.m_contactCount == island.m_contactCapacity) {
                  break;
               }
               if (cEdge.contact.m_flags & b2Contact.e_islandFlag) {
                  continue;
               }
               if (cEdge.contact.IsSensor() == true || cEdge.contact.IsEnabled() == false || cEdge.contact.IsTouching() == false) {
                  continue;
               }
               island.AddContact(cEdge.contact);
               cEdge.contact.m_flags |= b2Contact.e_islandFlag;
               var other = cEdge.other;
               if (other.m_flags & b2Body.e_islandFlag) {
                  continue;
               }
               if (other.GetType() != b2Body.b2_staticBody) {
                  other.Advance(minTOI);
                  other.SetAwake(true);
               }
               queue[queueStart + queueSize] = other;
               ++queueSize;
               other.m_flags |= b2Body.e_islandFlag;
            }
            for (var jEdge = b.m_jointList; jEdge; jEdge = jEdge.next) {
               if (island.m_jointCount == island.m_jointCapacity) continue;
               if (jEdge.joint.m_islandFlag == true) continue;
               other = jEdge.other;
               if (other.IsActive() == false) {
                  continue;
               }
               island.AddJoint(jEdge.joint);
               jEdge.joint.m_islandFlag = true;
               if (other.m_flags & b2Body.e_islandFlag) continue;
               if (other.GetType() != b2Body.b2_staticBody) {
                  other.Advance(minTOI);
                  other.SetAwake(true);
               }
               queue[queueStart + queueSize] = other;
               ++queueSize;
               other.m_flags |= b2Body.e_islandFlag;
            }
         }
         var subStep = b2World.s_timestep;
         subStep.warmStarting = false;
         subStep.dt = (1.0 - minTOI) * step.dt;
         subStep.inv_dt = 1.0 / subStep.dt;
         subStep.dtRatio = 0.0;
         subStep.velocityIterations = step.velocityIterations;
         subStep.positionIterations = step.positionIterations;
         island.SolveTOI(subStep);
         var i = 0;
         for (i = 0;
         i < island.m_bodyCount; ++i) {
            b = island.m_bodies[i];
            b.m_flags &= ~b2Body.e_islandFlag;
            if (b.IsAwake() == false) {
               continue;
            }
            if (b.GetType() != b2Body.b2_dynamicBody) {
               continue;
            }
            b.SynchronizeFixtures();
            for (cEdge = b.m_contactList;
            cEdge; cEdge = cEdge.next) {
               cEdge.contact.m_flags &= ~b2Contact.e_toiFlag;
            }
         }
         for (i = 0;
         i < island.m_contactCount; ++i) {
            c = island.m_contacts[i];
            c.m_flags &= ~ (b2Contact.e_toiFlag | b2Contact.e_islandFlag);
         }
         for (i = 0;
         i < island.m_jointCount; ++i) {
            j = island.m_joints[i];
            j.m_islandFlag = false;
         }
         this.m_contactManager.FindNewContacts();
      }
   }
   b2World.prototype.DrawJoint = function (joint) {
      var b1 = joint.GetBodyA();
      var b2 = joint.GetBodyB();
      var xf1 = b1.m_xf;
      var xf2 = b2.m_xf;
      var x1 = xf1.position;
      var x2 = xf2.position;
      var p1 = joint.GetAnchorA();
      var p2 = joint.GetAnchorB();
      var color = b2World.s_jointColor;
      switch (joint.m_type) {
      case b2Joint.e_distanceJoint:
         this.m_debugDraw.DrawSegment(p1, p2, color);
         break;
      case b2Joint.e_pulleyJoint:
         {
            var pulley = ((joint instanceof b2PulleyJoint ? joint : null));
            var s1 = pulley.GetGroundAnchorA();
            var s2 = pulley.GetGroundAnchorB();
            this.m_debugDraw.DrawSegment(s1, p1, color);
            this.m_debugDraw.DrawSegment(s2, p2, color);
            this.m_debugDraw.DrawSegment(s1, s2, color);
         }
         break;
      case b2Joint.e_mouseJoint:
         this.m_debugDraw.DrawSegment(p1, p2, color);
         break;
      default:
         if (b1 != this.m_groundBody) this.m_debugDraw.DrawSegment(x1, p1, color);
         this.m_debugDraw.DrawSegment(p1, p2, color);
         if (b2 != this.m_groundBody) this.m_debugDraw.DrawSegment(x2, p2, color);
      }
   }
   b2World.prototype.DrawShape = function (shape, xf, color) {
      switch (shape.m_type) {
      case b2Shape.e_circleShape:
         {
            var circle = ((shape instanceof b2CircleShape ? shape : null));
            var center = b2Math.MulX(xf, circle.m_p);
            var radius = circle.m_radius;
            var axis = xf.R.col1;
            this.m_debugDraw.DrawSolidCircle(center, radius, axis, color);
         }
         break;
      case b2Shape.e_polygonShape:
         {
            var i = 0;
            var poly = ((shape instanceof b2PolygonShape ? shape : null));
            var vertexCount = parseInt(poly.GetVertexCount());
            var localVertices = poly.GetVertices();
            var vertices = new Vector(vertexCount);
            for (i = 0;
            i < vertexCount; ++i) {
               vertices[i] = b2Math.MulX(xf, localVertices[i]);
            }
            this.m_debugDraw.DrawSolidPolygon(vertices, vertexCount, color);
         }
         break;
      case b2Shape.e_edgeShape:
         {
            var edge = (shape instanceof b2EdgeShape ? shape : null);
            this.m_debugDraw.DrawSegment(b2Math.MulX(xf, edge.GetVertex1()), b2Math.MulX(xf, edge.GetVertex2()), color);
         }
         break;
      }
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.b2World.s_timestep2 = new b2TimeStep();
      Box2D.Dynamics.b2World.s_xf = new b2Transform();
      Box2D.Dynamics.b2World.s_backupA = new b2Sweep();
      Box2D.Dynamics.b2World.s_backupB = new b2Sweep();
      Box2D.Dynamics.b2World.s_timestep = new b2TimeStep();
      Box2D.Dynamics.b2World.s_queue = new Vector();
      Box2D.Dynamics.b2World.s_jointColor = new b2Color(0.5, 0.8, 0.8);
      Box2D.Dynamics.b2World.e_newFixture = 0x0001;
      Box2D.Dynamics.b2World.e_locked = 0x0002;
   });
})();
(function () {
   var b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
      b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
      b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
      b2MassData = Box2D.Collision.Shapes.b2MassData,
      b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
      b2Shape = Box2D.Collision.Shapes.b2Shape,
      b2CircleContact = Box2D.Dynamics.Contacts.b2CircleContact,
      b2Contact = Box2D.Dynamics.Contacts.b2Contact,
      b2ContactConstraint = Box2D.Dynamics.Contacts.b2ContactConstraint,
      b2ContactConstraintPoint = Box2D.Dynamics.Contacts.b2ContactConstraintPoint,
      b2ContactEdge = Box2D.Dynamics.Contacts.b2ContactEdge,
      b2ContactFactory = Box2D.Dynamics.Contacts.b2ContactFactory,
      b2ContactRegister = Box2D.Dynamics.Contacts.b2ContactRegister,
      b2ContactResult = Box2D.Dynamics.Contacts.b2ContactResult,
      b2ContactSolver = Box2D.Dynamics.Contacts.b2ContactSolver,
      b2EdgeAndCircleContact = Box2D.Dynamics.Contacts.b2EdgeAndCircleContact,
      b2NullContact = Box2D.Dynamics.Contacts.b2NullContact,
      b2PolyAndCircleContact = Box2D.Dynamics.Contacts.b2PolyAndCircleContact,
      b2PolyAndEdgeContact = Box2D.Dynamics.Contacts.b2PolyAndEdgeContact,
      b2PolygonContact = Box2D.Dynamics.Contacts.b2PolygonContact,
      b2PositionSolverManifold = Box2D.Dynamics.Contacts.b2PositionSolverManifold,
      b2Body = Box2D.Dynamics.b2Body,
      b2BodyDef = Box2D.Dynamics.b2BodyDef,
      b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
      b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
      b2ContactListener = Box2D.Dynamics.b2ContactListener,
      b2ContactManager = Box2D.Dynamics.b2ContactManager,
      b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
      b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
      b2FilterData = Box2D.Dynamics.b2FilterData,
      b2Fixture = Box2D.Dynamics.b2Fixture,
      b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
      b2Island = Box2D.Dynamics.b2Island,
      b2TimeStep = Box2D.Dynamics.b2TimeStep,
      b2World = Box2D.Dynamics.b2World,
      b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3,
      b2AABB = Box2D.Collision.b2AABB,
      b2Bound = Box2D.Collision.b2Bound,
      b2BoundValues = Box2D.Collision.b2BoundValues,
      b2Collision = Box2D.Collision.b2Collision,
      b2ContactID = Box2D.Collision.b2ContactID,
      b2ContactPoint = Box2D.Collision.b2ContactPoint,
      b2Distance = Box2D.Collision.b2Distance,
      b2DistanceInput = Box2D.Collision.b2DistanceInput,
      b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
      b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
      b2DynamicTree = Box2D.Collision.b2DynamicTree,
      b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
      b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
      b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
      b2Manifold = Box2D.Collision.b2Manifold,
      b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
      b2Point = Box2D.Collision.b2Point,
      b2RayCastInput = Box2D.Collision.b2RayCastInput,
      b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
      b2Segment = Box2D.Collision.b2Segment,
      b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
      b2Simplex = Box2D.Collision.b2Simplex,
      b2SimplexCache = Box2D.Collision.b2SimplexCache,
      b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
      b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
      b2TOIInput = Box2D.Collision.b2TOIInput,
      b2WorldManifold = Box2D.Collision.b2WorldManifold,
      ClipVertex = Box2D.Collision.ClipVertex,
      Features = Box2D.Collision.Features,
      IBroadPhase = Box2D.Collision.IBroadPhase;

   Box2D.inherit(b2CircleContact, Box2D.Dynamics.Contacts.b2Contact);
   b2CircleContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
   b2CircleContact.b2CircleContact = function () {
      Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
   };
   b2CircleContact.Create = function (allocator) {
      return new b2CircleContact();
   }
   b2CircleContact.Destroy = function (contact, allocator) {}
   b2CircleContact.prototype.Reset = function (fixtureA, fixtureB) {
      this.__super.Reset.call(this, fixtureA, fixtureB);
   }
   b2CircleContact.prototype.Evaluate = function () {
      var bA = this.m_fixtureA.GetBody();
      var bB = this.m_fixtureB.GetBody();
      b2Collision.CollideCircles(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2CircleShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2CircleShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
   }
   b2Contact.b2Contact = function () {
      this.m_nodeA = new b2ContactEdge();
      this.m_nodeB = new b2ContactEdge();
      this.m_manifold = new b2Manifold();
      this.m_oldManifold = new b2Manifold();
   };
   b2Contact.prototype.GetManifold = function () {
      return this.m_manifold;
   }
   b2Contact.prototype.GetWorldManifold = function (worldManifold) {
      var bodyA = this.m_fixtureA.GetBody();
      var bodyB = this.m_fixtureB.GetBody();
      var shapeA = this.m_fixtureA.GetShape();
      var shapeB = this.m_fixtureB.GetShape();
      worldManifold.Initialize(this.m_manifold, bodyA.GetTransform(), shapeA.m_radius, bodyB.GetTransform(), shapeB.m_radius);
   }
   b2Contact.prototype.IsTouching = function () {
      return (this.m_flags & b2Contact.e_touchingFlag) == b2Contact.e_touchingFlag;
   }
   b2Contact.prototype.IsContinuous = function () {
      return (this.m_flags & b2Contact.e_continuousFlag) == b2Contact.e_continuousFlag;
   }
   b2Contact.prototype.SetSensor = function (sensor) {
      if (sensor) {
         this.m_flags |= b2Contact.e_sensorFlag;
      }
      else {
         this.m_flags &= ~b2Contact.e_sensorFlag;
      }
   }
   b2Contact.prototype.IsSensor = function () {
      return (this.m_flags & b2Contact.e_sensorFlag) == b2Contact.e_sensorFlag;
   }
   b2Contact.prototype.SetEnabled = function (flag) {
      if (flag) {
         this.m_flags |= b2Contact.e_enabledFlag;
      }
      else {
         this.m_flags &= ~b2Contact.e_enabledFlag;
      }
   }
   b2Contact.prototype.IsEnabled = function () {
      return (this.m_flags & b2Contact.e_enabledFlag) == b2Contact.e_enabledFlag;
   }
   b2Contact.prototype.GetNext = function () {
      return this.m_next;
   }
   b2Contact.prototype.GetFixtureA = function () {
      return this.m_fixtureA;
   }
   b2Contact.prototype.GetFixtureB = function () {
      return this.m_fixtureB;
   }
   b2Contact.prototype.FlagForFiltering = function () {
      this.m_flags |= b2Contact.e_filterFlag;
   }
   b2Contact.prototype.b2Contact = function () {}
   b2Contact.prototype.Reset = function (fixtureA, fixtureB) {
      if (fixtureA === undefined) fixtureA = null;
      if (fixtureB === undefined) fixtureB = null;
      this.m_flags = b2Contact.e_enabledFlag;
      if (!fixtureA || !fixtureB) {
         this.m_fixtureA = null;
         this.m_fixtureB = null;
         return;
      }
      if (fixtureA.IsSensor() || fixtureB.IsSensor()) {
         this.m_flags |= b2Contact.e_sensorFlag;
      }
      var bodyA = fixtureA.GetBody();
      var bodyB = fixtureB.GetBody();
      if (bodyA.GetType() != b2Body.b2_dynamicBody || bodyA.IsBullet() || bodyB.GetType() != b2Body.b2_dynamicBody || bodyB.IsBullet()) {
         this.m_flags |= b2Contact.e_continuousFlag;
      }
      this.m_fixtureA = fixtureA;
      this.m_fixtureB = fixtureB;
      this.m_manifold.m_pointCount = 0;
      this.m_prev = null;
      this.m_next = null;
      this.m_nodeA.contact = null;
      this.m_nodeA.prev = null;
      this.m_nodeA.next = null;
      this.m_nodeA.other = null;
      this.m_nodeB.contact = null;
      this.m_nodeB.prev = null;
      this.m_nodeB.next = null;
      this.m_nodeB.other = null;
   }
   b2Contact.prototype.Update = function (listener) {
      var tManifold = this.m_oldManifold;
      this.m_oldManifold = this.m_manifold;
      this.m_manifold = tManifold;
      this.m_flags |= b2Contact.e_enabledFlag;
      var touching = false;
      var wasTouching = (this.m_flags & b2Contact.e_touchingFlag) == b2Contact.e_touchingFlag;
      var bodyA = this.m_fixtureA.m_body;
      var bodyB = this.m_fixtureB.m_body;
      var aabbOverlap = this.m_fixtureA.m_aabb.TestOverlap(this.m_fixtureB.m_aabb);
      if (this.m_flags & b2Contact.e_sensorFlag) {
         if (aabbOverlap) {
            var shapeA = this.m_fixtureA.GetShape();
            var shapeB = this.m_fixtureB.GetShape();
            var xfA = bodyA.GetTransform();
            var xfB = bodyB.GetTransform();
            touching = b2Shape.TestOverlap(shapeA, xfA, shapeB, xfB);
         }
         this.m_manifold.m_pointCount = 0;
      }
      else {
         if (bodyA.GetType() != b2Body.b2_dynamicBody || bodyA.IsBullet() || bodyB.GetType() != b2Body.b2_dynamicBody || bodyB.IsBullet()) {
            this.m_flags |= b2Contact.e_continuousFlag;
         }
         else {
            this.m_flags &= ~b2Contact.e_continuousFlag;
         }
         if (aabbOverlap) {
            this.Evaluate();
            touching = this.m_manifold.m_pointCount > 0;
            for (var i = 0; i < this.m_manifold.m_pointCount; ++i) {
               var mp2 = this.m_manifold.m_points[i];
               mp2.m_normalImpulse = 0.0;
               mp2.m_tangentImpulse = 0.0;
               var id2 = mp2.m_id;
               for (var j = 0; j < this.m_oldManifold.m_pointCount; ++j) {
                  var mp1 = this.m_oldManifold.m_points[j];
                  if (mp1.m_id.key == id2.key) {
                     mp2.m_normalImpulse = mp1.m_normalImpulse;
                     mp2.m_tangentImpulse = mp1.m_tangentImpulse;
                     break;
                  }
               }
            }
         }
         else {
            this.m_manifold.m_pointCount = 0;
         }
         if (touching != wasTouching) {
            bodyA.SetAwake(true);
            bodyB.SetAwake(true);
         }
      }
      if (touching) {
         this.m_flags |= b2Contact.e_touchingFlag;
      }
      else {
         this.m_flags &= ~b2Contact.e_touchingFlag;
      }
      if (wasTouching == false && touching == true) {
         listener.BeginContact(this);
      }
      if (wasTouching == true && touching == false) {
         listener.EndContact(this);
      }
      if ((this.m_flags & b2Contact.e_sensorFlag) == 0) {
         listener.PreSolve(this, this.m_oldManifold);
      }
   }
   b2Contact.prototype.Evaluate = function () {}
   b2Contact.prototype.ComputeTOI = function (sweepA, sweepB) {
      b2Contact.s_input.proxyA.Set(this.m_fixtureA.GetShape());
      b2Contact.s_input.proxyB.Set(this.m_fixtureB.GetShape());
      b2Contact.s_input.sweepA = sweepA;
      b2Contact.s_input.sweepB = sweepB;
      b2Contact.s_input.tolerance = b2Settings.b2_linearSlop;
      return b2TimeOfImpact.TimeOfImpact(b2Contact.s_input);
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.Contacts.b2Contact.e_sensorFlag = 0x0001;
      Box2D.Dynamics.Contacts.b2Contact.e_continuousFlag = 0x0002;
      Box2D.Dynamics.Contacts.b2Contact.e_islandFlag = 0x0004;
      Box2D.Dynamics.Contacts.b2Contact.e_toiFlag = 0x0008;
      Box2D.Dynamics.Contacts.b2Contact.e_touchingFlag = 0x0010;
      Box2D.Dynamics.Contacts.b2Contact.e_enabledFlag = 0x0020;
      Box2D.Dynamics.Contacts.b2Contact.e_filterFlag = 0x0040;
      Box2D.Dynamics.Contacts.b2Contact.s_input = new b2TOIInput();
   });
   b2ContactConstraint.b2ContactConstraint = function () {
      this.localPlaneNormal = new b2Vec2();
      this.localPoint = new b2Vec2();
      this.normal = new b2Vec2();
      this.normalMass = new b2Mat22();
      this.K = new b2Mat22();
   };
   b2ContactConstraint.prototype.b2ContactConstraint = function () {
      this.points = new Vector(b2Settings.b2_maxManifoldPoints);
      for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
         this.points[i] = new b2ContactConstraintPoint();
      }
   }
   b2ContactConstraintPoint.b2ContactConstraintPoint = function () {
      this.localPoint = new b2Vec2();
      this.rA = new b2Vec2();
      this.rB = new b2Vec2();
   };
   b2ContactEdge.b2ContactEdge = function () {};
   b2ContactFactory.b2ContactFactory = function () {};
   b2ContactFactory.prototype.b2ContactFactory = function (allocator) {
      this.m_allocator = allocator;
      this.InitializeRegisters();
   }
   b2ContactFactory.prototype.AddType = function (createFcn, destroyFcn, type1, type2) {
      if (type1 === undefined) type1 = 0;
      if (type2 === undefined) type2 = 0;
      this.m_registers[type1][type2].createFcn = createFcn;
      this.m_registers[type1][type2].destroyFcn = destroyFcn;
      this.m_registers[type1][type2].primary = true;
      if (type1 != type2) {
         this.m_registers[type2][type1].createFcn = createFcn;
         this.m_registers[type2][type1].destroyFcn = destroyFcn;
         this.m_registers[type2][type1].primary = false;
      }
   }
   b2ContactFactory.prototype.InitializeRegisters = function () {
      this.m_registers = new Vector(b2Shape.e_shapeTypeCount);
      for (var i = 0; i < b2Shape.e_shapeTypeCount; i++) {
         this.m_registers[i] = new Vector(b2Shape.e_shapeTypeCount);
         for (var j = 0; j < b2Shape.e_shapeTypeCount; j++) {
            this.m_registers[i][j] = new b2ContactRegister();
         }
      }
      this.AddType(b2CircleContact.Create, b2CircleContact.Destroy, b2Shape.e_circleShape, b2Shape.e_circleShape);
      this.AddType(b2PolyAndCircleContact.Create, b2PolyAndCircleContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_circleShape);
      this.AddType(b2PolygonContact.Create, b2PolygonContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_polygonShape);
      this.AddType(b2EdgeAndCircleContact.Create, b2EdgeAndCircleContact.Destroy, b2Shape.e_edgeShape, b2Shape.e_circleShape);
      this.AddType(b2PolyAndEdgeContact.Create, b2PolyAndEdgeContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_edgeShape);
   }
   b2ContactFactory.prototype.Create = function (fixtureA, fixtureB) {
      var type1 = parseInt(fixtureA.GetType());
      var type2 = parseInt(fixtureB.GetType());
      var reg = this.m_registers[type1][type2];
      var c;
      if (reg.pool) {
         c = reg.pool;
         reg.pool = c.m_next;
         reg.poolCount--;
         c.Reset(fixtureA, fixtureB);
         return c;
      }
      var createFcn = reg.createFcn;
      if (createFcn != null) {
         if (reg.primary) {
            c = createFcn(this.m_allocator);
            c.Reset(fixtureA, fixtureB);
            return c;
         }
         else {
            c = createFcn(this.m_allocator);
            c.Reset(fixtureB, fixtureA);
            return c;
         }
      }
      else {
         return null;
      }
   }
   b2ContactFactory.prototype.Destroy = function (contact) {
      if (contact.m_manifold.m_pointCount > 0) {
         contact.m_fixtureA.m_body.SetAwake(true);
         contact.m_fixtureB.m_body.SetAwake(true);
      }
      var type1 = parseInt(contact.m_fixtureA.GetType());
      var type2 = parseInt(contact.m_fixtureB.GetType());
      var reg = this.m_registers[type1][type2];
      if (true) {
         reg.poolCount++;
         contact.m_next = reg.pool;
         reg.pool = contact;
      }
      var destroyFcn = reg.destroyFcn;
      destroyFcn(contact, this.m_allocator);
   }
   b2ContactRegister.b2ContactRegister = function () {};
   b2ContactResult.b2ContactResult = function () {
      this.position = new b2Vec2();
      this.normal = new b2Vec2();
      this.id = new b2ContactID();
   };
   b2ContactSolver.b2ContactSolver = function () {
      this.m_step = new b2TimeStep();
      this.m_constraints = new Vector();
   };
   b2ContactSolver.prototype.b2ContactSolver = function () {}
   b2ContactSolver.prototype.Initialize = function (step, contacts, contactCount, allocator) {
      if (contactCount === undefined) contactCount = 0;
      var contact;
      this.m_step.Set(step);
      this.m_allocator = allocator;
      var i = 0;
      var tVec;
      var tMat;
      this.m_constraintCount = contactCount;
      while (this.m_constraints.length < this.m_constraintCount) {
         this.m_constraints[this.m_constraints.length] = new b2ContactConstraint();
      }
      for (i = 0;
      i < contactCount; ++i) {
         contact = contacts[i];
         var fixtureA = contact.m_fixtureA;
         var fixtureB = contact.m_fixtureB;
         var shapeA = fixtureA.m_shape;
         var shapeB = fixtureB.m_shape;
         var radiusA = shapeA.m_radius;
         var radiusB = shapeB.m_radius;
         var bodyA = fixtureA.m_body;
         var bodyB = fixtureB.m_body;
         var manifold = contact.GetManifold();
         var friction = b2Settings.b2MixFriction(fixtureA.GetFriction(), fixtureB.GetFriction());
         var restitution = b2Settings.b2MixRestitution(fixtureA.GetRestitution(), fixtureB.GetRestitution());
         var vAX = bodyA.m_linearVelocity.x;
         var vAY = bodyA.m_linearVelocity.y;
         var vBX = bodyB.m_linearVelocity.x;
         var vBY = bodyB.m_linearVelocity.y;
         var wA = bodyA.m_angularVelocity;
         var wB = bodyB.m_angularVelocity;
         b2Settings.b2Assert(manifold.m_pointCount > 0);
         b2ContactSolver.s_worldManifold.Initialize(manifold, bodyA.m_xf, radiusA, bodyB.m_xf, radiusB);
         var normalX = b2ContactSolver.s_worldManifold.m_normal.x;
         var normalY = b2ContactSolver.s_worldManifold.m_normal.y;
         var cc = this.m_constraints[i];
         cc.bodyA = bodyA;
         cc.bodyB = bodyB;
         cc.manifold = manifold;
         cc.normal.x = normalX;
         cc.normal.y = normalY;
         cc.pointCount = manifold.m_pointCount;
         cc.friction = friction;
         cc.restitution = restitution;
         cc.localPlaneNormal.x = manifold.m_localPlaneNormal.x;
         cc.localPlaneNormal.y = manifold.m_localPlaneNormal.y;
         cc.localPoint.x = manifold.m_localPoint.x;
         cc.localPoint.y = manifold.m_localPoint.y;
         cc.radius = radiusA + radiusB;
         cc.type = manifold.m_type;
         for (var k = 0; k < cc.pointCount; ++k) {
            var cp = manifold.m_points[k];
            var ccp = cc.points[k];
            ccp.normalImpulse = cp.m_normalImpulse;
            ccp.tangentImpulse = cp.m_tangentImpulse;
            ccp.localPoint.SetV(cp.m_localPoint);
            var rAX = ccp.rA.x = b2ContactSolver.s_worldManifold.m_points[k].x - bodyA.m_sweep.c.x;
            var rAY = ccp.rA.y = b2ContactSolver.s_worldManifold.m_points[k].y - bodyA.m_sweep.c.y;
            var rBX = ccp.rB.x = b2ContactSolver.s_worldManifold.m_points[k].x - bodyB.m_sweep.c.x;
            var rBY = ccp.rB.y = b2ContactSolver.s_worldManifold.m_points[k].y - bodyB.m_sweep.c.y;
            var rnA = rAX * normalY - rAY * normalX;
            var rnB = rBX * normalY - rBY * normalX;
            rnA *= rnA;
            rnB *= rnB;
            var kNormal = bodyA.m_invMass + bodyB.m_invMass + bodyA.m_invI * rnA + bodyB.m_invI * rnB;
            ccp.normalMass = 1.0 / kNormal;
            var kEqualized = bodyA.m_mass * bodyA.m_invMass + bodyB.m_mass * bodyB.m_invMass;
            kEqualized += bodyA.m_mass * bodyA.m_invI * rnA + bodyB.m_mass * bodyB.m_invI * rnB;
            ccp.equalizedMass = 1.0 / kEqualized;
            var tangentX = normalY;
            var tangentY = (-normalX);
            var rtA = rAX * tangentY - rAY * tangentX;
            var rtB = rBX * tangentY - rBY * tangentX;
            rtA *= rtA;
            rtB *= rtB;
            var kTangent = bodyA.m_invMass + bodyB.m_invMass + bodyA.m_invI * rtA + bodyB.m_invI * rtB;
            ccp.tangentMass = 1.0 / kTangent;
            ccp.velocityBias = 0.0;
            var tX = vBX + ((-wB * rBY)) - vAX - ((-wA * rAY));
            var tY = vBY + (wB * rBX) - vAY - (wA * rAX);
            var vRel = cc.normal.x * tX + cc.normal.y * tY;
            if (vRel < (-b2Settings.b2_velocityThreshold)) {
               ccp.velocityBias += (-cc.restitution * vRel);
            }
         }
         if (cc.pointCount == 2) {
            var ccp1 = cc.points[0];
            var ccp2 = cc.points[1];
            var invMassA = bodyA.m_invMass;
            var invIA = bodyA.m_invI;
            var invMassB = bodyB.m_invMass;
            var invIB = bodyB.m_invI;
            var rn1A = ccp1.rA.x * normalY - ccp1.rA.y * normalX;
            var rn1B = ccp1.rB.x * normalY - ccp1.rB.y * normalX;
            var rn2A = ccp2.rA.x * normalY - ccp2.rA.y * normalX;
            var rn2B = ccp2.rB.x * normalY - ccp2.rB.y * normalX;
            var k11 = invMassA + invMassB + invIA * rn1A * rn1A + invIB * rn1B * rn1B;
            var k22 = invMassA + invMassB + invIA * rn2A * rn2A + invIB * rn2B * rn2B;
            var k12 = invMassA + invMassB + invIA * rn1A * rn2A + invIB * rn1B * rn2B;
            var k_maxConditionNumber = 100.0;
            if (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12)) {
               cc.K.col1.Set(k11, k12);
               cc.K.col2.Set(k12, k22);
               cc.K.GetInverse(cc.normalMass);
            }
            else {
               cc.pointCount = 1;
            }
         }
      }
   }
   b2ContactSolver.prototype.InitVelocityConstraints = function (step) {
      var tVec;
      var tVec2;
      var tMat;
      for (var i = 0; i < this.m_constraintCount; ++i) {
         var c = this.m_constraints[i];
         var bodyA = c.bodyA;
         var bodyB = c.bodyB;
         var invMassA = bodyA.m_invMass;
         var invIA = bodyA.m_invI;
         var invMassB = bodyB.m_invMass;
         var invIB = bodyB.m_invI;
         var normalX = c.normal.x;
         var normalY = c.normal.y;
         var tangentX = normalY;
         var tangentY = (-normalX);
         var tX = 0;
         var j = 0;
         var tCount = 0;
         if (step.warmStarting) {
            tCount = c.pointCount;
            for (j = 0;
            j < tCount; ++j) {
               var ccp = c.points[j];
               ccp.normalImpulse *= step.dtRatio;
               ccp.tangentImpulse *= step.dtRatio;
               var PX = ccp.normalImpulse * normalX + ccp.tangentImpulse * tangentX;
               var PY = ccp.normalImpulse * normalY + ccp.tangentImpulse * tangentY;
               bodyA.m_angularVelocity -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
               bodyA.m_linearVelocity.x -= invMassA * PX;
               bodyA.m_linearVelocity.y -= invMassA * PY;
               bodyB.m_angularVelocity += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
               bodyB.m_linearVelocity.x += invMassB * PX;
               bodyB.m_linearVelocity.y += invMassB * PY;
            }
         }
         else {
            tCount = c.pointCount;
            for (j = 0;
            j < tCount; ++j) {
               var ccp2 = c.points[j];
               ccp2.normalImpulse = 0.0;
               ccp2.tangentImpulse = 0.0;
            }
         }
      }
   }
   b2ContactSolver.prototype.SolveVelocityConstraints = function () {
      var j = 0;
      var ccp;
      var rAX = 0;
      var rAY = 0;
      var rBX = 0;
      var rBY = 0;
      var dvX = 0;
      var dvY = 0;
      var vn = 0;
      var vt = 0;
      var lambda = 0;
      var maxFriction = 0;
      var newImpulse = 0;
      var PX = 0;
      var PY = 0;
      var dX = 0;
      var dY = 0;
      var P1X = 0;
      var P1Y = 0;
      var P2X = 0;
      var P2Y = 0;
      var tMat;
      var tVec;
      for (var i = 0; i < this.m_constraintCount; ++i) {
         var c = this.m_constraints[i];
         var bodyA = c.bodyA;
         var bodyB = c.bodyB;
         var wA = bodyA.m_angularVelocity;
         var wB = bodyB.m_angularVelocity;
         var vA = bodyA.m_linearVelocity;
         var vB = bodyB.m_linearVelocity;
         var invMassA = bodyA.m_invMass;
         var invIA = bodyA.m_invI;
         var invMassB = bodyB.m_invMass;
         var invIB = bodyB.m_invI;
         var normalX = c.normal.x;
         var normalY = c.normal.y;
         var tangentX = normalY;
         var tangentY = (-normalX);
         var friction = c.friction;
         var tX = 0;
         for (j = 0;
         j < c.pointCount; j++) {
            ccp = c.points[j];
            dvX = vB.x - wB * ccp.rB.y - vA.x + wA * ccp.rA.y;
            dvY = vB.y + wB * ccp.rB.x - vA.y - wA * ccp.rA.x;
            vt = dvX * tangentX + dvY * tangentY;
            lambda = ccp.tangentMass * (-vt);
            maxFriction = friction * ccp.normalImpulse;
            newImpulse = b2Math.Clamp(ccp.tangentImpulse + lambda, (-maxFriction), maxFriction);
            lambda = newImpulse - ccp.tangentImpulse;
            PX = lambda * tangentX;
            PY = lambda * tangentY;
            vA.x -= invMassA * PX;
            vA.y -= invMassA * PY;
            wA -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
            vB.x += invMassB * PX;
            vB.y += invMassB * PY;
            wB += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
            ccp.tangentImpulse = newImpulse;
         }
         var tCount = parseInt(c.pointCount);
         if (c.pointCount == 1) {
            ccp = c.points[0];
            dvX = vB.x + ((-wB * ccp.rB.y)) - vA.x - ((-wA * ccp.rA.y));
            dvY = vB.y + (wB * ccp.rB.x) - vA.y - (wA * ccp.rA.x);
            vn = dvX * normalX + dvY * normalY;
            lambda = (-ccp.normalMass * (vn - ccp.velocityBias));
            newImpulse = ccp.normalImpulse + lambda;
            newImpulse = newImpulse > 0 ? newImpulse : 0.0;
            lambda = newImpulse - ccp.normalImpulse;
            PX = lambda * normalX;
            PY = lambda * normalY;
            vA.x -= invMassA * PX;
            vA.y -= invMassA * PY;
            wA -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
            vB.x += invMassB * PX;
            vB.y += invMassB * PY;
            wB += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
            ccp.normalImpulse = newImpulse;
         }
         else {
            var cp1 = c.points[0];
            var cp2 = c.points[1];
            var aX = cp1.normalImpulse;
            var aY = cp2.normalImpulse;
            var dv1X = vB.x - wB * cp1.rB.y - vA.x + wA * cp1.rA.y;
            var dv1Y = vB.y + wB * cp1.rB.x - vA.y - wA * cp1.rA.x;
            var dv2X = vB.x - wB * cp2.rB.y - vA.x + wA * cp2.rA.y;
            var dv2Y = vB.y + wB * cp2.rB.x - vA.y - wA * cp2.rA.x;
            var vn1 = dv1X * normalX + dv1Y * normalY;
            var vn2 = dv2X * normalX + dv2Y * normalY;
            var bX = vn1 - cp1.velocityBias;
            var bY = vn2 - cp2.velocityBias;
            tMat = c.K;
            bX -= tMat.col1.x * aX + tMat.col2.x * aY;
            bY -= tMat.col1.y * aX + tMat.col2.y * aY;
            var k_errorTol = 0.001;
            for (;;) {
               tMat = c.normalMass;
               var xX = (-(tMat.col1.x * bX + tMat.col2.x * bY));
               var xY = (-(tMat.col1.y * bX + tMat.col2.y * bY));
               if (xX >= 0.0 && xY >= 0.0) {
                  dX = xX - aX;
                  dY = xY - aY;
                  P1X = dX * normalX;
                  P1Y = dX * normalY;
                  P2X = dY * normalX;
                  P2Y = dY * normalY;
                  vA.x -= invMassA * (P1X + P2X);
                  vA.y -= invMassA * (P1Y + P2Y);
                  wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
                  vB.x += invMassB * (P1X + P2X);
                  vB.y += invMassB * (P1Y + P2Y);
                  wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
                  cp1.normalImpulse = xX;
                  cp2.normalImpulse = xY;
                  break;
               }
               xX = (-cp1.normalMass * bX);
               xY = 0.0;
               vn1 = 0.0;
               vn2 = c.K.col1.y * xX + bY;
               if (xX >= 0.0 && vn2 >= 0.0) {
                  dX = xX - aX;
                  dY = xY - aY;
                  P1X = dX * normalX;
                  P1Y = dX * normalY;
                  P2X = dY * normalX;
                  P2Y = dY * normalY;
                  vA.x -= invMassA * (P1X + P2X);
                  vA.y -= invMassA * (P1Y + P2Y);
                  wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
                  vB.x += invMassB * (P1X + P2X);
                  vB.y += invMassB * (P1Y + P2Y);
                  wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
                  cp1.normalImpulse = xX;
                  cp2.normalImpulse = xY;
                  break;
               }
               xX = 0.0;
               xY = (-cp2.normalMass * bY);
               vn1 = c.K.col2.x * xY + bX;
               vn2 = 0.0;
               if (xY >= 0.0 && vn1 >= 0.0) {
                  dX = xX - aX;
                  dY = xY - aY;
                  P1X = dX * normalX;
                  P1Y = dX * normalY;
                  P2X = dY * normalX;
                  P2Y = dY * normalY;
                  vA.x -= invMassA * (P1X + P2X);
                  vA.y -= invMassA * (P1Y + P2Y);
                  wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
                  vB.x += invMassB * (P1X + P2X);
                  vB.y += invMassB * (P1Y + P2Y);
                  wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
                  cp1.normalImpulse = xX;
                  cp2.normalImpulse = xY;
                  break;
               }
               xX = 0.0;
               xY = 0.0;
               vn1 = bX;
               vn2 = bY;
               if (vn1 >= 0.0 && vn2 >= 0.0) {
                  dX = xX - aX;
                  dY = xY - aY;
                  P1X = dX * normalX;
                  P1Y = dX * normalY;
                  P2X = dY * normalX;
                  P2Y = dY * normalY;
                  vA.x -= invMassA * (P1X + P2X);
                  vA.y -= invMassA * (P1Y + P2Y);
                  wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
                  vB.x += invMassB * (P1X + P2X);
                  vB.y += invMassB * (P1Y + P2Y);
                  wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
                  cp1.normalImpulse = xX;
                  cp2.normalImpulse = xY;
                  break;
               }
               break;
            }
         }
         bodyA.m_angularVelocity = wA;
         bodyB.m_angularVelocity = wB;
      }
   }
   b2ContactSolver.prototype.FinalizeVelocityConstraints = function () {
      for (var i = 0; i < this.m_constraintCount; ++i) {
         var c = this.m_constraints[i];
         var m = c.manifold;
         for (var j = 0; j < c.pointCount; ++j) {
            var point1 = m.m_points[j];
            var point2 = c.points[j];
            point1.m_normalImpulse = point2.normalImpulse;
            point1.m_tangentImpulse = point2.tangentImpulse;
         }
      }
   }
   b2ContactSolver.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var minSeparation = 0.0;
      for (var i = 0; i < this.m_constraintCount; i++) {
         var c = this.m_constraints[i];
         var bodyA = c.bodyA;
         var bodyB = c.bodyB;
         var invMassA = bodyA.m_mass * bodyA.m_invMass;
         var invIA = bodyA.m_mass * bodyA.m_invI;
         var invMassB = bodyB.m_mass * bodyB.m_invMass;
         var invIB = bodyB.m_mass * bodyB.m_invI;
         b2ContactSolver.s_psm.Initialize(c);
         var normal = b2ContactSolver.s_psm.m_normal;
         for (var j = 0; j < c.pointCount; j++) {
            var ccp = c.points[j];
            var point = b2ContactSolver.s_psm.m_points[j];
            var separation = b2ContactSolver.s_psm.m_separations[j];
            var rAX = point.x - bodyA.m_sweep.c.x;
            var rAY = point.y - bodyA.m_sweep.c.y;
            var rBX = point.x - bodyB.m_sweep.c.x;
            var rBY = point.y - bodyB.m_sweep.c.y;
            minSeparation = minSeparation < separation ? minSeparation : separation;
            var C = b2Math.Clamp(baumgarte * (separation + b2Settings.b2_linearSlop), (-b2Settings.b2_maxLinearCorrection), 0.0);
            var impulse = (-ccp.equalizedMass * C);
            var PX = impulse * normal.x;
            var PY = impulse * normal.y;bodyA.m_sweep.c.x -= invMassA * PX;
            bodyA.m_sweep.c.y -= invMassA * PY;
            bodyA.m_sweep.a -= invIA * (rAX * PY - rAY * PX);
            bodyA.SynchronizeTransform();
            bodyB.m_sweep.c.x += invMassB * PX;
            bodyB.m_sweep.c.y += invMassB * PY;
            bodyB.m_sweep.a += invIB * (rBX * PY - rBY * PX);
            bodyB.SynchronizeTransform();
         }
      }
      return minSeparation > (-1.5 * b2Settings.b2_linearSlop);
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.Contacts.b2ContactSolver.s_worldManifold = new b2WorldManifold();
      Box2D.Dynamics.Contacts.b2ContactSolver.s_psm = new b2PositionSolverManifold();
   });
   Box2D.inherit(b2EdgeAndCircleContact, Box2D.Dynamics.Contacts.b2Contact);
   b2EdgeAndCircleContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
   b2EdgeAndCircleContact.b2EdgeAndCircleContact = function () {
      Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
   };
   b2EdgeAndCircleContact.Create = function (allocator) {
      return new b2EdgeAndCircleContact();
   }
   b2EdgeAndCircleContact.Destroy = function (contact, allocator) {}
   b2EdgeAndCircleContact.prototype.Reset = function (fixtureA, fixtureB) {
      this.__super.Reset.call(this, fixtureA, fixtureB);
   }
   b2EdgeAndCircleContact.prototype.Evaluate = function () {
      var bA = this.m_fixtureA.GetBody();
      var bB = this.m_fixtureB.GetBody();
      this.b2CollideEdgeAndCircle(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2EdgeShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2CircleShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
   }
   b2EdgeAndCircleContact.prototype.b2CollideEdgeAndCircle = function (manifold, edge, xf1, circle, xf2) {}
   Box2D.inherit(b2NullContact, Box2D.Dynamics.Contacts.b2Contact);
   b2NullContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
   b2NullContact.b2NullContact = function () {
      Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
   };
   b2NullContact.prototype.b2NullContact = function () {
      this.__super.b2Contact.call(this);
   }
   b2NullContact.prototype.Evaluate = function () {}
   Box2D.inherit(b2PolyAndCircleContact, Box2D.Dynamics.Contacts.b2Contact);
   b2PolyAndCircleContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
   b2PolyAndCircleContact.b2PolyAndCircleContact = function () {
      Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
   };
   b2PolyAndCircleContact.Create = function (allocator) {
      return new b2PolyAndCircleContact();
   }
   b2PolyAndCircleContact.Destroy = function (contact, allocator) {}
   b2PolyAndCircleContact.prototype.Reset = function (fixtureA, fixtureB) {
      this.__super.Reset.call(this, fixtureA, fixtureB);
      b2Settings.b2Assert(fixtureA.GetType() == b2Shape.e_polygonShape);
      b2Settings.b2Assert(fixtureB.GetType() == b2Shape.e_circleShape);
   }
   b2PolyAndCircleContact.prototype.Evaluate = function () {
      var bA = this.m_fixtureA.m_body;
      var bB = this.m_fixtureB.m_body;
      b2Collision.CollidePolygonAndCircle(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2PolygonShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2CircleShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
   }
   Box2D.inherit(b2PolyAndEdgeContact, Box2D.Dynamics.Contacts.b2Contact);
   b2PolyAndEdgeContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
   b2PolyAndEdgeContact.b2PolyAndEdgeContact = function () {
      Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
   };
   b2PolyAndEdgeContact.Create = function (allocator) {
      return new b2PolyAndEdgeContact();
   }
   b2PolyAndEdgeContact.Destroy = function (contact, allocator) {}
   b2PolyAndEdgeContact.prototype.Reset = function (fixtureA, fixtureB) {
      this.__super.Reset.call(this, fixtureA, fixtureB);
      b2Settings.b2Assert(fixtureA.GetType() == b2Shape.e_polygonShape);
      b2Settings.b2Assert(fixtureB.GetType() == b2Shape.e_edgeShape);
   }
   b2PolyAndEdgeContact.prototype.Evaluate = function () {
      var bA = this.m_fixtureA.GetBody();
      var bB = this.m_fixtureB.GetBody();
      this.b2CollidePolyAndEdge(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2PolygonShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2EdgeShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
   }
   b2PolyAndEdgeContact.prototype.b2CollidePolyAndEdge = function (manifold, polygon, xf1, edge, xf2) {}
   Box2D.inherit(b2PolygonContact, Box2D.Dynamics.Contacts.b2Contact);
   b2PolygonContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
   b2PolygonContact.b2PolygonContact = function () {
      Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
   };
   b2PolygonContact.Create = function (allocator) {
      return new b2PolygonContact();
   }
   b2PolygonContact.Destroy = function (contact, allocator) {}
   b2PolygonContact.prototype.Reset = function (fixtureA, fixtureB) {
      this.__super.Reset.call(this, fixtureA, fixtureB);
   }
   b2PolygonContact.prototype.Evaluate = function () {
      var bA = this.m_fixtureA.GetBody();
      var bB = this.m_fixtureB.GetBody();
      b2Collision.CollidePolygons(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2PolygonShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2PolygonShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
   }
   b2PositionSolverManifold.b2PositionSolverManifold = function () {};
   b2PositionSolverManifold.prototype.b2PositionSolverManifold = function () {
      this.m_normal = new b2Vec2();
      this.m_separations = new Vector_a2j_Number(b2Settings.b2_maxManifoldPoints);
      this.m_points = new Vector(b2Settings.b2_maxManifoldPoints);
      for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
         this.m_points[i] = new b2Vec2();
      }
   }
   b2PositionSolverManifold.prototype.Initialize = function (cc) {
      b2Settings.b2Assert(cc.pointCount > 0);
      var i = 0;
      var clipPointX = 0;
      var clipPointY = 0;
      var tMat;
      var tVec;
      var planePointX = 0;
      var planePointY = 0;
      switch (cc.type) {
      case b2Manifold.e_circles:
         {
            tMat = cc.bodyA.m_xf.R;
            tVec = cc.localPoint;
            var pointAX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            var pointAY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            tMat = cc.bodyB.m_xf.R;
            tVec = cc.points[0].localPoint;
            var pointBX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            var pointBY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            var dX = pointBX - pointAX;
            var dY = pointBY - pointAY;
            var d2 = dX * dX + dY * dY;
            if (d2 > FLOAT_EPSILON * FLOAT_EPSILON) {
               var d = Math.sqrt(d2);
               this.m_normal.x = dX / d;
               this.m_normal.y = dY / d;
            }
            else {
               this.m_normal.x = 1.0;
               this.m_normal.y = 0.0;
            }
            this.m_points[0].x = 0.5 * (pointAX + pointBX);
            this.m_points[0].y = 0.5 * (pointAY + pointBY);
            this.m_separations[0] = dX * this.m_normal.x + dY * this.m_normal.y - cc.radius;
         }
         break;
      case b2Manifold.e_faceA:
         {
            tMat = cc.bodyA.m_xf.R;
            tVec = cc.localPlaneNormal;
            this.m_normal.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            this.m_normal.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tMat = cc.bodyA.m_xf.R;
            tVec = cc.localPoint;
            planePointX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            planePointY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            tMat = cc.bodyB.m_xf.R;
            for (i = 0;
            i < cc.pointCount; ++i) {
               tVec = cc.points[i].localPoint;
               clipPointX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
               clipPointY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
               this.m_separations[i] = (clipPointX - planePointX) * this.m_normal.x + (clipPointY - planePointY) * this.m_normal.y - cc.radius;
               this.m_points[i].x = clipPointX;
               this.m_points[i].y = clipPointY;
            }
         }
         break;
      case b2Manifold.e_faceB:
         {
            tMat = cc.bodyB.m_xf.R;
            tVec = cc.localPlaneNormal;
            this.m_normal.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            this.m_normal.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tMat = cc.bodyB.m_xf.R;
            tVec = cc.localPoint;
            planePointX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            planePointY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            tMat = cc.bodyA.m_xf.R;
            for (i = 0;
            i < cc.pointCount; ++i) {
               tVec = cc.points[i].localPoint;
               clipPointX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
               clipPointY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
               this.m_separations[i] = (clipPointX - planePointX) * this.m_normal.x + (clipPointY - planePointY) * this.m_normal.y - cc.radius;
               this.m_points[i].Set(clipPointX, clipPointY);
            }
            this.m_normal.x *= (-1);
            this.m_normal.y *= (-1);
         }
         break;
      }
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.Contacts.b2PositionSolverManifold.circlePointA = new b2Vec2();
      Box2D.Dynamics.Contacts.b2PositionSolverManifold.circlePointB = new b2Vec2();
   });
})();
(function () {
   var b2Body = Box2D.Dynamics.b2Body,
      b2BodyDef = Box2D.Dynamics.b2BodyDef,
      b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
      b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
      b2ContactListener = Box2D.Dynamics.b2ContactListener,
      b2ContactManager = Box2D.Dynamics.b2ContactManager,
      b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
      b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
      b2FilterData = Box2D.Dynamics.b2FilterData,
      b2Fixture = Box2D.Dynamics.b2Fixture,
      b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
      b2Island = Box2D.Dynamics.b2Island,
      b2TimeStep = Box2D.Dynamics.b2TimeStep,
      b2World = Box2D.Dynamics.b2World,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3,
      b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
      b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
      b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
      b2MassData = Box2D.Collision.Shapes.b2MassData,
      b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
      b2Shape = Box2D.Collision.Shapes.b2Shape,
      b2BuoyancyController = Box2D.Dynamics.Controllers.b2BuoyancyController,
      b2ConstantAccelController = Box2D.Dynamics.Controllers.b2ConstantAccelController,
      b2ConstantForceController = Box2D.Dynamics.Controllers.b2ConstantForceController,
      b2Controller = Box2D.Dynamics.Controllers.b2Controller,
      b2ControllerEdge = Box2D.Dynamics.Controllers.b2ControllerEdge,
      b2GravityController = Box2D.Dynamics.Controllers.b2GravityController,
      b2TensorDampingController = Box2D.Dynamics.Controllers.b2TensorDampingController;

   Box2D.inherit(b2BuoyancyController, Box2D.Dynamics.Controllers.b2Controller);
   b2BuoyancyController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
   b2BuoyancyController.b2BuoyancyController = function () {
      Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
      this.normal = new b2Vec2(0, (-1));
      this.offset = 0;
      this.density = 0;
      this.velocity = new b2Vec2(0, 0);
      this.linearDrag = 2;
      this.angularDrag = 1;
      this.useDensity = false;
      this.useWorldGravity = true;
      this.gravity = null;
   };
   b2BuoyancyController.prototype.Step = function (step) {
      if (!this.m_bodyList) return;
      if (this.useWorldGravity) {
         this.gravity = this.GetWorld().GetGravity().Copy();
      }
      for (var i = this.m_bodyList; i; i = i.nextBody) {
         var body = i.body;
         if (body.IsAwake() == false) {
            continue;
         }
         var areac = new b2Vec2();
         var massc = new b2Vec2();
         var area = 0.0;
         var mass = 0.0;
         for (var fixture = body.GetFixtureList(); fixture; fixture = fixture.GetNext()) {
            var sc = new b2Vec2();
            var sarea = fixture.GetShape().ComputeSubmergedArea(this.normal, this.offset, body.GetTransform(), sc);
            area += sarea;
            areac.x += sarea * sc.x;
            areac.y += sarea * sc.y;
            var shapeDensity = 0;
            if (this.useDensity) {
               shapeDensity = 1;
            }
            else {
               shapeDensity = 1;
            }
            mass += sarea * shapeDensity;
            massc.x += sarea * sc.x * shapeDensity;
            massc.y += sarea * sc.y * shapeDensity;
         }
         areac.x /= area;
         areac.y /= area;
         massc.x /= mass;
         massc.y /= mass;
         if (area < FLOAT_EPSILON) continue;
         var buoyancyForce = this.gravity.GetNegative();
         buoyancyForce.Multiply(this.density * area);
         body.ApplyForce(buoyancyForce, massc);
         var dragForce = body.GetLinearVelocityFromWorldPoint(areac);
         dragForce.Subtract(this.velocity);
         dragForce.Multiply((-this.linearDrag * area));
         body.ApplyForce(dragForce, areac);
         body.ApplyTorque((-body.GetInertia() / body.GetMass() * area * body.GetAngularVelocity() * this.angularDrag));
      }
   }
   b2BuoyancyController.prototype.Draw = function (debugDraw) {
      var r = 1000;
      var p1 = new b2Vec2();
      var p2 = new b2Vec2();
      p1.x = this.normal.x * this.offset + this.normal.y * r;
      p1.y = this.normal.y * this.offset - this.normal.x * r;
      p2.x = this.normal.x * this.offset - this.normal.y * r;
      p2.y = this.normal.y * this.offset + this.normal.x * r;
      var color = new b2Color(0, 0, 1);
      debugDraw.DrawSegment(p1, p2, color);
   }
   Box2D.inherit(b2ConstantAccelController, Box2D.Dynamics.Controllers.b2Controller);
   b2ConstantAccelController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
   b2ConstantAccelController.b2ConstantAccelController = function () {
      Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
      this.A = new b2Vec2(0, 0);
   };
   b2ConstantAccelController.prototype.Step = function (step) {
      var smallA = new b2Vec2(this.A.x * step.dt, this.A.y * step.dt);
      for (var i = this.m_bodyList; i; i = i.nextBody) {
         var body = i.body;
         if (!body.IsAwake()) continue;
         body.SetLinearVelocity(new b2Vec2(body.GetLinearVelocity().x + smallA.x, body.GetLinearVelocity().y + smallA.y));
      }
   }
   Box2D.inherit(b2ConstantForceController, Box2D.Dynamics.Controllers.b2Controller);
   b2ConstantForceController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
   b2ConstantForceController.b2ConstantForceController = function () {
      Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
      this.F = new b2Vec2(0, 0);
   };
   b2ConstantForceController.prototype.Step = function (step) {
      for (var i = this.m_bodyList; i; i = i.nextBody) {
         var body = i.body;
         if (!body.IsAwake()) continue;
         body.ApplyForce(this.F, body.GetWorldCenter());
      }
   }
   b2Controller.b2Controller = function () {};
   b2Controller.prototype.Step = function (step) {}
   b2Controller.prototype.Draw = function (debugDraw) {}
   b2Controller.prototype.AddBody = function (body) {
      var edge = new b2ControllerEdge();
      edge.controller = this;
      edge.body = body;
      edge.nextBody = this.m_bodyList;
      edge.prevBody = null;
      this.m_bodyList = edge;
      if (edge.nextBody) edge.nextBody.prevBody = edge;
      this.m_bodyCount++;
      edge.nextController = body.m_controllerList;
      edge.prevController = null;
      body.m_controllerList = edge;
      if (edge.nextController) edge.nextController.prevController = edge;
      body.m_controllerCount++;
   }
   b2Controller.prototype.RemoveBody = function (body) {
      var edge = body.m_controllerList;
      while (edge && edge.controller != this)
      edge = edge.nextController;
      if (edge.prevBody) edge.prevBody.nextBody = edge.nextBody;
      if (edge.nextBody) edge.nextBody.prevBody = edge.prevBody;
      if (edge.nextController) edge.nextController.prevController = edge.prevController;
      if (edge.prevController) edge.prevController.nextController = edge.nextController;
      if (this.m_bodyList == edge) this.m_bodyList = edge.nextBody;
      if (body.m_controllerList == edge) body.m_controllerList = edge.nextController;
      body.m_controllerCount--;
      this.m_bodyCount--;
   }
   b2Controller.prototype.Clear = function () {
      while (this.m_bodyList)
      this.RemoveBody(this.m_bodyList.body);
   }
   b2Controller.prototype.GetNext = function () {
      return this.m_next;
   }
   b2Controller.prototype.GetWorld = function () {
      return this.m_world;
   }
   b2Controller.prototype.GetBodyList = function () {
      return this.m_bodyList;
   }
   b2ControllerEdge.b2ControllerEdge = function () {};
   Box2D.inherit(b2GravityController, Box2D.Dynamics.Controllers.b2Controller);
   b2GravityController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
   b2GravityController.b2GravityController = function () {
      Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
      this.G = 1;
      this.invSqr = true;
   };
   b2GravityController.prototype.Step = function (step) {
      var i = null;
      var body1 = null;
      var p1 = null;
      var mass1 = 0;
      var j = null;
      var body2 = null;
      var p2 = null;
      var dx = 0;
      var dy = 0;
      var r2 = 0;
      var f = null;
      if (this.invSqr) {
         for (i = this.m_bodyList;
         i; i = i.nextBody) {
            body1 = i.body;
            p1 = body1.GetWorldCenter();
            mass1 = body1.GetMass();
            for (j = this.m_bodyList;
            j != i; j = j.nextBody) {
               body2 = j.body;
               p2 = body2.GetWorldCenter();
               dx = p2.x - p1.x;
               dy = p2.y - p1.y;
               r2 = dx * dx + dy * dy;
               if (r2 < FLOAT_EPSILON) continue;
               f = new b2Vec2(dx, dy);
               f.Multiply(this.G / r2 / Math.sqrt(r2) * mass1 * body2.GetMass());
               if (body1.IsAwake()) body1.ApplyForce(f, p1);
               f.Multiply((-1));
               if (body2.IsAwake()) body2.ApplyForce(f, p2);
            }
         }
      }
      else {
         for (i = this.m_bodyList;
         i; i = i.nextBody) {
            body1 = i.body;
            p1 = body1.GetWorldCenter();
            mass1 = body1.GetMass();
            for (j = this.m_bodyList;
            j != i; j = j.nextBody) {
               body2 = j.body;
               p2 = body2.GetWorldCenter();
               dx = p2.x - p1.x;
               dy = p2.y - p1.y;
               r2 = dx * dx + dy * dy;
               if (r2 < FLOAT_EPSILON) continue;
               f = new b2Vec2(dx, dy);
               f.Multiply(this.G / r2 * mass1 * body2.GetMass());
               if (body1.IsAwake()) body1.ApplyForce(f, p1);
               f.Multiply((-1));
               if (body2.IsAwake()) body2.ApplyForce(f, p2);
            }
         }
      }
   }
   Box2D.inherit(b2TensorDampingController, Box2D.Dynamics.Controllers.b2Controller);
   b2TensorDampingController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
   b2TensorDampingController.b2TensorDampingController = function () {
      Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
      this.T = new b2Mat22();
      this.maxTimestep = 0;
   };
   b2TensorDampingController.prototype.SetAxisAligned = function (xDamping, yDamping) {
      if (xDamping === undefined) xDamping = 0;
      if (yDamping === undefined) yDamping = 0;
      this.T.col1.x = (-xDamping);
      this.T.col1.y = 0;
      this.T.col2.x = 0;
      this.T.col2.y = (-yDamping);
      if (xDamping > 0 || yDamping > 0) {
         this.maxTimestep = 1 / Math.max(xDamping, yDamping);
      }
      else {
         this.maxTimestep = 0;
      }
   }
   b2TensorDampingController.prototype.Step = function (step) {
      var timestep = step.dt;
      if (timestep <= FLOAT_EPSILON) return;
      if (timestep > this.maxTimestep && this.maxTimestep > 0) timestep = this.maxTimestep;
      for (var i = this.m_bodyList; i; i = i.nextBody) {
         var body = i.body;
         if (!body.IsAwake()) {
            continue;
         }
         var damping = body.GetWorldVector(b2Math.MulMV(this.T, body.GetLocalVector(body.GetLinearVelocity())));
         body.SetLinearVelocity(new b2Vec2(body.GetLinearVelocity().x + damping.x * timestep, body.GetLinearVelocity().y + damping.y * timestep));
      }
   }
})();
(function () {
   var b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3,
      b2DistanceJoint = Box2D.Dynamics.Joints.b2DistanceJoint,
      b2DistanceJointDef = Box2D.Dynamics.Joints.b2DistanceJointDef,
      b2FrictionJoint = Box2D.Dynamics.Joints.b2FrictionJoint,
      b2FrictionJointDef = Box2D.Dynamics.Joints.b2FrictionJointDef,
      b2GearJoint = Box2D.Dynamics.Joints.b2GearJoint,
      b2GearJointDef = Box2D.Dynamics.Joints.b2GearJointDef,
      b2Jacobian = Box2D.Dynamics.Joints.b2Jacobian,
      b2Joint = Box2D.Dynamics.Joints.b2Joint,
      b2JointDef = Box2D.Dynamics.Joints.b2JointDef,
      b2JointEdge = Box2D.Dynamics.Joints.b2JointEdge,
      b2LineJoint = Box2D.Dynamics.Joints.b2LineJoint,
      b2LineJointDef = Box2D.Dynamics.Joints.b2LineJointDef,
      b2MouseJoint = Box2D.Dynamics.Joints.b2MouseJoint,
      b2MouseJointDef = Box2D.Dynamics.Joints.b2MouseJointDef,
      b2PrismaticJoint = Box2D.Dynamics.Joints.b2PrismaticJoint,
      b2PrismaticJointDef = Box2D.Dynamics.Joints.b2PrismaticJointDef,
      b2PulleyJoint = Box2D.Dynamics.Joints.b2PulleyJoint,
      b2PulleyJointDef = Box2D.Dynamics.Joints.b2PulleyJointDef,
      b2RevoluteJoint = Box2D.Dynamics.Joints.b2RevoluteJoint,
      b2RevoluteJointDef = Box2D.Dynamics.Joints.b2RevoluteJointDef,
      b2WeldJoint = Box2D.Dynamics.Joints.b2WeldJoint,
      b2WeldJointDef = Box2D.Dynamics.Joints.b2WeldJointDef,
      b2Body = Box2D.Dynamics.b2Body,
      b2BodyDef = Box2D.Dynamics.b2BodyDef,
      b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
      b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
      b2ContactListener = Box2D.Dynamics.b2ContactListener,
      b2ContactManager = Box2D.Dynamics.b2ContactManager,
      b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
      b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
      b2FilterData = Box2D.Dynamics.b2FilterData,
      b2Fixture = Box2D.Dynamics.b2Fixture,
      b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
      b2Island = Box2D.Dynamics.b2Island,
      b2TimeStep = Box2D.Dynamics.b2TimeStep,
      b2World = Box2D.Dynamics.b2World;

   Box2D.inherit(b2DistanceJoint, Box2D.Dynamics.Joints.b2Joint);
   b2DistanceJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2DistanceJoint.b2DistanceJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.m_localAnchor1 = new b2Vec2();
      this.m_localAnchor2 = new b2Vec2();
      this.m_u = new b2Vec2();
   };
   b2DistanceJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
   }
   b2DistanceJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
   }
   b2DistanceJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * this.m_impulse * this.m_u.x, inv_dt * this.m_impulse * this.m_u.y);
   }
   b2DistanceJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return 0.0;
   }
   b2DistanceJoint.prototype.GetLength = function () {
      return this.m_length;
   }
   b2DistanceJoint.prototype.SetLength = function (length) {
      if (length === undefined) length = 0;
      this.m_length = length;
   }
   b2DistanceJoint.prototype.GetFrequency = function () {
      return this.m_frequencyHz;
   }
   b2DistanceJoint.prototype.SetFrequency = function (hz) {
      if (hz === undefined) hz = 0;
      this.m_frequencyHz = hz;
   }
   b2DistanceJoint.prototype.GetDampingRatio = function () {
      return this.m_dampingRatio;
   }
   b2DistanceJoint.prototype.SetDampingRatio = function (ratio) {
      if (ratio === undefined) ratio = 0;
      this.m_dampingRatio = ratio;
   }
   b2DistanceJoint.prototype.b2DistanceJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      var tMat;
      var tX = 0;
      var tY = 0;
      this.m_localAnchor1.SetV(def.localAnchorA);
      this.m_localAnchor2.SetV(def.localAnchorB);
      this.m_length = def.length;
      this.m_frequencyHz = def.frequencyHz;
      this.m_dampingRatio = def.dampingRatio;
      this.m_impulse = 0.0;
      this.m_gamma = 0.0;
      this.m_bias = 0.0;
   }
   b2DistanceJoint.prototype.InitVelocityConstraints = function (step) {
      var tMat;
      var tX = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      this.m_u.x = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
      this.m_u.y = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
      var length = Math.sqrt(this.m_u.x * this.m_u.x + this.m_u.y * this.m_u.y);
      if (length > b2Settings.b2_linearSlop) {
         this.m_u.Multiply(1.0 / length);
      }
      else {
         this.m_u.SetZero();
      }
      var cr1u = (r1X * this.m_u.y - r1Y * this.m_u.x);
      var cr2u = (r2X * this.m_u.y - r2Y * this.m_u.x);
      var invMass = bA.m_invMass + bA.m_invI * cr1u * cr1u + bB.m_invMass + bB.m_invI * cr2u * cr2u;
      this.m_mass = invMass != 0.0 ? 1.0 / invMass : 0.0;
      if (this.m_frequencyHz > 0.0) {
         var C = length - this.m_length;
         var omega = 2.0 * Math.PI * this.m_frequencyHz;
         var d = 2.0 * this.m_mass * this.m_dampingRatio * omega;
         var k = this.m_mass * omega * omega;
         this.m_gamma = step.dt * (d + step.dt * k);
         this.m_gamma = this.m_gamma != 0.0 ? 1 / this.m_gamma : 0.0;
         this.m_bias = C * step.dt * k * this.m_gamma;
         this.m_mass = invMass + this.m_gamma;
         this.m_mass = this.m_mass != 0.0 ? 1.0 / this.m_mass : 0.0;
      }
      if (step.warmStarting) {
         this.m_impulse *= step.dtRatio;
         var PX = this.m_impulse * this.m_u.x;
         var PY = this.m_impulse * this.m_u.y;
         bA.m_linearVelocity.x -= bA.m_invMass * PX;
         bA.m_linearVelocity.y -= bA.m_invMass * PY;
         bA.m_angularVelocity -= bA.m_invI * (r1X * PY - r1Y * PX);
         bB.m_linearVelocity.x += bB.m_invMass * PX;
         bB.m_linearVelocity.y += bB.m_invMass * PY;
         bB.m_angularVelocity += bB.m_invI * (r2X * PY - r2Y * PX);
      }
      else {
         this.m_impulse = 0.0;
      }
   }
   b2DistanceJoint.prototype.SolveVelocityConstraints = function (step) {
      var tMat;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var v1X = bA.m_linearVelocity.x + ((-bA.m_angularVelocity * r1Y));
      var v1Y = bA.m_linearVelocity.y + (bA.m_angularVelocity * r1X);
      var v2X = bB.m_linearVelocity.x + ((-bB.m_angularVelocity * r2Y));
      var v2Y = bB.m_linearVelocity.y + (bB.m_angularVelocity * r2X);
      var Cdot = (this.m_u.x * (v2X - v1X) + this.m_u.y * (v2Y - v1Y));
      var impulse = (-this.m_mass * (Cdot + this.m_bias + this.m_gamma * this.m_impulse));
      this.m_impulse += impulse;
      var PX = impulse * this.m_u.x;
      var PY = impulse * this.m_u.y;
      bA.m_linearVelocity.x -= bA.m_invMass * PX;
      bA.m_linearVelocity.y -= bA.m_invMass * PY;
      bA.m_angularVelocity -= bA.m_invI * (r1X * PY - r1Y * PX);
      bB.m_linearVelocity.x += bB.m_invMass * PX;
      bB.m_linearVelocity.y += bB.m_invMass * PY;
      bB.m_angularVelocity += bB.m_invI * (r2X * PY - r2Y * PX);
   }
   b2DistanceJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var tMat;
      if (this.m_frequencyHz > 0.0) {
         return true;
      }
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
      var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
      var length = Math.sqrt(dX * dX + dY * dY);
      dX /= length;
      dY /= length;
      var C = length - this.m_length;
      C = b2Math.Clamp(C, (-b2Settings.b2_maxLinearCorrection), b2Settings.b2_maxLinearCorrection);
      var impulse = (-this.m_mass * C);
      this.m_u.Set(dX, dY);
      var PX = impulse * this.m_u.x;
      var PY = impulse * this.m_u.y;
      bA.m_sweep.c.x -= bA.m_invMass * PX;
      bA.m_sweep.c.y -= bA.m_invMass * PY;
      bA.m_sweep.a -= bA.m_invI * (r1X * PY - r1Y * PX);
      bB.m_sweep.c.x += bB.m_invMass * PX;
      bB.m_sweep.c.y += bB.m_invMass * PY;
      bB.m_sweep.a += bB.m_invI * (r2X * PY - r2Y * PX);
      bA.SynchronizeTransform();
      bB.SynchronizeTransform();
      return b2Math.Abs(C) < b2Settings.b2_linearSlop;
   }
   Box2D.inherit(b2DistanceJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2DistanceJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2DistanceJointDef.b2DistanceJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.localAnchorA = new b2Vec2();
      this.localAnchorB = new b2Vec2();
   };
   b2DistanceJointDef.prototype.b2DistanceJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_distanceJoint;
      this.length = 1.0;
      this.frequencyHz = 0.0;
      this.dampingRatio = 0.0;
   }
   b2DistanceJointDef.prototype.Initialize = function (bA, bB, anchorA, anchorB) {
      this.bodyA = bA;
      this.bodyB = bB;
      this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchorA));
      this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchorB));
      var dX = anchorB.x - anchorA.x;
      var dY = anchorB.y - anchorA.y;
      this.length = Math.sqrt(dX * dX + dY * dY);
      this.frequencyHz = 0.0;
      this.dampingRatio = 0.0;
   }
   Box2D.inherit(b2FrictionJoint, Box2D.Dynamics.Joints.b2Joint);
   b2FrictionJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2FrictionJoint.b2FrictionJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.m_localAnchorA = new b2Vec2();
      this.m_localAnchorB = new b2Vec2();
      this.m_linearMass = new b2Mat22();
      this.m_linearImpulse = new b2Vec2();
   };
   b2FrictionJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
   }
   b2FrictionJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
   }
   b2FrictionJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * this.m_linearImpulse.x, inv_dt * this.m_linearImpulse.y);
   }
   b2FrictionJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return inv_dt * this.m_angularImpulse;
   }
   b2FrictionJoint.prototype.SetMaxForce = function (force) {
      if (force === undefined) force = 0;
      this.m_maxForce = force;
   }
   b2FrictionJoint.prototype.GetMaxForce = function () {
      return this.m_maxForce;
   }
   b2FrictionJoint.prototype.SetMaxTorque = function (torque) {
      if (torque === undefined) torque = 0;
      this.m_maxTorque = torque;
   }
   b2FrictionJoint.prototype.GetMaxTorque = function () {
      return this.m_maxTorque;
   }
   b2FrictionJoint.prototype.b2FrictionJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      this.m_localAnchorA.SetV(def.localAnchorA);
      this.m_localAnchorB.SetV(def.localAnchorB);
      this.m_linearMass.SetZero();
      this.m_angularMass = 0.0;
      this.m_linearImpulse.SetZero();
      this.m_angularImpulse = 0.0;
      this.m_maxForce = def.maxForce;
      this.m_maxTorque = def.maxTorque;
   }
   b2FrictionJoint.prototype.InitVelocityConstraints = function (step) {
      var tMat;
      var tX = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      tMat = bA.m_xf.R;
      var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
      var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
      rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
      rAX = tX;
      tMat = bB.m_xf.R;
      var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
      var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
      rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
      rBX = tX;
      var mA = bA.m_invMass;
      var mB = bB.m_invMass;
      var iA = bA.m_invI;
      var iB = bB.m_invI;
      var K = new b2Mat22();
      K.col1.x = mA + mB;
      K.col2.x = 0.0;
      K.col1.y = 0.0;
      K.col2.y = mA + mB;
      K.col1.x += iA * rAY * rAY;
      K.col2.x += (-iA * rAX * rAY);
      K.col1.y += (-iA * rAX * rAY);
      K.col2.y += iA * rAX * rAX;
      K.col1.x += iB * rBY * rBY;
      K.col2.x += (-iB * rBX * rBY);
      K.col1.y += (-iB * rBX * rBY);
      K.col2.y += iB * rBX * rBX;
      K.GetInverse(this.m_linearMass);
      this.m_angularMass = iA + iB;
      if (this.m_angularMass > 0.0) {
         this.m_angularMass = 1.0 / this.m_angularMass;
      }
      if (step.warmStarting) {
         this.m_linearImpulse.x *= step.dtRatio;
         this.m_linearImpulse.y *= step.dtRatio;
         this.m_angularImpulse *= step.dtRatio;
         var P = this.m_linearImpulse;
         bA.m_linearVelocity.x -= mA * P.x;
         bA.m_linearVelocity.y -= mA * P.y;
         bA.m_angularVelocity -= iA * (rAX * P.y - rAY * P.x + this.m_angularImpulse);
         bB.m_linearVelocity.x += mB * P.x;
         bB.m_linearVelocity.y += mB * P.y;
         bB.m_angularVelocity += iB * (rBX * P.y - rBY * P.x + this.m_angularImpulse);
      }
      else {
         this.m_linearImpulse.SetZero();
         this.m_angularImpulse = 0.0;
      }
   }
   b2FrictionJoint.prototype.SolveVelocityConstraints = function (step) {
      var tMat;
      var tX = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var vA = bA.m_linearVelocity;
      var wA = bA.m_angularVelocity;
      var vB = bB.m_linearVelocity;
      var wB = bB.m_angularVelocity;
      var mA = bA.m_invMass;
      var mB = bB.m_invMass;
      var iA = bA.m_invI;
      var iB = bB.m_invI;
      tMat = bA.m_xf.R;
      var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
      var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
      rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
      rAX = tX;
      tMat = bB.m_xf.R;
      var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
      var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
      rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
      rBX = tX;
      var maxImpulse = 0; {
         var Cdot = wB - wA;
         var impulse = (-this.m_angularMass * Cdot);
         var oldImpulse = this.m_angularImpulse;
         maxImpulse = step.dt * this.m_maxTorque;
         this.m_angularImpulse = b2Math.Clamp(this.m_angularImpulse + impulse, (-maxImpulse), maxImpulse);
         impulse = this.m_angularImpulse - oldImpulse;
         wA -= iA * impulse;
         wB += iB * impulse;
      } {
         var CdotX = vB.x - wB * rBY - vA.x + wA * rAY;
         var CdotY = vB.y + wB * rBX - vA.y - wA * rAX;
         var impulseV = b2Math.MulMV(this.m_linearMass, new b2Vec2((-CdotX), (-CdotY)));
         var oldImpulseV = this.m_linearImpulse.Copy();
         this.m_linearImpulse.Add(impulseV);
         maxImpulse = step.dt * this.m_maxForce;
         if (this.m_linearImpulse.LengthSquared() > maxImpulse * maxImpulse) {
            this.m_linearImpulse.Normalize();
            this.m_linearImpulse.Multiply(maxImpulse);
         }
         impulseV = b2Math.SubtractVV(this.m_linearImpulse, oldImpulseV);
         vA.x -= mA * impulseV.x;
         vA.y -= mA * impulseV.y;
         wA -= iA * (rAX * impulseV.y - rAY * impulseV.x);
         vB.x += mB * impulseV.x;
         vB.y += mB * impulseV.y;
         wB += iB * (rBX * impulseV.y - rBY * impulseV.x);
      }
      bA.m_angularVelocity = wA;
      bB.m_angularVelocity = wB;
   }
   b2FrictionJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      return true;
   }
   Box2D.inherit(b2FrictionJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2FrictionJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2FrictionJointDef.b2FrictionJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.localAnchorA = new b2Vec2();
      this.localAnchorB = new b2Vec2();
   };
   b2FrictionJointDef.prototype.b2FrictionJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_frictionJoint;
      this.maxForce = 0.0;
      this.maxTorque = 0.0;
   }
   b2FrictionJointDef.prototype.Initialize = function (bA, bB, anchor) {
      this.bodyA = bA;
      this.bodyB = bB;
      this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchor));
      this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchor));
   }
   Box2D.inherit(b2GearJoint, Box2D.Dynamics.Joints.b2Joint);
   b2GearJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2GearJoint.b2GearJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.m_groundAnchor1 = new b2Vec2();
      this.m_groundAnchor2 = new b2Vec2();
      this.m_localAnchor1 = new b2Vec2();
      this.m_localAnchor2 = new b2Vec2();
      this.m_J = new b2Jacobian();
   };
   b2GearJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
   }
   b2GearJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
   }
   b2GearJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * this.m_impulse * this.m_J.linearB.x, inv_dt * this.m_impulse * this.m_J.linearB.y);
   }
   b2GearJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      var tMat = this.m_bodyB.m_xf.R;
      var rX = this.m_localAnchor1.x - this.m_bodyB.m_sweep.localCenter.x;
      var rY = this.m_localAnchor1.y - this.m_bodyB.m_sweep.localCenter.y;
      var tX = tMat.col1.x * rX + tMat.col2.x * rY;
      rY = tMat.col1.y * rX + tMat.col2.y * rY;
      rX = tX;
      var PX = this.m_impulse * this.m_J.linearB.x;
      var PY = this.m_impulse * this.m_J.linearB.y;
      return inv_dt * (this.m_impulse * this.m_J.angularB - rX * PY + rY * PX);
   }
   b2GearJoint.prototype.GetRatio = function () {
      return this.m_ratio;
   }
   b2GearJoint.prototype.SetRatio = function (ratio) {
      if (ratio === undefined) ratio = 0;
      this.m_ratio = ratio;
   }
   b2GearJoint.prototype.b2GearJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      var type1 = parseInt(def.joint1.m_type);
      var type2 = parseInt(def.joint2.m_type);
      this.m_revolute1 = null;
      this.m_prismatic1 = null;
      this.m_revolute2 = null;
      this.m_prismatic2 = null;
      var coordinate1 = 0;
      var coordinate2 = 0;
      this.m_ground1 = def.joint1.GetBodyA();
      this.m_bodyA = def.joint1.GetBodyB();
      if (type1 == b2Joint.e_revoluteJoint) {
         this.m_revolute1 = (def.joint1 instanceof b2RevoluteJoint ? def.joint1 : null);
         this.m_groundAnchor1.SetV(this.m_revolute1.m_localAnchor1);
         this.m_localAnchor1.SetV(this.m_revolute1.m_localAnchor2);
         coordinate1 = this.m_revolute1.GetJointAngle();
      }
      else {
         this.m_prismatic1 = (def.joint1 instanceof b2PrismaticJoint ? def.joint1 : null);
         this.m_groundAnchor1.SetV(this.m_prismatic1.m_localAnchor1);
         this.m_localAnchor1.SetV(this.m_prismatic1.m_localAnchor2);
         coordinate1 = this.m_prismatic1.GetJointTranslation();
      }
      this.m_ground2 = def.joint2.GetBodyA();
      this.m_bodyB = def.joint2.GetBodyB();
      if (type2 == b2Joint.e_revoluteJoint) {
         this.m_revolute2 = (def.joint2 instanceof b2RevoluteJoint ? def.joint2 : null);
         this.m_groundAnchor2.SetV(this.m_revolute2.m_localAnchor1);
         this.m_localAnchor2.SetV(this.m_revolute2.m_localAnchor2);
         coordinate2 = this.m_revolute2.GetJointAngle();
      }
      else {
         this.m_prismatic2 = (def.joint2 instanceof b2PrismaticJoint ? def.joint2 : null);
         this.m_groundAnchor2.SetV(this.m_prismatic2.m_localAnchor1);
         this.m_localAnchor2.SetV(this.m_prismatic2.m_localAnchor2);
         coordinate2 = this.m_prismatic2.GetJointTranslation();
      }
      this.m_ratio = def.ratio;
      this.m_constant = coordinate1 + this.m_ratio * coordinate2;
      this.m_impulse = 0.0;
   }
   b2GearJoint.prototype.InitVelocityConstraints = function (step) {
      var g1 = this.m_ground1;
      var g2 = this.m_ground2;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var ugX = 0;
      var ugY = 0;
      var rX = 0;
      var rY = 0;
      var tMat;
      var tVec;
      var crug = 0;
      var tX = 0;
      var K = 0.0;
      this.m_J.SetZero();
      if (this.m_revolute1) {
         this.m_J.angularA = (-1.0);
         K += bA.m_invI;
      }
      else {
         tMat = g1.m_xf.R;
         tVec = this.m_prismatic1.m_localXAxis1;
         ugX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
         ugY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
         tMat = bA.m_xf.R;
         rX = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
         rY = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
         tX = tMat.col1.x * rX + tMat.col2.x * rY;
         rY = tMat.col1.y * rX + tMat.col2.y * rY;
         rX = tX;
         crug = rX * ugY - rY * ugX;
         this.m_J.linearA.Set((-ugX), (-ugY));
         this.m_J.angularA = (-crug);
         K += bA.m_invMass + bA.m_invI * crug * crug;
      }
      if (this.m_revolute2) {
         this.m_J.angularB = (-this.m_ratio);
         K += this.m_ratio * this.m_ratio * bB.m_invI;
      }
      else {
         tMat = g2.m_xf.R;
         tVec = this.m_prismatic2.m_localXAxis1;
         ugX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
         ugY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
         tMat = bB.m_xf.R;
         rX = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
         rY = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
         tX = tMat.col1.x * rX + tMat.col2.x * rY;
         rY = tMat.col1.y * rX + tMat.col2.y * rY;
         rX = tX;
         crug = rX * ugY - rY * ugX;
         this.m_J.linearB.Set((-this.m_ratio * ugX), (-this.m_ratio * ugY));
         this.m_J.angularB = (-this.m_ratio * crug);
         K += this.m_ratio * this.m_ratio * (bB.m_invMass + bB.m_invI * crug * crug);
      }
      this.m_mass = K > 0.0 ? 1.0 / K : 0.0;
      if (step.warmStarting) {
         bA.m_linearVelocity.x += bA.m_invMass * this.m_impulse * this.m_J.linearA.x;
         bA.m_linearVelocity.y += bA.m_invMass * this.m_impulse * this.m_J.linearA.y;
         bA.m_angularVelocity += bA.m_invI * this.m_impulse * this.m_J.angularA;
         bB.m_linearVelocity.x += bB.m_invMass * this.m_impulse * this.m_J.linearB.x;
         bB.m_linearVelocity.y += bB.m_invMass * this.m_impulse * this.m_J.linearB.y;
         bB.m_angularVelocity += bB.m_invI * this.m_impulse * this.m_J.angularB;
      }
      else {
         this.m_impulse = 0.0;
      }
   }
   b2GearJoint.prototype.SolveVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var Cdot = this.m_J.Compute(bA.m_linearVelocity, bA.m_angularVelocity, bB.m_linearVelocity, bB.m_angularVelocity);
      var impulse = (-this.m_mass * Cdot);
      this.m_impulse += impulse;
      bA.m_linearVelocity.x += bA.m_invMass * impulse * this.m_J.linearA.x;
      bA.m_linearVelocity.y += bA.m_invMass * impulse * this.m_J.linearA.y;
      bA.m_angularVelocity += bA.m_invI * impulse * this.m_J.angularA;
      bB.m_linearVelocity.x += bB.m_invMass * impulse * this.m_J.linearB.x;
      bB.m_linearVelocity.y += bB.m_invMass * impulse * this.m_J.linearB.y;
      bB.m_angularVelocity += bB.m_invI * impulse * this.m_J.angularB;
   }
   b2GearJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var linearError = 0.0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var coordinate1 = 0;
      var coordinate2 = 0;
      if (this.m_revolute1) {
         coordinate1 = this.m_revolute1.GetJointAngle();
      }
      else {
         coordinate1 = this.m_prismatic1.GetJointTranslation();
      }
      if (this.m_revolute2) {
         coordinate2 = this.m_revolute2.GetJointAngle();
      }
      else {
         coordinate2 = this.m_prismatic2.GetJointTranslation();
      }
      var C = this.m_constant - (coordinate1 + this.m_ratio * coordinate2);
      var impulse = (-this.m_mass * C);
      bA.m_sweep.c.x += bA.m_invMass * impulse * this.m_J.linearA.x;
      bA.m_sweep.c.y += bA.m_invMass * impulse * this.m_J.linearA.y;
      bA.m_sweep.a += bA.m_invI * impulse * this.m_J.angularA;
      bB.m_sweep.c.x += bB.m_invMass * impulse * this.m_J.linearB.x;
      bB.m_sweep.c.y += bB.m_invMass * impulse * this.m_J.linearB.y;
      bB.m_sweep.a += bB.m_invI * impulse * this.m_J.angularB;
      bA.SynchronizeTransform();
      bB.SynchronizeTransform();
      return linearError < b2Settings.b2_linearSlop;
   }
   Box2D.inherit(b2GearJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2GearJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2GearJointDef.b2GearJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
   };
   b2GearJointDef.prototype.b2GearJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_gearJoint;
      this.joint1 = null;
      this.joint2 = null;
      this.ratio = 1.0;
   }
   b2Jacobian.b2Jacobian = function () {
      this.linearA = new b2Vec2();
      this.linearB = new b2Vec2();
   };
   b2Jacobian.prototype.SetZero = function () {
      this.linearA.SetZero();
      this.angularA = 0.0;
      this.linearB.SetZero();
      this.angularB = 0.0;
   }
   b2Jacobian.prototype.Set = function (x1, a1, x2, a2) {
      if (a1 === undefined) a1 = 0;
      if (a2 === undefined) a2 = 0;
      this.linearA.SetV(x1);
      this.angularA = a1;
      this.linearB.SetV(x2);
      this.angularB = a2;
   }
   b2Jacobian.prototype.Compute = function (x1, a1, x2, a2) {
      if (a1 === undefined) a1 = 0;
      if (a2 === undefined) a2 = 0;
      return (this.linearA.x * x1.x + this.linearA.y * x1.y) + this.angularA * a1 + (this.linearB.x * x2.x + this.linearB.y * x2.y) + this.angularB * a2;
   }
   b2Joint.b2Joint = function () {
      this.m_edgeA = new b2JointEdge();
      this.m_edgeB = new b2JointEdge();
      this.m_localCenterA = new b2Vec2();
      this.m_localCenterB = new b2Vec2();
   };
   b2Joint.prototype.GetType = function () {
      return this.m_type;
   }
   b2Joint.prototype.GetAnchorA = function () {
      return null;
   }
   b2Joint.prototype.GetAnchorB = function () {
      return null;
   }
   b2Joint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return null;
   }
   b2Joint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return 0.0;
   }
   b2Joint.prototype.GetBodyA = function () {
      return this.m_bodyA;
   }
   b2Joint.prototype.GetBodyB = function () {
      return this.m_bodyB;
   }
   b2Joint.prototype.GetNext = function () {
      return this.m_next;
   }
   b2Joint.prototype.GetUserData = function () {
      return this.m_userData;
   }
   b2Joint.prototype.SetUserData = function (data) {
      this.m_userData = data;
   }
   b2Joint.prototype.IsActive = function () {
      return this.m_bodyA.IsActive() && this.m_bodyB.IsActive();
   }
   b2Joint.Create = function (def, allocator) {
      var joint = null;
      switch (def.type) {
      case b2Joint.e_distanceJoint:
         {
            joint = new b2DistanceJoint((def instanceof b2DistanceJointDef ? def : null));
         }
         break;
      case b2Joint.e_mouseJoint:
         {
            joint = new b2MouseJoint((def instanceof b2MouseJointDef ? def : null));
         }
         break;
      case b2Joint.e_prismaticJoint:
         {
            joint = new b2PrismaticJoint((def instanceof b2PrismaticJointDef ? def : null));
         }
         break;
      case b2Joint.e_revoluteJoint:
         {
            joint = new b2RevoluteJoint((def instanceof b2RevoluteJointDef ? def : null));
         }
         break;
      case b2Joint.e_pulleyJoint:
         {
            joint = new b2PulleyJoint((def instanceof b2PulleyJointDef ? def : null));
         }
         break;
      case b2Joint.e_gearJoint:
         {
            joint = new b2GearJoint((def instanceof b2GearJointDef ? def : null));
         }
         break;
      case b2Joint.e_lineJoint:
         {
            joint = new b2LineJoint((def instanceof b2LineJointDef ? def : null));
         }
         break;
      case b2Joint.e_weldJoint:
         {
            joint = new b2WeldJoint((def instanceof b2WeldJointDef ? def : null));
         }
         break;
      case b2Joint.e_frictionJoint:
         {
            joint = new b2FrictionJoint((def instanceof b2FrictionJointDef ? def : null));
         }
         break;
      default:
         break;
      }
      return joint;
   }
   b2Joint.Destroy = function (joint, allocator) {}
   b2Joint.prototype.b2Joint = function (def) {
      b2Settings.b2Assert(def.bodyA != def.bodyB);
      this.m_type = def.type;
      this.m_prev = null;
      this.m_next = null;
      this.m_bodyA = def.bodyA;
      this.m_bodyB = def.bodyB;
      this.m_collideConnected = def.collideConnected;
      this.m_islandFlag = false;
      this.m_userData = def.userData;
   }
   b2Joint.prototype.InitVelocityConstraints = function (step) {}
   b2Joint.prototype.SolveVelocityConstraints = function (step) {}
   b2Joint.prototype.FinalizeVelocityConstraints = function () {}
   b2Joint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      return false;
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.Joints.b2Joint.e_unknownJoint = 0;
      Box2D.Dynamics.Joints.b2Joint.e_revoluteJoint = 1;
      Box2D.Dynamics.Joints.b2Joint.e_prismaticJoint = 2;
      Box2D.Dynamics.Joints.b2Joint.e_distanceJoint = 3;
      Box2D.Dynamics.Joints.b2Joint.e_pulleyJoint = 4;
      Box2D.Dynamics.Joints.b2Joint.e_mouseJoint = 5;
      Box2D.Dynamics.Joints.b2Joint.e_gearJoint = 6;
      Box2D.Dynamics.Joints.b2Joint.e_lineJoint = 7;
      Box2D.Dynamics.Joints.b2Joint.e_weldJoint = 8;
      Box2D.Dynamics.Joints.b2Joint.e_frictionJoint = 9;
      Box2D.Dynamics.Joints.b2Joint.e_inactiveLimit = 0;
      Box2D.Dynamics.Joints.b2Joint.e_atLowerLimit = 1;
      Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit = 2;
      Box2D.Dynamics.Joints.b2Joint.e_equalLimits = 3;
   });
   b2JointDef.b2JointDef = function () {};
   b2JointDef.prototype.b2JointDef = function () {
      this.type = b2Joint.e_unknownJoint;
      this.userData = null;
      this.bodyA = null;
      this.bodyB = null;
      this.collideConnected = false;
   }
   b2JointEdge.b2JointEdge = function () {};
   Box2D.inherit(b2LineJoint, Box2D.Dynamics.Joints.b2Joint);
   b2LineJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2LineJoint.b2LineJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.m_localAnchor1 = new b2Vec2();
      this.m_localAnchor2 = new b2Vec2();
      this.m_localXAxis1 = new b2Vec2();
      this.m_localYAxis1 = new b2Vec2();
      this.m_axis = new b2Vec2();
      this.m_perp = new b2Vec2();
      this.m_K = new b2Mat22();
      this.m_impulse = new b2Vec2();
   };
   b2LineJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
   }
   b2LineJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
   }
   b2LineJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x), inv_dt * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y));
   }
   b2LineJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return inv_dt * this.m_impulse.y;
   }
   b2LineJoint.prototype.GetJointTranslation = function () {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      var p1 = bA.GetWorldPoint(this.m_localAnchor1);
      var p2 = bB.GetWorldPoint(this.m_localAnchor2);
      var dX = p2.x - p1.x;
      var dY = p2.y - p1.y;
      var axis = bA.GetWorldVector(this.m_localXAxis1);
      var translation = axis.x * dX + axis.y * dY;
      return translation;
   }
   b2LineJoint.prototype.GetJointSpeed = function () {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var p1X = bA.m_sweep.c.x + r1X;
      var p1Y = bA.m_sweep.c.y + r1Y;
      var p2X = bB.m_sweep.c.x + r2X;
      var p2Y = bB.m_sweep.c.y + r2Y;
      var dX = p2X - p1X;
      var dY = p2Y - p1Y;
      var axis = bA.GetWorldVector(this.m_localXAxis1);
      var v1 = bA.m_linearVelocity;
      var v2 = bB.m_linearVelocity;
      var w1 = bA.m_angularVelocity;
      var w2 = bB.m_angularVelocity;
      var speed = (dX * ((-w1 * axis.y)) + dY * (w1 * axis.x)) + (axis.x * (((v2.x + ((-w2 * r2Y))) - v1.x) - ((-w1 * r1Y))) + axis.y * (((v2.y + (w2 * r2X)) - v1.y) - (w1 * r1X)));
      return speed;
   }
   b2LineJoint.prototype.IsLimitEnabled = function () {
      return this.m_enableLimit;
   }
   b2LineJoint.prototype.EnableLimit = function (flag) {
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_enableLimit = flag;
   }
   b2LineJoint.prototype.GetLowerLimit = function () {
      return this.m_lowerTranslation;
   }
   b2LineJoint.prototype.GetUpperLimit = function () {
      return this.m_upperTranslation;
   }
   b2LineJoint.prototype.SetLimits = function (lower, upper) {
      if (lower === undefined) lower = 0;
      if (upper === undefined) upper = 0;
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_lowerTranslation = lower;
      this.m_upperTranslation = upper;
   }
   b2LineJoint.prototype.IsMotorEnabled = function () {
      return this.m_enableMotor;
   }
   b2LineJoint.prototype.EnableMotor = function (flag) {
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_enableMotor = flag;
   }
   b2LineJoint.prototype.SetMotorSpeed = function (speed) {
      if (speed === undefined) speed = 0;
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_motorSpeed = speed;
   }
   b2LineJoint.prototype.GetMotorSpeed = function () {
      return this.m_motorSpeed;
   }
   b2LineJoint.prototype.SetMaxMotorForce = function (force) {
      if (force === undefined) force = 0;
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_maxMotorForce = force;
   }
   b2LineJoint.prototype.GetMaxMotorForce = function () {
      return this.m_maxMotorForce;
   }
   b2LineJoint.prototype.GetMotorForce = function () {
      return this.m_motorImpulse;
   }
   b2LineJoint.prototype.b2LineJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      var tMat;
      var tX = 0;
      var tY = 0;
      this.m_localAnchor1.SetV(def.localAnchorA);
      this.m_localAnchor2.SetV(def.localAnchorB);
      this.m_localXAxis1.SetV(def.localAxisA);
      this.m_localYAxis1.x = (-this.m_localXAxis1.y);
      this.m_localYAxis1.y = this.m_localXAxis1.x;
      this.m_impulse.SetZero();
      this.m_motorMass = 0.0;
      this.m_motorImpulse = 0.0;
      this.m_lowerTranslation = def.lowerTranslation;
      this.m_upperTranslation = def.upperTranslation;
      this.m_maxMotorForce = def.maxMotorForce;
      this.m_motorSpeed = def.motorSpeed;
      this.m_enableLimit = def.enableLimit;
      this.m_enableMotor = def.enableMotor;
      this.m_limitState = b2Joint.e_inactiveLimit;
      this.m_axis.SetZero();
      this.m_perp.SetZero();
   }
   b2LineJoint.prototype.InitVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      var tX = 0;
      this.m_localCenterA.SetV(bA.GetLocalCenter());
      this.m_localCenterB.SetV(bB.GetLocalCenter());
      var xf1 = bA.GetTransform();
      var xf2 = bB.GetTransform();
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
      var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
      tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
      var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
      var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
      this.m_invMassA = bA.m_invMass;
      this.m_invMassB = bB.m_invMass;
      this.m_invIA = bA.m_invI;
      this.m_invIB = bB.m_invI; {
         this.m_axis.SetV(b2Math.MulMV(xf1.R, this.m_localXAxis1));
         this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
         this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
         this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2;
         this.m_motorMass = this.m_motorMass > FLOAT_EPSILON ? 1.0 / this.m_motorMass : 0.0;
      } {
         this.m_perp.SetV(b2Math.MulMV(xf1.R, this.m_localYAxis1));
         this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
         this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
         var m1 = this.m_invMassA;
         var m2 = this.m_invMassB;
         var i1 = this.m_invIA;
         var i2 = this.m_invIB;
         this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
         this.m_K.col1.y = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
         this.m_K.col2.x = this.m_K.col1.y;
         this.m_K.col2.y = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
      }
      if (this.m_enableLimit) {
         var jointTransition = this.m_axis.x * dX + this.m_axis.y * dY;
         if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop) {
            this.m_limitState = b2Joint.e_equalLimits;
         }
         else if (jointTransition <= this.m_lowerTranslation) {
            if (this.m_limitState != b2Joint.e_atLowerLimit) {
               this.m_limitState = b2Joint.e_atLowerLimit;
               this.m_impulse.y = 0.0;
            }
         }
         else if (jointTransition >= this.m_upperTranslation) {
            if (this.m_limitState != b2Joint.e_atUpperLimit) {
               this.m_limitState = b2Joint.e_atUpperLimit;
               this.m_impulse.y = 0.0;
            }
         }
         else {
            this.m_limitState = b2Joint.e_inactiveLimit;
            this.m_impulse.y = 0.0;
         }
      }
      else {
         this.m_limitState = b2Joint.e_inactiveLimit;
      }
      if (this.m_enableMotor == false) {
         this.m_motorImpulse = 0.0;
      }
      if (step.warmStarting) {
         this.m_impulse.x *= step.dtRatio;
         this.m_impulse.y *= step.dtRatio;
         this.m_motorImpulse *= step.dtRatio;
         var PX = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x;
         var PY = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y;
         var L1 = this.m_impulse.x * this.m_s1 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a1;
         var L2 = this.m_impulse.x * this.m_s2 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a2;
         bA.m_linearVelocity.x -= this.m_invMassA * PX;
         bA.m_linearVelocity.y -= this.m_invMassA * PY;
         bA.m_angularVelocity -= this.m_invIA * L1;
         bB.m_linearVelocity.x += this.m_invMassB * PX;
         bB.m_linearVelocity.y += this.m_invMassB * PY;
         bB.m_angularVelocity += this.m_invIB * L2;
      }
      else {
         this.m_impulse.SetZero();
         this.m_motorImpulse = 0.0;
      }
   }
   b2LineJoint.prototype.SolveVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var v1 = bA.m_linearVelocity;
      var w1 = bA.m_angularVelocity;
      var v2 = bB.m_linearVelocity;
      var w2 = bB.m_angularVelocity;
      var PX = 0;
      var PY = 0;
      var L1 = 0;
      var L2 = 0;
      if (this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
         var Cdot = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
         var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);
         var oldImpulse = this.m_motorImpulse;
         var maxImpulse = step.dt * this.m_maxMotorForce;
         this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, (-maxImpulse), maxImpulse);
         impulse = this.m_motorImpulse - oldImpulse;
         PX = impulse * this.m_axis.x;
         PY = impulse * this.m_axis.y;
         L1 = impulse * this.m_a1;
         L2 = impulse * this.m_a2;
         v1.x -= this.m_invMassA * PX;
         v1.y -= this.m_invMassA * PY;
         w1 -= this.m_invIA * L1;
         v2.x += this.m_invMassB * PX;
         v2.y += this.m_invMassB * PY;
         w2 += this.m_invIB * L2;
      }
      var Cdot1 = this.m_perp.x * (v2.x - v1.x) + this.m_perp.y * (v2.y - v1.y) + this.m_s2 * w2 - this.m_s1 * w1;
      if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
         var Cdot2 = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
         var f1 = this.m_impulse.Copy();
         var df = this.m_K.Solve(new b2Vec2(), (-Cdot1), (-Cdot2));
         this.m_impulse.Add(df);
         if (this.m_limitState == b2Joint.e_atLowerLimit) {
            this.m_impulse.y = b2Math.Max(this.m_impulse.y, 0.0);
         }
         else if (this.m_limitState == b2Joint.e_atUpperLimit) {
            this.m_impulse.y = b2Math.Min(this.m_impulse.y, 0.0);
         }
         var b = (-Cdot1) - (this.m_impulse.y - f1.y) * this.m_K.col2.x;
         var f2r = 0;
         if (this.m_K.col1.x != 0.0) {
            f2r = b / this.m_K.col1.x + f1.x;
         }
         else {
            f2r = f1.x;
         }
         this.m_impulse.x = f2r;
         df.x = this.m_impulse.x - f1.x;
         df.y = this.m_impulse.y - f1.y;
         PX = df.x * this.m_perp.x + df.y * this.m_axis.x;
         PY = df.x * this.m_perp.y + df.y * this.m_axis.y;
         L1 = df.x * this.m_s1 + df.y * this.m_a1;
         L2 = df.x * this.m_s2 + df.y * this.m_a2;
         v1.x -= this.m_invMassA * PX;
         v1.y -= this.m_invMassA * PY;
         w1 -= this.m_invIA * L1;
         v2.x += this.m_invMassB * PX;
         v2.y += this.m_invMassB * PY;
         w2 += this.m_invIB * L2;
      }
      else {
         var df2 = 0;
         if (this.m_K.col1.x != 0.0) {
            df2 = ((-Cdot1)) / this.m_K.col1.x;
         }
         else {
            df2 = 0.0;
         }
         this.m_impulse.x += df2;
         PX = df2 * this.m_perp.x;
         PY = df2 * this.m_perp.y;
         L1 = df2 * this.m_s1;
         L2 = df2 * this.m_s2;
         v1.x -= this.m_invMassA * PX;
         v1.y -= this.m_invMassA * PY;
         w1 -= this.m_invIA * L1;
         v2.x += this.m_invMassB * PX;
         v2.y += this.m_invMassB * PY;
         w2 += this.m_invIB * L2;
      }
      bA.m_linearVelocity.SetV(v1);
      bA.m_angularVelocity = w1;
      bB.m_linearVelocity.SetV(v2);
      bB.m_angularVelocity = w2;
   }
   b2LineJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var limitC = 0;
      var oldLimitImpulse = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var c1 = bA.m_sweep.c;
      var a1 = bA.m_sweep.a;
      var c2 = bB.m_sweep.c;
      var a2 = bB.m_sweep.a;
      var tMat;
      var tX = 0;
      var m1 = 0;
      var m2 = 0;
      var i1 = 0;
      var i2 = 0;
      var linearError = 0.0;
      var angularError = 0.0;
      var active = false;
      var C2 = 0.0;
      var R1 = b2Mat22.FromAngle(a1);
      var R2 = b2Mat22.FromAngle(a2);
      tMat = R1;
      var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
      var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
      tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = R2;
      var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
      var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var dX = c2.x + r2X - c1.x - r1X;
      var dY = c2.y + r2Y - c1.y - r1Y;
      if (this.m_enableLimit) {
         this.m_axis = b2Math.MulMV(R1, this.m_localXAxis1);
         this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
         this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
         var translation = this.m_axis.x * dX + this.m_axis.y * dY;
         if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop) {
            C2 = b2Math.Clamp(translation, (-b2Settings.b2_maxLinearCorrection), b2Settings.b2_maxLinearCorrection);
            linearError = b2Math.Abs(translation);
            active = true;
         }
         else if (translation <= this.m_lowerTranslation) {
            C2 = b2Math.Clamp(translation - this.m_lowerTranslation + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
            linearError = this.m_lowerTranslation - translation;
            active = true;
         }
         else if (translation >= this.m_upperTranslation) {
            C2 = b2Math.Clamp(translation - this.m_upperTranslation + b2Settings.b2_linearSlop, 0.0, b2Settings.b2_maxLinearCorrection);
            linearError = translation - this.m_upperTranslation;
            active = true;
         }
      }
      this.m_perp = b2Math.MulMV(R1, this.m_localYAxis1);
      this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
      this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
      var impulse = new b2Vec2();
      var C1 = this.m_perp.x * dX + this.m_perp.y * dY;
      linearError = b2Math.Max(linearError, b2Math.Abs(C1));
      angularError = 0.0;
      if (active) {
         m1 = this.m_invMassA;
         m2 = this.m_invMassB;
         i1 = this.m_invIA;
         i2 = this.m_invIB;
         this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
         this.m_K.col1.y = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
         this.m_K.col2.x = this.m_K.col1.y;
         this.m_K.col2.y = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
         this.m_K.Solve(impulse, (-C1), (-C2));
      }
      else {
         m1 = this.m_invMassA;
         m2 = this.m_invMassB;
         i1 = this.m_invIA;
         i2 = this.m_invIB;
         var k11 = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
         var impulse1 = 0;
         if (k11 != 0.0) {
            impulse1 = ((-C1)) / k11;
         }
         else {
            impulse1 = 0.0;
         }
         impulse.x = impulse1;
         impulse.y = 0.0;
      }
      var PX = impulse.x * this.m_perp.x + impulse.y * this.m_axis.x;
      var PY = impulse.x * this.m_perp.y + impulse.y * this.m_axis.y;
      var L1 = impulse.x * this.m_s1 + impulse.y * this.m_a1;
      var L2 = impulse.x * this.m_s2 + impulse.y * this.m_a2;
      c1.x -= this.m_invMassA * PX;
      c1.y -= this.m_invMassA * PY;
      a1 -= this.m_invIA * L1;
      c2.x += this.m_invMassB * PX;
      c2.y += this.m_invMassB * PY;
      a2 += this.m_invIB * L2;
      bA.m_sweep.a = a1;
      bB.m_sweep.a = a2;
      bA.SynchronizeTransform();
      bB.SynchronizeTransform();
      return linearError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop;
   }
   Box2D.inherit(b2LineJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2LineJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2LineJointDef.b2LineJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.localAnchorA = new b2Vec2();
      this.localAnchorB = new b2Vec2();
      this.localAxisA = new b2Vec2();
   };
   b2LineJointDef.prototype.b2LineJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_lineJoint;
      this.localAxisA.Set(1.0, 0.0);
      this.enableLimit = false;
      this.lowerTranslation = 0.0;
      this.upperTranslation = 0.0;
      this.enableMotor = false;
      this.maxMotorForce = 0.0;
      this.motorSpeed = 0.0;
   }
   b2LineJointDef.prototype.Initialize = function (bA, bB, anchor, axis) {
      this.bodyA = bA;
      this.bodyB = bB;
      this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
      this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
      this.localAxisA = this.bodyA.GetLocalVector(axis);
   }
   Box2D.inherit(b2MouseJoint, Box2D.Dynamics.Joints.b2Joint);
   b2MouseJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2MouseJoint.b2MouseJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.K = new b2Mat22();
      this.K1 = new b2Mat22();
      this.K2 = new b2Mat22();
      this.m_localAnchor = new b2Vec2();
      this.m_target = new b2Vec2();
      this.m_impulse = new b2Vec2();
      this.m_mass = new b2Mat22();
      this.m_C = new b2Vec2();
   };
   b2MouseJoint.prototype.GetAnchorA = function () {
      return this.m_target;
   }
   b2MouseJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchor);
   }
   b2MouseJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y);
   }
   b2MouseJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return 0.0;
   }
   b2MouseJoint.prototype.GetTarget = function () {
      return this.m_target;
   }
   b2MouseJoint.prototype.SetTarget = function (target) {
      if (this.m_bodyB.IsAwake() == false) {
         this.m_bodyB.SetAwake(true);
      }
      this.m_target = target;
   }
   b2MouseJoint.prototype.GetMaxForce = function () {
      return this.m_maxForce;
   }
   b2MouseJoint.prototype.SetMaxForce = function (maxForce) {
      if (maxForce === undefined) maxForce = 0;
      this.m_maxForce = maxForce;
   }
   b2MouseJoint.prototype.GetFrequency = function () {
      return this.m_frequencyHz;
   }
   b2MouseJoint.prototype.SetFrequency = function (hz) {
      if (hz === undefined) hz = 0;
      this.m_frequencyHz = hz;
   }
   b2MouseJoint.prototype.GetDampingRatio = function () {
      return this.m_dampingRatio;
   }
   b2MouseJoint.prototype.SetDampingRatio = function (ratio) {
      if (ratio === undefined) ratio = 0;
      this.m_dampingRatio = ratio;
   }
   b2MouseJoint.prototype.b2MouseJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      this.m_target.SetV(def.target);
      var tX = this.m_target.x - this.m_bodyB.m_xf.position.x;
      var tY = this.m_target.y - this.m_bodyB.m_xf.position.y;
      var tMat = this.m_bodyB.m_xf.R;
      this.m_localAnchor.x = (tX * tMat.col1.x + tY * tMat.col1.y);
      this.m_localAnchor.y = (tX * tMat.col2.x + tY * tMat.col2.y);
      this.m_maxForce = def.maxForce;
      this.m_impulse.SetZero();
      this.m_frequencyHz = def.frequencyHz;
      this.m_dampingRatio = def.dampingRatio;
      this.m_beta = 0.0;
      this.m_gamma = 0.0;
   }
   b2MouseJoint.prototype.InitVelocityConstraints = function (step) {
      var b = this.m_bodyB;
      var mass = b.GetMass();
      var omega = 2.0 * Math.PI * this.m_frequencyHz;
      var d = 2.0 * mass * this.m_dampingRatio * omega;
      var k = mass * omega * omega;
      this.m_gamma = step.dt * (d + step.dt * k);
      this.m_gamma = this.m_gamma != 0 ? 1 / this.m_gamma : 0.0;
      this.m_beta = step.dt * k * this.m_gamma;
      var tMat;tMat = b.m_xf.R;
      var rX = this.m_localAnchor.x - b.m_sweep.localCenter.x;
      var rY = this.m_localAnchor.y - b.m_sweep.localCenter.y;
      var tX = (tMat.col1.x * rX + tMat.col2.x * rY);rY = (tMat.col1.y * rX + tMat.col2.y * rY);
      rX = tX;
      var invMass = b.m_invMass;
      var invI = b.m_invI;this.K1.col1.x = invMass;
      this.K1.col2.x = 0.0;
      this.K1.col1.y = 0.0;
      this.K1.col2.y = invMass;
      this.K2.col1.x = invI * rY * rY;
      this.K2.col2.x = (-invI * rX * rY);
      this.K2.col1.y = (-invI * rX * rY);
      this.K2.col2.y = invI * rX * rX;
      this.K.SetM(this.K1);
      this.K.AddM(this.K2);
      this.K.col1.x += this.m_gamma;
      this.K.col2.y += this.m_gamma;
      this.K.GetInverse(this.m_mass);
      this.m_C.x = b.m_sweep.c.x + rX - this.m_target.x;
      this.m_C.y = b.m_sweep.c.y + rY - this.m_target.y;
      b.m_angularVelocity *= 0.98;
      this.m_impulse.x *= step.dtRatio;
      this.m_impulse.y *= step.dtRatio;
      b.m_linearVelocity.x += invMass * this.m_impulse.x;
      b.m_linearVelocity.y += invMass * this.m_impulse.y;
      b.m_angularVelocity += invI * (rX * this.m_impulse.y - rY * this.m_impulse.x);
   }
   b2MouseJoint.prototype.SolveVelocityConstraints = function (step) {
      var b = this.m_bodyB;
      var tMat;
      var tX = 0;
      var tY = 0;
      tMat = b.m_xf.R;
      var rX = this.m_localAnchor.x - b.m_sweep.localCenter.x;
      var rY = this.m_localAnchor.y - b.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rX + tMat.col2.x * rY);
      rY = (tMat.col1.y * rX + tMat.col2.y * rY);
      rX = tX;
      var CdotX = b.m_linearVelocity.x + ((-b.m_angularVelocity * rY));
      var CdotY = b.m_linearVelocity.y + (b.m_angularVelocity * rX);
      tMat = this.m_mass;
      tX = CdotX + this.m_beta * this.m_C.x + this.m_gamma * this.m_impulse.x;
      tY = CdotY + this.m_beta * this.m_C.y + this.m_gamma * this.m_impulse.y;
      var impulseX = (-(tMat.col1.x * tX + tMat.col2.x * tY));
      var impulseY = (-(tMat.col1.y * tX + tMat.col2.y * tY));
      var oldImpulseX = this.m_impulse.x;
      var oldImpulseY = this.m_impulse.y;
      this.m_impulse.x += impulseX;
      this.m_impulse.y += impulseY;
      var maxImpulse = step.dt * this.m_maxForce;
      if (this.m_impulse.LengthSquared() > maxImpulse * maxImpulse) {
         this.m_impulse.Multiply(maxImpulse / this.m_impulse.Length());
      }
      impulseX = this.m_impulse.x - oldImpulseX;
      impulseY = this.m_impulse.y - oldImpulseY;
      b.m_linearVelocity.x += b.m_invMass * impulseX;
      b.m_linearVelocity.y += b.m_invMass * impulseY;
      b.m_angularVelocity += b.m_invI * (rX * impulseY - rY * impulseX);
   }
   b2MouseJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      return true;
   }
   Box2D.inherit(b2MouseJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2MouseJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2MouseJointDef.b2MouseJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.target = new b2Vec2();
   };
   b2MouseJointDef.prototype.b2MouseJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_mouseJoint;
      this.maxForce = 0.0;
      this.frequencyHz = 5.0;
      this.dampingRatio = 0.7;
   }
   Box2D.inherit(b2PrismaticJoint, Box2D.Dynamics.Joints.b2Joint);
   b2PrismaticJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2PrismaticJoint.b2PrismaticJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.m_localAnchor1 = new b2Vec2();
      this.m_localAnchor2 = new b2Vec2();
      this.m_localXAxis1 = new b2Vec2();
      this.m_localYAxis1 = new b2Vec2();
      this.m_axis = new b2Vec2();
      this.m_perp = new b2Vec2();
      this.m_K = new b2Mat33();
      this.m_impulse = new b2Vec3();
   };
   b2PrismaticJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
   }
   b2PrismaticJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
   }
   b2PrismaticJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x), inv_dt * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y));
   }
   b2PrismaticJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return inv_dt * this.m_impulse.y;
   }
   b2PrismaticJoint.prototype.GetJointTranslation = function () {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      var p1 = bA.GetWorldPoint(this.m_localAnchor1);
      var p2 = bB.GetWorldPoint(this.m_localAnchor2);
      var dX = p2.x - p1.x;
      var dY = p2.y - p1.y;
      var axis = bA.GetWorldVector(this.m_localXAxis1);
      var translation = axis.x * dX + axis.y * dY;
      return translation;
   }
   b2PrismaticJoint.prototype.GetJointSpeed = function () {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var p1X = bA.m_sweep.c.x + r1X;
      var p1Y = bA.m_sweep.c.y + r1Y;
      var p2X = bB.m_sweep.c.x + r2X;
      var p2Y = bB.m_sweep.c.y + r2Y;
      var dX = p2X - p1X;
      var dY = p2Y - p1Y;
      var axis = bA.GetWorldVector(this.m_localXAxis1);
      var v1 = bA.m_linearVelocity;
      var v2 = bB.m_linearVelocity;
      var w1 = bA.m_angularVelocity;
      var w2 = bB.m_angularVelocity;
      var speed = (dX * ((-w1 * axis.y)) + dY * (w1 * axis.x)) + (axis.x * (((v2.x + ((-w2 * r2Y))) - v1.x) - ((-w1 * r1Y))) + axis.y * (((v2.y + (w2 * r2X)) - v1.y) - (w1 * r1X)));
      return speed;
   }
   b2PrismaticJoint.prototype.IsLimitEnabled = function () {
      return this.m_enableLimit;
   }
   b2PrismaticJoint.prototype.EnableLimit = function (flag) {
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_enableLimit = flag;
   }
   b2PrismaticJoint.prototype.GetLowerLimit = function () {
      return this.m_lowerTranslation;
   }
   b2PrismaticJoint.prototype.GetUpperLimit = function () {
      return this.m_upperTranslation;
   }
   b2PrismaticJoint.prototype.SetLimits = function (lower, upper) {
      if (lower === undefined) lower = 0;
      if (upper === undefined) upper = 0;
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_lowerTranslation = lower;
      this.m_upperTranslation = upper;
   }
   b2PrismaticJoint.prototype.IsMotorEnabled = function () {
      return this.m_enableMotor;
   }
   b2PrismaticJoint.prototype.EnableMotor = function (flag) {
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_enableMotor = flag;
   }
   b2PrismaticJoint.prototype.SetMotorSpeed = function (speed) {
      if (speed === undefined) speed = 0;
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_motorSpeed = speed;
   }
   b2PrismaticJoint.prototype.GetMotorSpeed = function () {
      return this.m_motorSpeed;
   }
   b2PrismaticJoint.prototype.SetMaxMotorForce = function (force) {
      if (force === undefined) force = 0;
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_maxMotorForce = force;
   }
   b2PrismaticJoint.prototype.GetMotorForce = function () {
      return this.m_motorImpulse;
   }
   b2PrismaticJoint.prototype.b2PrismaticJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      var tMat;
      var tX = 0;
      var tY = 0;
      this.m_localAnchor1.SetV(def.localAnchorA);
      this.m_localAnchor2.SetV(def.localAnchorB);
      this.m_localXAxis1.SetV(def.localAxisA);
      this.m_localYAxis1.x = (-this.m_localXAxis1.y);
      this.m_localYAxis1.y = this.m_localXAxis1.x;
      this.m_refAngle = def.referenceAngle;
      this.m_impulse.SetZero();
      this.m_motorMass = 0.0;
      this.m_motorImpulse = 0.0;
      this.m_lowerTranslation = def.lowerTranslation;
      this.m_upperTranslation = def.upperTranslation;
      this.m_maxMotorForce = def.maxMotorForce;
      this.m_motorSpeed = def.motorSpeed;
      this.m_enableLimit = def.enableLimit;
      this.m_enableMotor = def.enableMotor;
      this.m_limitState = b2Joint.e_inactiveLimit;
      this.m_axis.SetZero();
      this.m_perp.SetZero();
   }
   b2PrismaticJoint.prototype.InitVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      var tX = 0;
      this.m_localCenterA.SetV(bA.GetLocalCenter());
      this.m_localCenterB.SetV(bB.GetLocalCenter());
      var xf1 = bA.GetTransform();
      var xf2 = bB.GetTransform();
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
      var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
      tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
      var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
      var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
      this.m_invMassA = bA.m_invMass;
      this.m_invMassB = bB.m_invMass;
      this.m_invIA = bA.m_invI;
      this.m_invIB = bB.m_invI; {
         this.m_axis.SetV(b2Math.MulMV(xf1.R, this.m_localXAxis1));
         this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
         this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
         this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2;
         if (this.m_motorMass > FLOAT_EPSILON) this.m_motorMass = 1.0 / this.m_motorMass;
      } {
         this.m_perp.SetV(b2Math.MulMV(xf1.R, this.m_localYAxis1));
         this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
         this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
         var m1 = this.m_invMassA;
         var m2 = this.m_invMassB;
         var i1 = this.m_invIA;
         var i2 = this.m_invIB;
         this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
         this.m_K.col1.y = i1 * this.m_s1 + i2 * this.m_s2;
         this.m_K.col1.z = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
         this.m_K.col2.x = this.m_K.col1.y;
         this.m_K.col2.y = i1 + i2;
         this.m_K.col2.z = i1 * this.m_a1 + i2 * this.m_a2;
         this.m_K.col3.x = this.m_K.col1.z;
         this.m_K.col3.y = this.m_K.col2.z;
         this.m_K.col3.z = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
      }
      if (this.m_enableLimit) {
         var jointTransition = this.m_axis.x * dX + this.m_axis.y * dY;
         if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop) {
            this.m_limitState = b2Joint.e_equalLimits;
         }
         else if (jointTransition <= this.m_lowerTranslation) {
            if (this.m_limitState != b2Joint.e_atLowerLimit) {
               this.m_limitState = b2Joint.e_atLowerLimit;
               this.m_impulse.z = 0.0;
            }
         }
         else if (jointTransition >= this.m_upperTranslation) {
            if (this.m_limitState != b2Joint.e_atUpperLimit) {
               this.m_limitState = b2Joint.e_atUpperLimit;
               this.m_impulse.z = 0.0;
            }
         }
         else {
            this.m_limitState = b2Joint.e_inactiveLimit;
            this.m_impulse.z = 0.0;
         }
      }
      else {
         this.m_limitState = b2Joint.e_inactiveLimit;
      }
      if (this.m_enableMotor == false) {
         this.m_motorImpulse = 0.0;
      }
      if (step.warmStarting) {
         this.m_impulse.x *= step.dtRatio;
         this.m_impulse.y *= step.dtRatio;
         this.m_motorImpulse *= step.dtRatio;
         var PX = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x;
         var PY = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y;
         var L1 = this.m_impulse.x * this.m_s1 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1;
         var L2 = this.m_impulse.x * this.m_s2 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2;
         bA.m_linearVelocity.x -= this.m_invMassA * PX;
         bA.m_linearVelocity.y -= this.m_invMassA * PY;
         bA.m_angularVelocity -= this.m_invIA * L1;
         bB.m_linearVelocity.x += this.m_invMassB * PX;
         bB.m_linearVelocity.y += this.m_invMassB * PY;
         bB.m_angularVelocity += this.m_invIB * L2;
      }
      else {
         this.m_impulse.SetZero();
         this.m_motorImpulse = 0.0;
      }
   }
   b2PrismaticJoint.prototype.SolveVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var v1 = bA.m_linearVelocity;
      var w1 = bA.m_angularVelocity;
      var v2 = bB.m_linearVelocity;
      var w2 = bB.m_angularVelocity;
      var PX = 0;
      var PY = 0;
      var L1 = 0;
      var L2 = 0;
      if (this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
         var Cdot = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
         var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);
         var oldImpulse = this.m_motorImpulse;
         var maxImpulse = step.dt * this.m_maxMotorForce;
         this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, (-maxImpulse), maxImpulse);
         impulse = this.m_motorImpulse - oldImpulse;
         PX = impulse * this.m_axis.x;
         PY = impulse * this.m_axis.y;
         L1 = impulse * this.m_a1;
         L2 = impulse * this.m_a2;
         v1.x -= this.m_invMassA * PX;
         v1.y -= this.m_invMassA * PY;
         w1 -= this.m_invIA * L1;
         v2.x += this.m_invMassB * PX;
         v2.y += this.m_invMassB * PY;
         w2 += this.m_invIB * L2;
      }
      var Cdot1X = this.m_perp.x * (v2.x - v1.x) + this.m_perp.y * (v2.y - v1.y) + this.m_s2 * w2 - this.m_s1 * w1;
      var Cdot1Y = w2 - w1;
      if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
         var Cdot2 = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
         var f1 = this.m_impulse.Copy();
         var df = this.m_K.Solve33(new b2Vec3(), (-Cdot1X), (-Cdot1Y), (-Cdot2));
         this.m_impulse.Add(df);
         if (this.m_limitState == b2Joint.e_atLowerLimit) {
            this.m_impulse.z = b2Math.Max(this.m_impulse.z, 0.0);
         }
         else if (this.m_limitState == b2Joint.e_atUpperLimit) {
            this.m_impulse.z = b2Math.Min(this.m_impulse.z, 0.0);
         }
         var bX = (-Cdot1X) - (this.m_impulse.z - f1.z) * this.m_K.col3.x;
         var bY = (-Cdot1Y) - (this.m_impulse.z - f1.z) * this.m_K.col3.y;
         var f2r = this.m_K.Solve22(new b2Vec2(), bX, bY);
         f2r.x += f1.x;
         f2r.y += f1.y;
         this.m_impulse.x = f2r.x;
         this.m_impulse.y = f2r.y;
         df.x = this.m_impulse.x - f1.x;
         df.y = this.m_impulse.y - f1.y;
         df.z = this.m_impulse.z - f1.z;
         PX = df.x * this.m_perp.x + df.z * this.m_axis.x;
         PY = df.x * this.m_perp.y + df.z * this.m_axis.y;
         L1 = df.x * this.m_s1 + df.y + df.z * this.m_a1;
         L2 = df.x * this.m_s2 + df.y + df.z * this.m_a2;
         v1.x -= this.m_invMassA * PX;
         v1.y -= this.m_invMassA * PY;
         w1 -= this.m_invIA * L1;
         v2.x += this.m_invMassB * PX;
         v2.y += this.m_invMassB * PY;
         w2 += this.m_invIB * L2;
      }
      else {
         var df2 = this.m_K.Solve22(new b2Vec2(), (-Cdot1X), (-Cdot1Y));
         this.m_impulse.x += df2.x;
         this.m_impulse.y += df2.y;
         PX = df2.x * this.m_perp.x;
         PY = df2.x * this.m_perp.y;
         L1 = df2.x * this.m_s1 + df2.y;
         L2 = df2.x * this.m_s2 + df2.y;
         v1.x -= this.m_invMassA * PX;
         v1.y -= this.m_invMassA * PY;
         w1 -= this.m_invIA * L1;
         v2.x += this.m_invMassB * PX;
         v2.y += this.m_invMassB * PY;
         w2 += this.m_invIB * L2;
      }
      bA.m_linearVelocity.SetV(v1);
      bA.m_angularVelocity = w1;
      bB.m_linearVelocity.SetV(v2);
      bB.m_angularVelocity = w2;
   }
   b2PrismaticJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var limitC = 0;
      var oldLimitImpulse = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var c1 = bA.m_sweep.c;
      var a1 = bA.m_sweep.a;
      var c2 = bB.m_sweep.c;
      var a2 = bB.m_sweep.a;
      var tMat;
      var tX = 0;
      var m1 = 0;
      var m2 = 0;
      var i1 = 0;
      var i2 = 0;
      var linearError = 0.0;
      var angularError = 0.0;
      var active = false;
      var C2 = 0.0;
      var R1 = b2Mat22.FromAngle(a1);
      var R2 = b2Mat22.FromAngle(a2);
      tMat = R1;
      var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
      var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
      tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = R2;
      var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
      var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var dX = c2.x + r2X - c1.x - r1X;
      var dY = c2.y + r2Y - c1.y - r1Y;
      if (this.m_enableLimit) {
         this.m_axis = b2Math.MulMV(R1, this.m_localXAxis1);
         this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
         this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
         var translation = this.m_axis.x * dX + this.m_axis.y * dY;
         if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop) {
            C2 = b2Math.Clamp(translation, (-b2Settings.b2_maxLinearCorrection), b2Settings.b2_maxLinearCorrection);
            linearError = b2Math.Abs(translation);
            active = true;
         }
         else if (translation <= this.m_lowerTranslation) {
            C2 = b2Math.Clamp(translation - this.m_lowerTranslation + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
            linearError = this.m_lowerTranslation - translation;
            active = true;
         }
         else if (translation >= this.m_upperTranslation) {
            C2 = b2Math.Clamp(translation - this.m_upperTranslation + b2Settings.b2_linearSlop, 0.0, b2Settings.b2_maxLinearCorrection);
            linearError = translation - this.m_upperTranslation;
            active = true;
         }
      }
      this.m_perp = b2Math.MulMV(R1, this.m_localYAxis1);
      this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
      this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
      var impulse = new b2Vec3();
      var C1X = this.m_perp.x * dX + this.m_perp.y * dY;
      var C1Y = a2 - a1 - this.m_refAngle;
      linearError = b2Math.Max(linearError, b2Math.Abs(C1X));
      angularError = b2Math.Abs(C1Y);
      if (active) {
         m1 = this.m_invMassA;
         m2 = this.m_invMassB;
         i1 = this.m_invIA;
         i2 = this.m_invIB;
         this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
         this.m_K.col1.y = i1 * this.m_s1 + i2 * this.m_s2;
         this.m_K.col1.z = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
         this.m_K.col2.x = this.m_K.col1.y;
         this.m_K.col2.y = i1 + i2;
         this.m_K.col2.z = i1 * this.m_a1 + i2 * this.m_a2;
         this.m_K.col3.x = this.m_K.col1.z;
         this.m_K.col3.y = this.m_K.col2.z;
         this.m_K.col3.z = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
         this.m_K.Solve33(impulse, (-C1X), (-C1Y), (-C2));
      }
      else {
         m1 = this.m_invMassA;
         m2 = this.m_invMassB;
         i1 = this.m_invIA;
         i2 = this.m_invIB;
         var k11 = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
         var k12 = i1 * this.m_s1 + i2 * this.m_s2;
         var k22 = i1 + i2;
         this.m_K.col1.Set(k11, k12, 0.0);
         this.m_K.col2.Set(k12, k22, 0.0);
         var impulse1 = this.m_K.Solve22(new b2Vec2(), (-C1X), (-C1Y));
         impulse.x = impulse1.x;
         impulse.y = impulse1.y;
         impulse.z = 0.0;
      }
      var PX = impulse.x * this.m_perp.x + impulse.z * this.m_axis.x;
      var PY = impulse.x * this.m_perp.y + impulse.z * this.m_axis.y;
      var L1 = impulse.x * this.m_s1 + impulse.y + impulse.z * this.m_a1;
      var L2 = impulse.x * this.m_s2 + impulse.y + impulse.z * this.m_a2;
      c1.x -= this.m_invMassA * PX;
      c1.y -= this.m_invMassA * PY;
      a1 -= this.m_invIA * L1;
      c2.x += this.m_invMassB * PX;
      c2.y += this.m_invMassB * PY;
      a2 += this.m_invIB * L2;
      bA.m_sweep.a = a1;
      bB.m_sweep.a = a2;
      bA.SynchronizeTransform();
      bB.SynchronizeTransform();
      return linearError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop;
   }
   Box2D.inherit(b2PrismaticJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2PrismaticJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2PrismaticJointDef.b2PrismaticJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.localAnchorA = new b2Vec2();
      this.localAnchorB = new b2Vec2();
      this.localAxisA = new b2Vec2();
   };
   b2PrismaticJointDef.prototype.b2PrismaticJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_prismaticJoint;
      this.localAxisA.Set(1.0, 0.0);
      this.referenceAngle = 0.0;
      this.enableLimit = false;
      this.lowerTranslation = 0.0;
      this.upperTranslation = 0.0;
      this.enableMotor = false;
      this.maxMotorForce = 0.0;
      this.motorSpeed = 0.0;
   }
   b2PrismaticJointDef.prototype.Initialize = function (bA, bB, anchor, axis) {
      this.bodyA = bA;
      this.bodyB = bB;
      this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
      this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
      this.localAxisA = this.bodyA.GetLocalVector(axis);
      this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
   }
   Box2D.inherit(b2PulleyJoint, Box2D.Dynamics.Joints.b2Joint);
   b2PulleyJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2PulleyJoint.b2PulleyJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.m_groundAnchor1 = new b2Vec2();
      this.m_groundAnchor2 = new b2Vec2();
      this.m_localAnchor1 = new b2Vec2();
      this.m_localAnchor2 = new b2Vec2();
      this.m_u1 = new b2Vec2();
      this.m_u2 = new b2Vec2();
   };
   b2PulleyJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
   }
   b2PulleyJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
   }
   b2PulleyJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * this.m_impulse * this.m_u2.x, inv_dt * this.m_impulse * this.m_u2.y);
   }
   b2PulleyJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return 0.0;
   }
   b2PulleyJoint.prototype.GetGroundAnchorA = function () {
      var a = this.m_ground.m_xf.position.Copy();
      a.Add(this.m_groundAnchor1);
      return a;
   }
   b2PulleyJoint.prototype.GetGroundAnchorB = function () {
      var a = this.m_ground.m_xf.position.Copy();
      a.Add(this.m_groundAnchor2);
      return a;
   }
   b2PulleyJoint.prototype.GetLength1 = function () {
      var p = this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
      var sX = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
      var sY = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
      var dX = p.x - sX;
      var dY = p.y - sY;
      return Math.sqrt(dX * dX + dY * dY);
   }
   b2PulleyJoint.prototype.GetLength2 = function () {
      var p = this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
      var sX = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
      var sY = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
      var dX = p.x - sX;
      var dY = p.y - sY;
      return Math.sqrt(dX * dX + dY * dY);
   }
   b2PulleyJoint.prototype.GetRatio = function () {
      return this.m_ratio;
   }
   b2PulleyJoint.prototype.b2PulleyJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      var tMat;
      var tX = 0;
      var tY = 0;
      this.m_ground = this.m_bodyA.m_world.m_groundBody;
      this.m_groundAnchor1.x = def.groundAnchorA.x - this.m_ground.m_xf.position.x;
      this.m_groundAnchor1.y = def.groundAnchorA.y - this.m_ground.m_xf.position.y;
      this.m_groundAnchor2.x = def.groundAnchorB.x - this.m_ground.m_xf.position.x;
      this.m_groundAnchor2.y = def.groundAnchorB.y - this.m_ground.m_xf.position.y;
      this.m_localAnchor1.SetV(def.localAnchorA);
      this.m_localAnchor2.SetV(def.localAnchorB);
      this.m_ratio = def.ratio;
      this.m_constant = def.lengthA + this.m_ratio * def.lengthB;
      this.m_maxLength1 = b2Math.Min(def.maxLengthA, this.m_constant - this.m_ratio * b2PulleyJoint.b2_minPulleyLength);
      this.m_maxLength2 = b2Math.Min(def.maxLengthB, (this.m_constant - b2PulleyJoint.b2_minPulleyLength) / this.m_ratio);
      this.m_impulse = 0.0;
      this.m_limitImpulse1 = 0.0;
      this.m_limitImpulse2 = 0.0;
   }
   b2PulleyJoint.prototype.InitVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var p1X = bA.m_sweep.c.x + r1X;
      var p1Y = bA.m_sweep.c.y + r1Y;
      var p2X = bB.m_sweep.c.x + r2X;
      var p2Y = bB.m_sweep.c.y + r2Y;
      var s1X = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
      var s1Y = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
      var s2X = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
      var s2Y = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
      this.m_u1.Set(p1X - s1X, p1Y - s1Y);
      this.m_u2.Set(p2X - s2X, p2Y - s2Y);
      var length1 = this.m_u1.Length();
      var length2 = this.m_u2.Length();
      if (length1 > b2Settings.b2_linearSlop) {
         this.m_u1.Multiply(1.0 / length1);
      }
      else {
         this.m_u1.SetZero();
      }
      if (length2 > b2Settings.b2_linearSlop) {
         this.m_u2.Multiply(1.0 / length2);
      }
      else {
         this.m_u2.SetZero();
      }
      var C = this.m_constant - length1 - this.m_ratio * length2;
      if (C > 0.0) {
         this.m_state = b2Joint.e_inactiveLimit;
         this.m_impulse = 0.0;
      }
      else {
         this.m_state = b2Joint.e_atUpperLimit;
      }
      if (length1 < this.m_maxLength1) {
         this.m_limitState1 = b2Joint.e_inactiveLimit;
         this.m_limitImpulse1 = 0.0;
      }
      else {
         this.m_limitState1 = b2Joint.e_atUpperLimit;
      }
      if (length2 < this.m_maxLength2) {
         this.m_limitState2 = b2Joint.e_inactiveLimit;
         this.m_limitImpulse2 = 0.0;
      }
      else {
         this.m_limitState2 = b2Joint.e_atUpperLimit;
      }
      var cr1u1 = r1X * this.m_u1.y - r1Y * this.m_u1.x;
      var cr2u2 = r2X * this.m_u2.y - r2Y * this.m_u2.x;
      this.m_limitMass1 = bA.m_invMass + bA.m_invI * cr1u1 * cr1u1;
      this.m_limitMass2 = bB.m_invMass + bB.m_invI * cr2u2 * cr2u2;
      this.m_pulleyMass = this.m_limitMass1 + this.m_ratio * this.m_ratio * this.m_limitMass2;
      this.m_limitMass1 = 1.0 / this.m_limitMass1;
      this.m_limitMass2 = 1.0 / this.m_limitMass2;
      this.m_pulleyMass = 1.0 / this.m_pulleyMass;
      if (step.warmStarting) {
         this.m_impulse *= step.dtRatio;
         this.m_limitImpulse1 *= step.dtRatio;
         this.m_limitImpulse2 *= step.dtRatio;
         var P1X = ((-this.m_impulse) - this.m_limitImpulse1) * this.m_u1.x;
         var P1Y = ((-this.m_impulse) - this.m_limitImpulse1) * this.m_u1.y;
         var P2X = ((-this.m_ratio * this.m_impulse) - this.m_limitImpulse2) * this.m_u2.x;
         var P2Y = ((-this.m_ratio * this.m_impulse) - this.m_limitImpulse2) * this.m_u2.y;
         bA.m_linearVelocity.x += bA.m_invMass * P1X;
         bA.m_linearVelocity.y += bA.m_invMass * P1Y;
         bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X);
         bB.m_linearVelocity.x += bB.m_invMass * P2X;
         bB.m_linearVelocity.y += bB.m_invMass * P2Y;
         bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X);
      }
      else {
         this.m_impulse = 0.0;
         this.m_limitImpulse1 = 0.0;
         this.m_limitImpulse2 = 0.0;
      }
   }
   b2PulleyJoint.prototype.SolveVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var v1X = 0;
      var v1Y = 0;
      var v2X = 0;
      var v2Y = 0;
      var P1X = 0;
      var P1Y = 0;
      var P2X = 0;
      var P2Y = 0;
      var Cdot = 0;
      var impulse = 0;
      var oldImpulse = 0;
      if (this.m_state == b2Joint.e_atUpperLimit) {
         v1X = bA.m_linearVelocity.x + ((-bA.m_angularVelocity * r1Y));
         v1Y = bA.m_linearVelocity.y + (bA.m_angularVelocity * r1X);
         v2X = bB.m_linearVelocity.x + ((-bB.m_angularVelocity * r2Y));
         v2Y = bB.m_linearVelocity.y + (bB.m_angularVelocity * r2X);
         Cdot = (-(this.m_u1.x * v1X + this.m_u1.y * v1Y)) - this.m_ratio * (this.m_u2.x * v2X + this.m_u2.y * v2Y);
         impulse = this.m_pulleyMass * ((-Cdot));
         oldImpulse = this.m_impulse;
         this.m_impulse = b2Math.Max(0.0, this.m_impulse + impulse);
         impulse = this.m_impulse - oldImpulse;
         P1X = (-impulse * this.m_u1.x);
         P1Y = (-impulse * this.m_u1.y);
         P2X = (-this.m_ratio * impulse * this.m_u2.x);
         P2Y = (-this.m_ratio * impulse * this.m_u2.y);
         bA.m_linearVelocity.x += bA.m_invMass * P1X;
         bA.m_linearVelocity.y += bA.m_invMass * P1Y;
         bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X);
         bB.m_linearVelocity.x += bB.m_invMass * P2X;
         bB.m_linearVelocity.y += bB.m_invMass * P2Y;
         bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X);
      }
      if (this.m_limitState1 == b2Joint.e_atUpperLimit) {
         v1X = bA.m_linearVelocity.x + ((-bA.m_angularVelocity * r1Y));
         v1Y = bA.m_linearVelocity.y + (bA.m_angularVelocity * r1X);
         Cdot = (-(this.m_u1.x * v1X + this.m_u1.y * v1Y));
         impulse = (-this.m_limitMass1 * Cdot);
         oldImpulse = this.m_limitImpulse1;
         this.m_limitImpulse1 = b2Math.Max(0.0, this.m_limitImpulse1 + impulse);
         impulse = this.m_limitImpulse1 - oldImpulse;
         P1X = (-impulse * this.m_u1.x);
         P1Y = (-impulse * this.m_u1.y);
         bA.m_linearVelocity.x += bA.m_invMass * P1X;
         bA.m_linearVelocity.y += bA.m_invMass * P1Y;
         bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X);
      }
      if (this.m_limitState2 == b2Joint.e_atUpperLimit) {
         v2X = bB.m_linearVelocity.x + ((-bB.m_angularVelocity * r2Y));
         v2Y = bB.m_linearVelocity.y + (bB.m_angularVelocity * r2X);
         Cdot = (-(this.m_u2.x * v2X + this.m_u2.y * v2Y));
         impulse = (-this.m_limitMass2 * Cdot);
         oldImpulse = this.m_limitImpulse2;
         this.m_limitImpulse2 = b2Math.Max(0.0, this.m_limitImpulse2 + impulse);
         impulse = this.m_limitImpulse2 - oldImpulse;
         P2X = (-impulse * this.m_u2.x);
         P2Y = (-impulse * this.m_u2.y);
         bB.m_linearVelocity.x += bB.m_invMass * P2X;
         bB.m_linearVelocity.y += bB.m_invMass * P2Y;
         bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X);
      }
   }
   b2PulleyJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      var s1X = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
      var s1Y = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
      var s2X = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
      var s2Y = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
      var r1X = 0;
      var r1Y = 0;
      var r2X = 0;
      var r2Y = 0;
      var p1X = 0;
      var p1Y = 0;
      var p2X = 0;
      var p2Y = 0;
      var length1 = 0;
      var length2 = 0;
      var C = 0;
      var impulse = 0;
      var oldImpulse = 0;
      var oldLimitPositionImpulse = 0;
      var tX = 0;
      var linearError = 0.0;
      if (this.m_state == b2Joint.e_atUpperLimit) {
         tMat = bA.m_xf.R;
         r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
         r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
         r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
         r1X = tX;
         tMat = bB.m_xf.R;
         r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
         r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
         r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
         r2X = tX;
         p1X = bA.m_sweep.c.x + r1X;
         p1Y = bA.m_sweep.c.y + r1Y;
         p2X = bB.m_sweep.c.x + r2X;
         p2Y = bB.m_sweep.c.y + r2Y;
         this.m_u1.Set(p1X - s1X, p1Y - s1Y);
         this.m_u2.Set(p2X - s2X, p2Y - s2Y);
         length1 = this.m_u1.Length();
         length2 = this.m_u2.Length();
         if (length1 > b2Settings.b2_linearSlop) {
            this.m_u1.Multiply(1.0 / length1);
         }
         else {
            this.m_u1.SetZero();
         }
         if (length2 > b2Settings.b2_linearSlop) {
            this.m_u2.Multiply(1.0 / length2);
         }
         else {
            this.m_u2.SetZero();
         }
         C = this.m_constant - length1 - this.m_ratio * length2;
         linearError = b2Math.Max(linearError, (-C));
         C = b2Math.Clamp(C + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
         impulse = (-this.m_pulleyMass * C);
         p1X = (-impulse * this.m_u1.x);
         p1Y = (-impulse * this.m_u1.y);
         p2X = (-this.m_ratio * impulse * this.m_u2.x);
         p2Y = (-this.m_ratio * impulse * this.m_u2.y);
         bA.m_sweep.c.x += bA.m_invMass * p1X;
         bA.m_sweep.c.y += bA.m_invMass * p1Y;
         bA.m_sweep.a += bA.m_invI * (r1X * p1Y - r1Y * p1X);
         bB.m_sweep.c.x += bB.m_invMass * p2X;
         bB.m_sweep.c.y += bB.m_invMass * p2Y;
         bB.m_sweep.a += bB.m_invI * (r2X * p2Y - r2Y * p2X);
         bA.SynchronizeTransform();
         bB.SynchronizeTransform();
      }
      if (this.m_limitState1 == b2Joint.e_atUpperLimit) {
         tMat = bA.m_xf.R;
         r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
         r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
         r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
         r1X = tX;
         p1X = bA.m_sweep.c.x + r1X;
         p1Y = bA.m_sweep.c.y + r1Y;
         this.m_u1.Set(p1X - s1X, p1Y - s1Y);
         length1 = this.m_u1.Length();
         if (length1 > b2Settings.b2_linearSlop) {
            this.m_u1.x *= 1.0 / length1;
            this.m_u1.y *= 1.0 / length1;
         }
         else {
            this.m_u1.SetZero();
         }
         C = this.m_maxLength1 - length1;
         linearError = b2Math.Max(linearError, (-C));
         C = b2Math.Clamp(C + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
         impulse = (-this.m_limitMass1 * C);
         p1X = (-impulse * this.m_u1.x);
         p1Y = (-impulse * this.m_u1.y);
         bA.m_sweep.c.x += bA.m_invMass * p1X;
         bA.m_sweep.c.y += bA.m_invMass * p1Y;
         bA.m_sweep.a += bA.m_invI * (r1X * p1Y - r1Y * p1X);
         bA.SynchronizeTransform();
      }
      if (this.m_limitState2 == b2Joint.e_atUpperLimit) {
         tMat = bB.m_xf.R;
         r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
         r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
         r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
         r2X = tX;
         p2X = bB.m_sweep.c.x + r2X;
         p2Y = bB.m_sweep.c.y + r2Y;
         this.m_u2.Set(p2X - s2X, p2Y - s2Y);
         length2 = this.m_u2.Length();
         if (length2 > b2Settings.b2_linearSlop) {
            this.m_u2.x *= 1.0 / length2;
            this.m_u2.y *= 1.0 / length2;
         }
         else {
            this.m_u2.SetZero();
         }
         C = this.m_maxLength2 - length2;
         linearError = b2Math.Max(linearError, (-C));
         C = b2Math.Clamp(C + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
         impulse = (-this.m_limitMass2 * C);
         p2X = (-impulse * this.m_u2.x);
         p2Y = (-impulse * this.m_u2.y);
         bB.m_sweep.c.x += bB.m_invMass * p2X;
         bB.m_sweep.c.y += bB.m_invMass * p2Y;
         bB.m_sweep.a += bB.m_invI * (r2X * p2Y - r2Y * p2X);
         bB.SynchronizeTransform();
      }
      return linearError < b2Settings.b2_linearSlop;
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.Joints.b2PulleyJoint.b2_minPulleyLength = 2.0;
   });
   Box2D.inherit(b2PulleyJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2PulleyJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2PulleyJointDef.b2PulleyJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.groundAnchorA = new b2Vec2();
      this.groundAnchorB = new b2Vec2();
      this.localAnchorA = new b2Vec2();
      this.localAnchorB = new b2Vec2();
   };
   b2PulleyJointDef.prototype.b2PulleyJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_pulleyJoint;
      this.groundAnchorA.Set((-1.0), 1.0);
      this.groundAnchorB.Set(1.0, 1.0);
      this.localAnchorA.Set((-1.0), 0.0);
      this.localAnchorB.Set(1.0, 0.0);
      this.lengthA = 0.0;
      this.maxLengthA = 0.0;
      this.lengthB = 0.0;
      this.maxLengthB = 0.0;
      this.ratio = 1.0;
      this.collideConnected = true;
   }
   b2PulleyJointDef.prototype.Initialize = function (bA, bB, gaA, gaB, anchorA, anchorB, r) {
      if (r === undefined) r = 0;
      this.bodyA = bA;
      this.bodyB = bB;
      this.groundAnchorA.SetV(gaA);
      this.groundAnchorB.SetV(gaB);
      this.localAnchorA = this.bodyA.GetLocalPoint(anchorA);
      this.localAnchorB = this.bodyB.GetLocalPoint(anchorB);
      var d1X = anchorA.x - gaA.x;
      var d1Y = anchorA.y - gaA.y;
      this.lengthA = Math.sqrt(d1X * d1X + d1Y * d1Y);
      var d2X = anchorB.x - gaB.x;
      var d2Y = anchorB.y - gaB.y;
      this.lengthB = Math.sqrt(d2X * d2X + d2Y * d2Y);
      this.ratio = r;
      var C = this.lengthA + this.ratio * this.lengthB;
      this.maxLengthA = C - this.ratio * b2PulleyJoint.b2_minPulleyLength;
      this.maxLengthB = (C - b2PulleyJoint.b2_minPulleyLength) / this.ratio;
   }
   Box2D.inherit(b2RevoluteJoint, Box2D.Dynamics.Joints.b2Joint);
   b2RevoluteJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2RevoluteJoint.b2RevoluteJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.K = new b2Mat22();
      this.K1 = new b2Mat22();
      this.K2 = new b2Mat22();
      this.K3 = new b2Mat22();
      this.impulse3 = new b2Vec3();
      this.impulse2 = new b2Vec2();
      this.reduced = new b2Vec2();
      this.m_localAnchor1 = new b2Vec2();
      this.m_localAnchor2 = new b2Vec2();
      this.m_impulse = new b2Vec3();
      this.m_mass = new b2Mat33();
   };
   b2RevoluteJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
   }
   b2RevoluteJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
   }
   b2RevoluteJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y);
   }
   b2RevoluteJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return inv_dt * this.m_impulse.z;
   }
   b2RevoluteJoint.prototype.GetJointAngle = function () {
      return this.m_bodyB.m_sweep.a - this.m_bodyA.m_sweep.a - this.m_referenceAngle;
   }
   b2RevoluteJoint.prototype.GetJointSpeed = function () {
      return this.m_bodyB.m_angularVelocity - this.m_bodyA.m_angularVelocity;
   }
   b2RevoluteJoint.prototype.IsLimitEnabled = function () {
      return this.m_enableLimit;
   }
   b2RevoluteJoint.prototype.EnableLimit = function (flag) {
      this.m_enableLimit = flag;
   }
   b2RevoluteJoint.prototype.GetLowerLimit = function () {
      return this.m_lowerAngle;
   }
   b2RevoluteJoint.prototype.GetUpperLimit = function () {
      return this.m_upperAngle;
   }
   b2RevoluteJoint.prototype.SetLimits = function (lower, upper) {
      if (lower === undefined) lower = 0;
      if (upper === undefined) upper = 0;
      this.m_lowerAngle = lower;
      this.m_upperAngle = upper;
   }
   b2RevoluteJoint.prototype.IsMotorEnabled = function () {
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      return this.m_enableMotor;
   }
   b2RevoluteJoint.prototype.EnableMotor = function (flag) {
      this.m_enableMotor = flag;
   }
   b2RevoluteJoint.prototype.SetMotorSpeed = function (speed) {
      if (speed === undefined) speed = 0;
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_motorSpeed = speed;
   }
   b2RevoluteJoint.prototype.GetMotorSpeed = function () {
      return this.m_motorSpeed;
   }
   b2RevoluteJoint.prototype.SetMaxMotorTorque = function (torque) {
      if (torque === undefined) torque = 0;
      this.m_maxMotorTorque = torque;
   }
   b2RevoluteJoint.prototype.GetMotorTorque = function () {
      return this.m_maxMotorTorque;
   }
   b2RevoluteJoint.prototype.b2RevoluteJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      this.m_localAnchor1.SetV(def.localAnchorA);
      this.m_localAnchor2.SetV(def.localAnchorB);
      this.m_referenceAngle = def.referenceAngle;
      this.m_impulse.SetZero();
      this.m_motorImpulse = 0.0;
      this.m_lowerAngle = def.lowerAngle;
      this.m_upperAngle = def.upperAngle;
      this.m_maxMotorTorque = def.maxMotorTorque;
      this.m_motorSpeed = def.motorSpeed;
      this.m_enableLimit = def.enableLimit;
      this.m_enableMotor = def.enableMotor;
      this.m_limitState = b2Joint.e_inactiveLimit;
   }
   b2RevoluteJoint.prototype.InitVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      var tX = 0;
      if (this.m_enableMotor || this.m_enableLimit) {}
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var m1 = bA.m_invMass;
      var m2 = bB.m_invMass;
      var i1 = bA.m_invI;
      var i2 = bB.m_invI;
      this.m_mass.col1.x = m1 + m2 + r1Y * r1Y * i1 + r2Y * r2Y * i2;
      this.m_mass.col2.x = (-r1Y * r1X * i1) - r2Y * r2X * i2;
      this.m_mass.col3.x = (-r1Y * i1) - r2Y * i2;
      this.m_mass.col1.y = this.m_mass.col2.x;
      this.m_mass.col2.y = m1 + m2 + r1X * r1X * i1 + r2X * r2X * i2;
      this.m_mass.col3.y = r1X * i1 + r2X * i2;
      this.m_mass.col1.z = this.m_mass.col3.x;
      this.m_mass.col2.z = this.m_mass.col3.y;
      this.m_mass.col3.z = i1 + i2;
      this.m_motorMass = 1.0 / (i1 + i2);
      if (this.m_enableMotor == false) {
         this.m_motorImpulse = 0.0;
      }
      if (this.m_enableLimit) {
         var jointAngle = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
         if (b2Math.Abs(this.m_upperAngle - this.m_lowerAngle) < 2.0 * b2Settings.b2_angularSlop) {
            this.m_limitState = b2Joint.e_equalLimits;
         }
         else if (jointAngle <= this.m_lowerAngle) {
            if (this.m_limitState != b2Joint.e_atLowerLimit) {
               this.m_impulse.z = 0.0;
            }
            this.m_limitState = b2Joint.e_atLowerLimit;
         }
         else if (jointAngle >= this.m_upperAngle) {
            if (this.m_limitState != b2Joint.e_atUpperLimit) {
               this.m_impulse.z = 0.0;
            }
            this.m_limitState = b2Joint.e_atUpperLimit;
         }
         else {
            this.m_limitState = b2Joint.e_inactiveLimit;
            this.m_impulse.z = 0.0;
         }
      }
      else {
         this.m_limitState = b2Joint.e_inactiveLimit;
      }
      if (step.warmStarting) {
         this.m_impulse.x *= step.dtRatio;
         this.m_impulse.y *= step.dtRatio;
         this.m_motorImpulse *= step.dtRatio;
         var PX = this.m_impulse.x;
         var PY = this.m_impulse.y;
         bA.m_linearVelocity.x -= m1 * PX;
         bA.m_linearVelocity.y -= m1 * PY;
         bA.m_angularVelocity -= i1 * ((r1X * PY - r1Y * PX) + this.m_motorImpulse + this.m_impulse.z);
         bB.m_linearVelocity.x += m2 * PX;
         bB.m_linearVelocity.y += m2 * PY;
         bB.m_angularVelocity += i2 * ((r2X * PY - r2Y * PX) + this.m_motorImpulse + this.m_impulse.z);
      }
      else {
         this.m_impulse.SetZero();
         this.m_motorImpulse = 0.0;
      }
   }
   b2RevoluteJoint.prototype.SolveVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      var tX = 0;
      var newImpulse = 0;
      var r1X = 0;
      var r1Y = 0;
      var r2X = 0;
      var r2Y = 0;
      var v1 = bA.m_linearVelocity;
      var w1 = bA.m_angularVelocity;
      var v2 = bB.m_linearVelocity;
      var w2 = bB.m_angularVelocity;
      var m1 = bA.m_invMass;
      var m2 = bB.m_invMass;
      var i1 = bA.m_invI;
      var i2 = bB.m_invI;
      if (this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
         var Cdot = w2 - w1 - this.m_motorSpeed;
         var impulse = this.m_motorMass * ((-Cdot));
         var oldImpulse = this.m_motorImpulse;
         var maxImpulse = step.dt * this.m_maxMotorTorque;
         this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, (-maxImpulse), maxImpulse);
         impulse = this.m_motorImpulse - oldImpulse;
         w1 -= i1 * impulse;
         w2 += i2 * impulse;
      }
      if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
         tMat = bA.m_xf.R;
         r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
         r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
         r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
         r1X = tX;
         tMat = bB.m_xf.R;
         r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
         r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
         r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
         r2X = tX;
         var Cdot1X = v2.x + ((-w2 * r2Y)) - v1.x - ((-w1 * r1Y));
         var Cdot1Y = v2.y + (w2 * r2X) - v1.y - (w1 * r1X);
         var Cdot2 = w2 - w1;
         this.m_mass.Solve33(this.impulse3, (-Cdot1X), (-Cdot1Y), (-Cdot2));
         if (this.m_limitState == b2Joint.e_equalLimits) {
            this.m_impulse.Add(this.impulse3);
         }
         else if (this.m_limitState == b2Joint.e_atLowerLimit) {
            newImpulse = this.m_impulse.z + this.impulse3.z;
            if (newImpulse < 0.0) {
               this.m_mass.Solve22(this.reduced, (-Cdot1X), (-Cdot1Y));
               this.impulse3.x = this.reduced.x;
               this.impulse3.y = this.reduced.y;
               this.impulse3.z = (-this.m_impulse.z);
               this.m_impulse.x += this.reduced.x;
               this.m_impulse.y += this.reduced.y;
               this.m_impulse.z = 0.0;
            }
         }
         else if (this.m_limitState == b2Joint.e_atUpperLimit) {
            newImpulse = this.m_impulse.z + this.impulse3.z;
            if (newImpulse > 0.0) {
               this.m_mass.Solve22(this.reduced, (-Cdot1X), (-Cdot1Y));
               this.impulse3.x = this.reduced.x;
               this.impulse3.y = this.reduced.y;
               this.impulse3.z = (-this.m_impulse.z);
               this.m_impulse.x += this.reduced.x;
               this.m_impulse.y += this.reduced.y;
               this.m_impulse.z = 0.0;
            }
         }
         v1.x -= m1 * this.impulse3.x;
         v1.y -= m1 * this.impulse3.y;
         w1 -= i1 * (r1X * this.impulse3.y - r1Y * this.impulse3.x + this.impulse3.z);
         v2.x += m2 * this.impulse3.x;
         v2.y += m2 * this.impulse3.y;
         w2 += i2 * (r2X * this.impulse3.y - r2Y * this.impulse3.x + this.impulse3.z);
      }
      else {
         tMat = bA.m_xf.R;
         r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
         r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
         r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
         r1X = tX;
         tMat = bB.m_xf.R;
         r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
         r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
         r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
         r2X = tX;
         var CdotX = v2.x + ((-w2 * r2Y)) - v1.x - ((-w1 * r1Y));
         var CdotY = v2.y + (w2 * r2X) - v1.y - (w1 * r1X);
         this.m_mass.Solve22(this.impulse2, (-CdotX), (-CdotY));
         this.m_impulse.x += this.impulse2.x;
         this.m_impulse.y += this.impulse2.y;
         v1.x -= m1 * this.impulse2.x;
         v1.y -= m1 * this.impulse2.y;
         w1 -= i1 * (r1X * this.impulse2.y - r1Y * this.impulse2.x);
         v2.x += m2 * this.impulse2.x;
         v2.y += m2 * this.impulse2.y;
         w2 += i2 * (r2X * this.impulse2.y - r2Y * this.impulse2.x);
      }
      bA.m_linearVelocity.SetV(v1);
      bA.m_angularVelocity = w1;
      bB.m_linearVelocity.SetV(v2);
      bB.m_angularVelocity = w2;
   }
   b2RevoluteJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var oldLimitImpulse = 0;
      var C = 0;
      var tMat;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var angularError = 0.0;
      var positionError = 0.0;
      var tX = 0;
      var impulseX = 0;
      var impulseY = 0;
      if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
         var angle = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
         var limitImpulse = 0.0;
         if (this.m_limitState == b2Joint.e_equalLimits) {
            C = b2Math.Clamp(angle - this.m_lowerAngle, (-b2Settings.b2_maxAngularCorrection), b2Settings.b2_maxAngularCorrection);
            limitImpulse = (-this.m_motorMass * C);
            angularError = b2Math.Abs(C);
         }
         else if (this.m_limitState == b2Joint.e_atLowerLimit) {
            C = angle - this.m_lowerAngle;
            angularError = (-C);
            C = b2Math.Clamp(C + b2Settings.b2_angularSlop, (-b2Settings.b2_maxAngularCorrection), 0.0);
            limitImpulse = (-this.m_motorMass * C);
         }
         else if (this.m_limitState == b2Joint.e_atUpperLimit) {
            C = angle - this.m_upperAngle;
            angularError = C;
            C = b2Math.Clamp(C - b2Settings.b2_angularSlop, 0.0, b2Settings.b2_maxAngularCorrection);
            limitImpulse = (-this.m_motorMass * C);
         }
         bA.m_sweep.a -= bA.m_invI * limitImpulse;
         bB.m_sweep.a += bB.m_invI * limitImpulse;
         bA.SynchronizeTransform();
         bB.SynchronizeTransform();
      } {
         tMat = bA.m_xf.R;
         var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
         var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
         r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
         r1X = tX;
         tMat = bB.m_xf.R;
         var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
         var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
         r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
         r2X = tX;
         var CX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
         var CY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
         var CLengthSquared = CX * CX + CY * CY;
         var CLength = Math.sqrt(CLengthSquared);
         positionError = CLength;
         var invMass1 = bA.m_invMass;
         var invMass2 = bB.m_invMass;
         var invI1 = bA.m_invI;
         var invI2 = bB.m_invI;
         var k_allowedStretch = 10.0 * b2Settings.b2_linearSlop;
         if (CLengthSquared > k_allowedStretch * k_allowedStretch) {
            var uX = CX / CLength;
            var uY = CY / CLength;
            var k = invMass1 + invMass2;
            var m = 1.0 / k;
            impulseX = m * ((-CX));
            impulseY = m * ((-CY));
            var k_beta = 0.5;
            bA.m_sweep.c.x -= k_beta * invMass1 * impulseX;
            bA.m_sweep.c.y -= k_beta * invMass1 * impulseY;
            bB.m_sweep.c.x += k_beta * invMass2 * impulseX;
            bB.m_sweep.c.y += k_beta * invMass2 * impulseY;
            CX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
            CY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
         }
         this.K1.col1.x = invMass1 + invMass2;
         this.K1.col2.x = 0.0;
         this.K1.col1.y = 0.0;
         this.K1.col2.y = invMass1 + invMass2;
         this.K2.col1.x = invI1 * r1Y * r1Y;
         this.K2.col2.x = (-invI1 * r1X * r1Y);
         this.K2.col1.y = (-invI1 * r1X * r1Y);
         this.K2.col2.y = invI1 * r1X * r1X;
         this.K3.col1.x = invI2 * r2Y * r2Y;
         this.K3.col2.x = (-invI2 * r2X * r2Y);
         this.K3.col1.y = (-invI2 * r2X * r2Y);
         this.K3.col2.y = invI2 * r2X * r2X;
         this.K.SetM(this.K1);
         this.K.AddM(this.K2);
         this.K.AddM(this.K3);
         this.K.Solve(b2RevoluteJoint.tImpulse, (-CX), (-CY));
         impulseX = b2RevoluteJoint.tImpulse.x;
         impulseY = b2RevoluteJoint.tImpulse.y;
         bA.m_sweep.c.x -= bA.m_invMass * impulseX;
         bA.m_sweep.c.y -= bA.m_invMass * impulseY;
         bA.m_sweep.a -= bA.m_invI * (r1X * impulseY - r1Y * impulseX);
         bB.m_sweep.c.x += bB.m_invMass * impulseX;
         bB.m_sweep.c.y += bB.m_invMass * impulseY;
         bB.m_sweep.a += bB.m_invI * (r2X * impulseY - r2Y * impulseX);
         bA.SynchronizeTransform();
         bB.SynchronizeTransform();
      }
      return positionError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop;
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.Joints.b2RevoluteJoint.tImpulse = new b2Vec2();
   });
   Box2D.inherit(b2RevoluteJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2RevoluteJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2RevoluteJointDef.b2RevoluteJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.localAnchorA = new b2Vec2();
      this.localAnchorB = new b2Vec2();
   };
   b2RevoluteJointDef.prototype.b2RevoluteJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_revoluteJoint;
      this.localAnchorA.Set(0.0, 0.0);
      this.localAnchorB.Set(0.0, 0.0);
      this.referenceAngle = 0.0;
      this.lowerAngle = 0.0;
      this.upperAngle = 0.0;
      this.maxMotorTorque = 0.0;
      this.motorSpeed = 0.0;
      this.enableLimit = false;
      this.enableMotor = false;
   }
   b2RevoluteJointDef.prototype.Initialize = function (bA, bB, anchor) {
      this.bodyA = bA;
      this.bodyB = bB;
      this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
      this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
      this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
   }
   Box2D.inherit(b2WeldJoint, Box2D.Dynamics.Joints.b2Joint);
   b2WeldJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2WeldJoint.b2WeldJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.m_localAnchorA = new b2Vec2();
      this.m_localAnchorB = new b2Vec2();
      this.m_impulse = new b2Vec3();
      this.m_mass = new b2Mat33();
   };
   b2WeldJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
   }
   b2WeldJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
   }
   b2WeldJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y);
   }
   b2WeldJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return inv_dt * this.m_impulse.z;
   }
   b2WeldJoint.prototype.b2WeldJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      this.m_localAnchorA.SetV(def.localAnchorA);
      this.m_localAnchorB.SetV(def.localAnchorB);
      this.m_referenceAngle = def.referenceAngle;
      this.m_impulse.SetZero();
      this.m_mass = new b2Mat33();
   }
   b2WeldJoint.prototype.InitVelocityConstraints = function (step) {
      var tMat;
      var tX = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      tMat = bA.m_xf.R;
      var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
      var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
      rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
      rAX = tX;
      tMat = bB.m_xf.R;
      var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
      var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
      rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
      rBX = tX;
      var mA = bA.m_invMass;
      var mB = bB.m_invMass;
      var iA = bA.m_invI;
      var iB = bB.m_invI;
      this.m_mass.col1.x = mA + mB + rAY * rAY * iA + rBY * rBY * iB;
      this.m_mass.col2.x = (-rAY * rAX * iA) - rBY * rBX * iB;
      this.m_mass.col3.x = (-rAY * iA) - rBY * iB;
      this.m_mass.col1.y = this.m_mass.col2.x;
      this.m_mass.col2.y = mA + mB + rAX * rAX * iA + rBX * rBX * iB;
      this.m_mass.col3.y = rAX * iA + rBX * iB;
      this.m_mass.col1.z = this.m_mass.col3.x;
      this.m_mass.col2.z = this.m_mass.col3.y;
      this.m_mass.col3.z = iA + iB;
      if (step.warmStarting) {
         this.m_impulse.x *= step.dtRatio;
         this.m_impulse.y *= step.dtRatio;
         this.m_impulse.z *= step.dtRatio;
         bA.m_linearVelocity.x -= mA * this.m_impulse.x;
         bA.m_linearVelocity.y -= mA * this.m_impulse.y;
         bA.m_angularVelocity -= iA * (rAX * this.m_impulse.y - rAY * this.m_impulse.x + this.m_impulse.z);
         bB.m_linearVelocity.x += mB * this.m_impulse.x;
         bB.m_linearVelocity.y += mB * this.m_impulse.y;
         bB.m_angularVelocity += iB * (rBX * this.m_impulse.y - rBY * this.m_impulse.x + this.m_impulse.z);
      }
      else {
         this.m_impulse.SetZero();
      }
   }
   b2WeldJoint.prototype.SolveVelocityConstraints = function (step) {
      var tMat;
      var tX = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var vA = bA.m_linearVelocity;
      var wA = bA.m_angularVelocity;
      var vB = bB.m_linearVelocity;
      var wB = bB.m_angularVelocity;
      var mA = bA.m_invMass;
      var mB = bB.m_invMass;
      var iA = bA.m_invI;
      var iB = bB.m_invI;
      tMat = bA.m_xf.R;
      var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
      var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
      rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
      rAX = tX;
      tMat = bB.m_xf.R;
      var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
      var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
      rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
      rBX = tX;
      var Cdot1X = vB.x - wB * rBY - vA.x + wA * rAY;
      var Cdot1Y = vB.y + wB * rBX - vA.y - wA * rAX;
      var Cdot2 = wB - wA;
      var impulse = new b2Vec3();
      this.m_mass.Solve33(impulse, (-Cdot1X), (-Cdot1Y), (-Cdot2));
      this.m_impulse.Add(impulse);
      vA.x -= mA * impulse.x;
      vA.y -= mA * impulse.y;
      wA -= iA * (rAX * impulse.y - rAY * impulse.x + impulse.z);
      vB.x += mB * impulse.x;
      vB.y += mB * impulse.y;
      wB += iB * (rBX * impulse.y - rBY * impulse.x + impulse.z);
      bA.m_angularVelocity = wA;
      bB.m_angularVelocity = wB;
   }
   b2WeldJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var tMat;
      var tX = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      tMat = bA.m_xf.R;
      var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
      var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
      rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
      rAX = tX;
      tMat = bB.m_xf.R;
      var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
      var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
      rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
      rBX = tX;
      var mA = bA.m_invMass;
      var mB = bB.m_invMass;
      var iA = bA.m_invI;
      var iB = bB.m_invI;
      var C1X = bB.m_sweep.c.x + rBX - bA.m_sweep.c.x - rAX;
      var C1Y = bB.m_sweep.c.y + rBY - bA.m_sweep.c.y - rAY;
      var C2 = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
      var k_allowedStretch = 10.0 * b2Settings.b2_linearSlop;
      var positionError = Math.sqrt(C1X * C1X + C1Y * C1Y);
      var angularError = b2Math.Abs(C2);
      if (positionError > k_allowedStretch) {
         iA *= 1.0;
         iB *= 1.0;
      }
      this.m_mass.col1.x = mA + mB + rAY * rAY * iA + rBY * rBY * iB;
      this.m_mass.col2.x = (-rAY * rAX * iA) - rBY * rBX * iB;
      this.m_mass.col3.x = (-rAY * iA) - rBY * iB;
      this.m_mass.col1.y = this.m_mass.col2.x;
      this.m_mass.col2.y = mA + mB + rAX * rAX * iA + rBX * rBX * iB;
      this.m_mass.col3.y = rAX * iA + rBX * iB;
      this.m_mass.col1.z = this.m_mass.col3.x;
      this.m_mass.col2.z = this.m_mass.col3.y;
      this.m_mass.col3.z = iA + iB;
      var impulse = new b2Vec3();
      this.m_mass.Solve33(impulse, (-C1X), (-C1Y), (-C2));
      bA.m_sweep.c.x -= mA * impulse.x;
      bA.m_sweep.c.y -= mA * impulse.y;
      bA.m_sweep.a -= iA * (rAX * impulse.y - rAY * impulse.x + impulse.z);
      bB.m_sweep.c.x += mB * impulse.x;
      bB.m_sweep.c.y += mB * impulse.y;
      bB.m_sweep.a += iB * (rBX * impulse.y - rBY * impulse.x + impulse.z);
      bA.SynchronizeTransform();
      bB.SynchronizeTransform();
      return positionError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop;
   }
   Box2D.inherit(b2WeldJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2WeldJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2WeldJointDef.b2WeldJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.localAnchorA = new b2Vec2();
      this.localAnchorB = new b2Vec2();
   };
   b2WeldJointDef.prototype.b2WeldJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_weldJoint;
      this.referenceAngle = 0.0;
   }
   b2WeldJointDef.prototype.Initialize = function (bA, bB, anchor) {
      this.bodyA = bA;
      this.bodyB = bB;
      this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchor));
      this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchor));
      this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
   }
})();
(function () {
   var b2DebugDraw = Box2D.Dynamics.b2DebugDraw;
   b2DebugDraw.b2DebugDraw = function () {
      this.m_drawScale = 1.0;
      this.m_lineThickness = 1.0;
      this.m_alpha = 1.0;
      this.m_fillAlpha = 1.0;
      this.m_xformScale = 1.0;
      var __this = this;
      //#WORKAROUND
      this.m_sprite = {
         graphics: {
            clear: function () {
               __this.m_ctx.clearRect(0, 0, __this.m_ctx.canvas.width, __this.m_ctx.canvas.height)
            }
         }
      };
   };
   b2DebugDraw.prototype._color = function (color, alpha) {
      return "rgba(" + ((color & 0xFF0000) >> 16) + "," + ((color & 0xFF00) >> 8) + "," + (color & 0xFF) + "," + alpha + ")";
   };
   b2DebugDraw.prototype.b2DebugDraw = function () {
      this.m_drawFlags = 0;
   };
   b2DebugDraw.prototype.SetFlags = function (flags) {
      if (flags === undefined) flags = 0;
      this.m_drawFlags = flags;
   };
   b2DebugDraw.prototype.GetFlags = function () {
      return this.m_drawFlags;
   };
   b2DebugDraw.prototype.AppendFlags = function (flags) {
      if (flags === undefined) flags = 0;
      this.m_drawFlags |= flags;
   };
   b2DebugDraw.prototype.ClearFlags = function (flags) {
      if (flags === undefined) flags = 0;
      this.m_drawFlags &= ~flags;
   };
   b2DebugDraw.prototype.SetSprite = function (sprite) {
      this.m_ctx = sprite;
   };
   b2DebugDraw.prototype.GetSprite = function () {
      return this.m_ctx;
   };
   b2DebugDraw.prototype.SetDrawScale = function (drawScale) {
      if (drawScale === undefined) drawScale = 0;
      this.m_drawScale = drawScale;
   };
   b2DebugDraw.prototype.GetDrawScale = function () {
      return this.m_drawScale;
   };
   b2DebugDraw.prototype.SetLineThickness = function (lineThickness) {
      if (lineThickness === undefined) lineThickness = 0;
      this.m_lineThickness = lineThickness;
      this.m_ctx.strokeWidth = lineThickness;
   };
   b2DebugDraw.prototype.GetLineThickness = function () {
      return this.m_lineThickness;
   };
   b2DebugDraw.prototype.SetAlpha = function (alpha) {
      if (alpha === undefined) alpha = 0;
      this.m_alpha = alpha;
   };
   b2DebugDraw.prototype.GetAlpha = function () {
      return this.m_alpha;
   };
   b2DebugDraw.prototype.SetFillAlpha = function (alpha) {
      if (alpha === undefined) alpha = 0;
      this.m_fillAlpha = alpha;
   };
   b2DebugDraw.prototype.GetFillAlpha = function () {
      return this.m_fillAlpha;
   };
   b2DebugDraw.prototype.SetXFormScale = function (xformScale) {
      if (xformScale === undefined) xformScale = 0;
      this.m_xformScale = xformScale;
   };
   b2DebugDraw.prototype.GetXFormScale = function () {
      return this.m_xformScale;
   };
   b2DebugDraw.prototype.DrawPolygon = function (vertices, vertexCount, color) {
      if (!vertexCount) return;
      var s = this.m_ctx;
      var drawScale = this.m_drawScale;
      s.beginPath();
      s.strokeStyle = this._color(color.color, this.m_alpha);
      s.moveTo(vertices[0].x * drawScale, vertices[0].y * drawScale);
      for (var i = 1; i < vertexCount; i++) {
         s.lineTo(vertices[i].x * drawScale, vertices[i].y * drawScale);
      }
      s.lineTo(vertices[0].x * drawScale, vertices[0].y * drawScale);
      s.closePath();
      s.stroke();
   };
   b2DebugDraw.prototype.DrawSolidPolygon = function (vertices, vertexCount, color) {
      if (!vertexCount) return;
      var s = this.m_ctx;
      var drawScale = this.m_drawScale;
      s.beginPath();
      s.strokeStyle = this._color(color.color, this.m_alpha);
      s.fillStyle = this._color(color.color, this.m_fillAlpha);
      s.moveTo(vertices[0].x * drawScale, vertices[0].y * drawScale);
      for (var i = 1; i < vertexCount; i++) {
         s.lineTo(vertices[i].x * drawScale, vertices[i].y * drawScale);
      }
      s.lineTo(vertices[0].x * drawScale, vertices[0].y * drawScale);
      s.closePath();
      s.fill();
      s.stroke();
   };
   b2DebugDraw.prototype.DrawCircle = function (center, radius, color) {
      if (!radius) return;
      var s = this.m_ctx;
      var drawScale = this.m_drawScale;
      s.beginPath();
      s.strokeStyle = this._color(color.color, this.m_alpha);
      s.arc(center.x * drawScale, center.y * drawScale, radius * drawScale, 0, Math.PI * 2, true);
      s.closePath();
      s.stroke();
   };
   b2DebugDraw.prototype.DrawSolidCircle = function (center, radius, axis, color) {
      if (!radius) return;
      var s = this.m_ctx,
         drawScale = this.m_drawScale,
         cx = center.x * drawScale,
         cy = center.y * drawScale;
      s.moveTo(0, 0);
      s.beginPath();
      s.strokeStyle = this._color(color.color, this.m_alpha);
      s.fillStyle = this._color(color.color, this.m_fillAlpha);
      s.arc(cx, cy, radius * drawScale, 0, Math.PI * 2, true);
      s.moveTo(cx, cy);
      s.lineTo((center.x + axis.x * radius) * drawScale, (center.y + axis.y * radius) * drawScale);
      s.closePath();
      s.fill();
      s.stroke();
   };
   b2DebugDraw.prototype.DrawSegment = function (p1, p2, color) {
      var s = this.m_ctx,
         drawScale = this.m_drawScale;
      s.strokeStyle = this._color(color.color, this.m_alpha);
      s.beginPath();
      s.moveTo(p1.x * drawScale, p1.y * drawScale);
      s.lineTo(p2.x * drawScale, p2.y * drawScale);
      s.closePath();
      s.stroke();
   };
   b2DebugDraw.prototype.DrawTransform = function (xf) {
      var s = this.m_ctx,
         drawScale = this.m_drawScale;
      s.beginPath();
      s.strokeStyle = this._color(0xff0000, this.m_alpha);
      s.moveTo(xf.position.x * drawScale, xf.position.y * drawScale);
      s.lineTo((xf.position.x + this.m_xformScale * xf.R.col1.x) * drawScale, (xf.position.y + this.m_xformScale * xf.R.col1.y) * drawScale);

      s.strokeStyle = this._color(0xff00, this.m_alpha);
      s.moveTo(xf.position.x * drawScale, xf.position.y * drawScale);
      s.lineTo((xf.position.x + this.m_xformScale * xf.R.col2.x) * drawScale, (xf.position.y + this.m_xformScale * xf.R.col2.y) * drawScale);
      s.closePath();
      s.stroke();
   };
})(); //post-definitions
var i;
for (i = 0; i < Box2D.postDefs.length; ++i) Box2D.postDefs[i]();
delete Box2D.postDefs;


		return {
			Common : {
				Math : {
					b2Vec2 : Box2D.Common.Math.b2Vec2,
					createB2Vec2 : function( x, y ) {
						return new Box2D.Common.Math.b2Vec2( x, y )
					}
				}
			},
			Dynamics : {
				b2Body : Box2D.Dynamics.b2Body,
				createB2Body : function() {
					return new Box2D.Dynamics.b2Body()
				},
				b2BodyDef : Box2D.Dynamics.b2BodyDef,
				createB2BodyDef : function() {
					return new Box2D.Dynamics.b2BodyDef()
				},
				b2FilterData : Box2D.Dynamics.b2FilterData,
				createB2FilterData : function() {
					return new Box2D.Dynamics.b2FilterData()
				},
				b2ContactListener : Box2D.Dynamics.b2ContactListener,
				createB2ContactListener : function( beginContact, endContact, preSolve, postSolve ) {
					var contactListener = new Box2D.Dynamics.b2ContactListener()

					if( beginContact ) contactListener.BeginContact = beginContact
					if( endContact )   contactListener.EndContact   = endContact
					if( preSolve )     contactListener.PreSolve     = preSolve
					if( postSolve )    contactListener.PostSolve    = postSolve

					return contactListener
				},
				b2DebugDraw : Box2D.Dynamics.b2DebugDraw,
				createB2DebugDraw : function() {
					return new Box2D.Dynamics.b2DebugDraw()
				},
				b2FixtureDef : Box2D.Dynamics.b2FixtureDef,
				createB2FixtureDef : function() {
					return new Box2D.Dynamics.b2FixtureDef()
				},
				b2World : Box2D.Dynamics.b2World,
				createB2World : function( gravity, doSleep ) {
					return new Box2D.Dynamics.b2World( gravity, doSleep )
				}
			},
			Collision : {
				Shapes : {
					b2PolygonShape : Box2D.Collision.Shapes.b2PolygonShape,
					createB2PolygonShape : function() {
						return new Box2D.Collision.Shapes.b2PolygonShape()
					},
					b2CircleShape : Box2D.Collision.Shapes.b2CircleShape,
					createB2CircleShape : function( radius ) {
						return new Box2D.Collision.Shapes.b2CircleShape( radius )
					}
				}
			}
		}
	}
)

define(
	'spell/shared/util/platform/private/environment/isHtml5WinPhone',
	function() {
		'use strict'

		return window.external && typeof(window.external.notify ) !== 'undefined'
	}
)

define(
	'spell/shared/util/platform/private/environment/isHtml5Tizen',
	function() {
		'use strict'


		return typeof( tizen ) !== 'undefined'
	}
)

define(
	'spell/shared/util/platform/private/Application',
	[
		'spell/shared/util/platform/private/environment/isHtml5GameClosure',
		'spell/shared/util/platform/private/environment/isHtml5Tizen',
		'spell/shared/util/platform/private/environment/isHtml5WinPhone'
	],
	function(
		isHtml5GameClosure,
	    isHtml5Tizen,
		isHtml5WinPhone
	) {
		'use strict'


		return {
			close : function() {
				if( isHtml5GameClosure ) {
					NATIVE.sendActivityToBack()

				} else if ( isHtml5Tizen ) {
					tizen.application.getCurrentApplication().exit()

				} else if ( isHtml5WinPhone ) {
					window.external.notify( 'endApplication' )
				}
			}
		}
	}
)

/**
 * This class is derived from the library "Underscore" which original license follows:
 *
 * Licence Notice Underscore.js 1.3.3:
 *
 * Copyright (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */
define(
	'spell/shared/util/platform/private/functions',
	function() {
		// Baseline setup
		// --------------

		// Establish the root object, `window` in the browser, or `global` on the server.
		var root = this;

		// Save the previous value of the `_` variable.
		var previousUnderscore = root._;

		// Establish the object that gets returned to break out of a loop iteration.
		var breaker = {};

		// Save bytes in the minified (but not gzipped) version:
		var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

		// Create quick reference variables for speed access to core prototypes.
		var slice            = ArrayProto.slice,
				unshift          = ArrayProto.unshift,
				toString         = ObjProto.toString,
				hasOwnProperty   = ObjProto.hasOwnProperty;

		// All **ECMAScript 5** native function implementations that we hope to use
		// are declared here.
		var
				nativeForEach      = ArrayProto.forEach,
				nativeMap          = ArrayProto.map,
				nativeReduce       = ArrayProto.reduce,
				nativeReduceRight  = ArrayProto.reduceRight,
				nativeFilter       = ArrayProto.filter,
				nativeEvery        = ArrayProto.every,
				nativeSome         = ArrayProto.some,
				nativeIndexOf      = ArrayProto.indexOf,
				nativeLastIndexOf  = ArrayProto.lastIndexOf,
				nativeIsArray      = Array.isArray,
				nativeKeys         = Object.keys,
				nativeBind         = FuncProto.bind;

		// Create a safe reference to the Underscore object for use below.
		var _ = function(obj) { return new wrapper(obj); };

		// Export the Underscore object for **Node.js**, with
		// backwards-compatibility for the old `require()` API. If we're in
		// the browser, add `_` as a global object via a string identifier,
		// for Closure Compiler "advanced" mode.
		if (typeof exports !== 'undefined') {
			if (typeof module !== 'undefined' && module.exports) {
				exports = module.exports = _;
			}
			exports._ = _;
		} else {
			root['_'] = _;
		}

		// Current version.
		_.VERSION = '1.3.3';

		// Collection Functions
		// --------------------

		// The cornerstone, an `each` implementation, aka `forEach`.
		// Handles objects with the built-in `forEach`, arrays, and raw objects.
		// Delegates to **ECMAScript 5**'s native `forEach` if available.
		var each = _.each = _.forEach = function(obj, iterator, context) {
			if (obj == null) return;
			if (nativeForEach && obj.forEach === nativeForEach) {
				obj.forEach(iterator, context);
			} else if ( _.isArray( obj ) ) {
				for (var i = 0, l = obj.length; i < l; i++) {
					if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) return;
				}
			} else {
				for (var key in obj) {
					if (_.has(obj, key)) {
						if (iterator.call(context, obj[key], key, obj) === breaker) return;
					}
				}
			}
		};

		// Return the results of applying the iterator to each element.
		// Delegates to **ECMAScript 5**'s native `map` if available.
		_.map = _.collect = function(obj, iterator, context) {
			var results = [];
			if (obj == null) return results;
			if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
			each(obj, function(value, index, list) {
				results[results.length] = iterator.call(context, value, index, list);
			});
			if ( _.isArray( obj ) ) results.length = obj.length;
			return results;
		};

		// **Reduce** builds up a single result from a list of values, aka `inject`,
		// or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
		_.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
			var initial = arguments.length > 2;
			if (obj == null) obj = [];
			if (nativeReduce && obj.reduce === nativeReduce) {
				if (context) iterator = _.bind(iterator, context);
				return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
			}
			each(obj, function(value, index, list) {
				if (!initial) {
					memo = value;
					initial = true;
				} else {
					memo = iterator.call(context, memo, value, index, list);
				}
			});
			if (!initial) throw new TypeError('Reduce of empty array with no initial value');
			return memo;
		};

		// The right-associative version of reduce, also known as `foldr`.
		// Delegates to **ECMAScript 5**'s native `reduceRight` if available.
		_.reduceRight = _.foldr = function(obj, iterator, memo, context) {
			var initial = arguments.length > 2;
			if (obj == null) obj = [];
			if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
				if (context) iterator = _.bind(iterator, context);
				return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
			}
			var reversed = _.toArray(obj).reverse();
			if (context && !initial) iterator = _.bind(iterator, context);
			return initial ? _.reduce(reversed, iterator, memo, context) : _.reduce(reversed, iterator);
		};

		// Return the first value which passes a truth test. Aliased as `detect`.
		_.find = _.detect = function(obj, iterator, context) {
			var result;
			any(obj, function(value, index, list) {
				if (iterator.call(context, value, index, list)) {
					result = value;
					return true;
				}
			});
			return result;
		};

		// Return all the elements that pass a truth test.
		// Delegates to **ECMAScript 5**'s native `filter` if available.
		// Aliased as `select`.
		_.filter = _.select = function(obj, iterator, context) {
			var results = [];
			if (obj == null) return results;
			if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
			each(obj, function(value, index, list) {
				if (iterator.call(context, value, index, list)) results[results.length] = value;
			});
			return results;
		};

		// Return all the elements for which a truth test fails.
		_.reject = function(obj, iterator, context) {
			var results = [];
			if (obj == null) return results;
			each(obj, function(value, index, list) {
				if (!iterator.call(context, value, index, list)) results[results.length] = value;
			});
			return results;
		};

		// Determine whether all of the elements match a truth test.
		// Delegates to **ECMAScript 5**'s native `every` if available.
		// Aliased as `all`.
		_.every = _.all = function(obj, iterator, context) {
			var result = true;
			if (obj == null) return result;
			if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
			each(obj, function(value, index, list) {
				if (!(result = result && iterator.call(context, value, index, list))) return breaker;
			});
			return !!result;
		};

		// Determine if at least one element in the object matches a truth test.
		// Delegates to **ECMAScript 5**'s native `some` if available.
		// Aliased as `any`.
		var any = _.some = _.any = function(obj, iterator, context) {
			iterator || (iterator = _.identity);
			var result = false;
			if (obj == null) return result;
			if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
			each(obj, function(value, index, list) {
				if (result || (result = iterator.call(context, value, index, list))) return breaker;
			});
			return !!result;
		};

		// Determine if a given value is included in the array or object using `===`.
		// Aliased as `contains`.
		_.include = _.contains = function(obj, target) {
			var found = false;
			if (obj == null) return found;
			if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
			found = any(obj, function(value) {
				return value === target;
			});
			return found;
		};

		// Invoke a method (with arguments) on every item in a collection.
		_.invoke = function(obj, method) {
			var args = slice.call(arguments, 2);
			return _.map(obj, function(value) {
				return (_.isFunction(method) ? method || value : value[method]).apply(value, args);
			});
		};

		// Convenience version of a common use case of `map`: fetching a property.
		_.pluck = function(obj, key) {
			return _.map(obj, function(value){ return value[key]; });
		};

		// Return the maximum element or (element-based computation).
		_.max = function(obj, iterator, context) {
			if (!iterator && _.isArray(obj) && obj[0] === +obj[0]) return Math.max.apply(Math, obj);
			if (!iterator && _.isEmpty(obj)) return -Infinity;
			var result = {computed : -Infinity};
			each(obj, function(value, index, list) {
				var computed = iterator ? iterator.call(context, value, index, list) : value;
				computed >= result.computed && (result = {value : value, computed : computed});
			});
			return result.value;
		};

		// Return the minimum element (or element-based computation).
		_.min = function(obj, iterator, context) {
			if (!iterator && _.isArray(obj) && obj[0] === +obj[0]) return Math.min.apply(Math, obj);
			if (!iterator && _.isEmpty(obj)) return Infinity;
			var result = {computed : Infinity};
			each(obj, function(value, index, list) {
				var computed = iterator ? iterator.call(context, value, index, list) : value;
				computed < result.computed && (result = {value : value, computed : computed});
			});
			return result.value;
		};

		// Shuffle an array.
		_.shuffle = function(obj) {
			var shuffled = [], rand;
			each(obj, function(value, index, list) {
				rand = Math.floor(Math.random() * (index + 1));
				shuffled[index] = shuffled[rand];
				shuffled[rand] = value;
			});
			return shuffled;
		};

		// Sort the object's values by a criterion produced by an iterator.
		_.sortBy = function(obj, val, context) {
			var iterator = _.isFunction(val) ? val : function(obj) { return obj[val]; };
			return _.pluck(_.map(obj, function(value, index, list) {
				return {
					value : value,
					criteria : iterator.call(context, value, index, list)
				};
			}).sort(function(left, right) {
						var a = left.criteria, b = right.criteria;
						if (a === void 0) return 1;
						if (b === void 0) return -1;
						return a < b ? -1 : a > b ? 1 : 0;
					}), 'value');
		};

		// Groups the object's values by a criterion. Pass either a string attribute
		// to group by, or a function that returns the criterion.
		_.groupBy = function(obj, val) {
			var result = {};
			var iterator = _.isFunction(val) ? val : function(obj) { return obj[val]; };
			each(obj, function(value, index) {
				var key = iterator(value, index);
				(result[key] || (result[key] = [])).push(value);
			});
			return result;
		};

		// Use a comparator function to figure out at what index an object should
		// be inserted so as to maintain order. Uses binary search.
		_.sortedIndex = function(array, obj, iterator) {
			iterator || (iterator = _.identity);
			var low = 0, high = array.length;
			while (low < high) {
				var mid = (low + high) >> 1;
				iterator(array[mid]) < iterator(obj) ? low = mid + 1 : high = mid;
			}
			return low;
		};

		// Safely convert anything iterable into a real, live array.
		_.toArray = function(obj) {
			if (!obj)                                     return [];
			if (_.isArray(obj))                           return slice.call(obj);
			if (_.isArguments(obj))                       return slice.call(obj);
			if (obj.toArray && _.isFunction(obj.toArray)) return obj.toArray();
			return _.values(obj);
		};

		// Return the number of elements in an object.
		_.size = function(obj) {
			return _.isArray(obj) ? obj.length : _.keys(obj).length;
		};

		// Array Functions
		// ---------------

		// Get the first element of an array. Passing **n** will return the first N
		// values in the array. Aliased as `head` and `take`. The **guard** check
		// allows it to work with `_.map`.
		_.first = _.head = _.take = function(array, n, guard) {
			return (n != null) && !guard ? slice.call(array, 0, n) : array[0];
		};

		// Returns everything but the last entry of the array. Especcialy useful on
		// the arguments object. Passing **n** will return all the values in
		// the array, excluding the last N. The **guard** check allows it to work with
		// `_.map`.
		_.initial = function(array, n, guard) {
			return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
		};

		// Get the last element of an array. Passing **n** will return the last N
		// values in the array. The **guard** check allows it to work with `_.map`.
		_.last = function(array, n, guard) {
			if ((n != null) && !guard) {
				return slice.call(array, Math.max(array.length - n, 0));
			} else {
				return array[array.length - 1];
			}
		};

		// Returns everything but the first entry of the array. Aliased as `tail`.
		// Especially useful on the arguments object. Passing an **index** will return
		// the rest of the values in the array from that index onward. The **guard**
		// check allows it to work with `_.map`.
		_.rest = _.tail = function(array, index, guard) {
			return slice.call(array, (index == null) || guard ? 1 : index);
		};

		// Trim out all falsy values from an array.
		_.compact = function(array) {
			return _.filter(array, function(value){ return !!value; });
		};

		// Return a completely flattened version of an array.
		_.flatten = function(array, shallow) {
			return _.reduce(array, function(memo, value) {
				if (_.isArray(value)) return memo.concat(shallow ? value : _.flatten(value));
				memo[memo.length] = value;
				return memo;
			}, []);
		};

		// Return a version of the array that does not contain the specified value(s).
		_.without = function(array) {
			return _.difference(array, slice.call(arguments, 1));
		};

		// Produce a duplicate-free version of the array. If the array has already
		// been sorted, you have the option of using a faster algorithm.
		// Aliased as `unique`.
		_.uniq = _.unique = function(array, isSorted, iterator) {
			var initial = iterator ? _.map(array, iterator) : array;
			var results = [];
			// The `isSorted` flag is irrelevant if the array only contains two elements.
			if (array.length < 3) isSorted = true;
			_.reduce(initial, function (memo, value, index) {
				if (isSorted ? _.last(memo) !== value || !memo.length : !_.include(memo, value)) {
					memo.push(value);
					results.push(array[index]);
				}
				return memo;
			}, []);
			return results;
		};

		// Produce an array that contains the union: each distinct element from all of
		// the passed-in arrays.
		_.union = function() {
			return _.uniq(_.flatten(arguments, true));
		};

		// Produce an array that contains every item shared between all the
		// passed-in arrays. (Aliased as "intersect" for back-compat.)
		_.intersection = _.intersect = function(array) {
			var rest = slice.call(arguments, 1);
			return _.filter(_.uniq(array), function(item) {
				return _.every(rest, function(other) {
					return _.indexOf(other, item) >= 0;
				});
			});
		};

		// Take the difference between one array and a number of other arrays.
		// Only the elements present in just the first array will remain.
		_.difference = function(array) {
			var rest = _.flatten(slice.call(arguments, 1), true);
			return _.filter(array, function(value){ return !_.include(rest, value); });
		};

		// Zip together multiple lists into a single array -- elements that share
		// an index go together.
		_.zip = function() {
			var args = slice.call(arguments);
			var length = _.max(_.pluck(args, 'length'));
			var results = new Array(length);
			for (var i = 0; i < length; i++) results[i] = _.pluck(args, "" + i);
			return results;
		};

		// If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
		// we need this function. Return the position of the first occurrence of an
		// item in an array, or -1 if the item is not included in the array.
		// Delegates to **ECMAScript 5**'s native `indexOf` if available.
		// If the array is large and already in sort order, pass `true`
		// for **isSorted** to use binary search.
		_.indexOf = function(array, item, isSorted) {
			if (array == null) return -1;
			var i, l;
			if (isSorted) {
				i = _.sortedIndex(array, item);
				return array[i] === item ? i : -1;
			}
			if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item);
			for (i = 0, l = array.length; i < l; i++) if (i in array && array[i] === item) return i;
			return -1;
		};

		// Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
		_.lastIndexOf = function(array, item) {
			if (array == null) return -1;
			if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) return array.lastIndexOf(item);
			var i = array.length;
			while (i--) if (i in array && array[i] === item) return i;
			return -1;
		};

		// Generate an integer Array containing an arithmetic progression. A port of
		// the native Python `range()` function. See
		// [the Python documentation](http://docs.python.org/library/functions.html#range).
		_.range = function(start, stop, step) {
			if (arguments.length <= 1) {
				stop = start || 0;
				start = 0;
			}
			step = arguments[2] || 1;

			var len = Math.max(Math.ceil((stop - start) / step), 0);
			var idx = 0;
			var range = new Array(len);

			while(idx < len) {
				range[idx++] = start;
				start += step;
			}

			return range;
		};

		// Function (ahem) Functions
		// ------------------

		// Reusable constructor function for prototype setting.
		var ctor = function(){};

		// Create a function bound to a given object (assigning `this`, and arguments,
		// optionally). Binding with arguments is also known as `curry`.
		// Delegates to **ECMAScript 5**'s native `Function.bind` if available.
		// We check for `func.bind` first, to fail fast when `func` is undefined.
		_.bind = function bind(func, context) {
			var bound, args;
			if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
			if (!_.isFunction(func)) throw new TypeError;
			args = slice.call(arguments, 2);
			return bound = function() {
				if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
				ctor.prototype = func.prototype;
				var self = new ctor;
				var result = func.apply(self, args.concat(slice.call(arguments)));
				if (Object(result) === result) return result;
				return self;
			};
		};

		// Bind all of an object's methods to that object. Useful for ensuring that
		// all callbacks defined on an object belong to it.
		_.bindAll = function(obj) {
			var funcs = slice.call(arguments, 1);
			if (funcs.length == 0) funcs = _.functions(obj);
			each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
			return obj;
		};

		// Memoize an expensive function by storing its results.
		_.memoize = function(func, hasher) {
			var memo = {};
			hasher || (hasher = _.identity);
			return function() {
				var key = hasher.apply(this, arguments);
				return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
			};
		};

		// Delays a function for the given number of milliseconds, and then calls
		// it with the arguments supplied.
		_.delay = function(func, wait) {
			var args = slice.call(arguments, 2);
			return setTimeout(function(){ return func.apply(null, args); }, wait);
		};

		// Defers a function, scheduling it to run after the current call stack has
		// cleared.
		_.defer = function(func) {
			return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
		};

		// Returns a function, that, when invoked, will only be triggered at most once
		// during a given window of time.
		_.throttle = function(func, wait) {
			var context, args, timeout, throttling, more, result;
			var whenDone = _.debounce(function(){ more = throttling = false; }, wait);
			return function() {
				context = this; args = arguments;
				var later = function() {
					timeout = null;
					if (more) func.apply(context, args);
					whenDone();
				};
				if (!timeout) timeout = setTimeout(later, wait);
				if (throttling) {
					more = true;
				} else {
					result = func.apply(context, args);
				}
				whenDone();
				throttling = true;
				return result;
			};
		};

		// Returns a function, that, as long as it continues to be invoked, will not
		// be triggered. The function will be called after it stops being called for
		// N milliseconds. If `immediate` is passed, trigger the function on the
		// leading edge, instead of the trailing.
		_.debounce = function(func, wait, immediate) {
			var timeout;
			return function() {
				var context = this, args = arguments;
				var later = function() {
					timeout = null;
					if (!immediate) func.apply(context, args);
				};
				if (immediate && !timeout) func.apply(context, args);
				clearTimeout(timeout);
				timeout = setTimeout(later, wait);
			};
		};

		// Returns a function that will be executed at most one time, no matter how
		// often you call it. Useful for lazy initialization.
		_.once = function(func) {
			var ran = false, memo;
			return function() {
				if (ran) return memo;
				ran = true;
				return memo = func.apply(this, arguments);
			};
		};

		// Returns the first function passed as an argument to the second,
		// allowing you to adjust arguments, run code before and after, and
		// conditionally execute the original function.
		_.wrap = function(func, wrapper) {
			return function() {
				var args = [func].concat(slice.call(arguments, 0));
				return wrapper.apply(this, args);
			};
		};

		// Returns a function that is the composition of a list of functions, each
		// consuming the return value of the function that follows.
		_.compose = function() {
			var funcs = arguments;
			return function() {
				var args = arguments;
				for (var i = funcs.length - 1; i >= 0; i--) {
					args = [funcs[i].apply(this, args)];
				}
				return args[0];
			};
		};

		// Returns a function that will only be executed after being called N times.
		_.after = function(times, func) {
			if (times <= 0) return func();
			return function() {
				if (--times < 1) { return func.apply(this, arguments); }
			};
		};

		// Object Functions
		// ----------------

		// Retrieve the names of an object's properties.
		// Delegates to **ECMAScript 5**'s native `Object.keys`
		_.keys = nativeKeys || function(obj) {
			if (obj !== Object(obj)) throw new TypeError('Invalid object');
			var keys = [];
			for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;
			return keys;
		};

		// Retrieve the values of an object's properties.
		_.values = function(obj) {
			return _.map(obj, _.identity);
		};

		// Return a sorted list of the function names available on the object.
		// Aliased as `methods`
		_.functions = _.methods = function(obj) {
			var names = [];
			for (var key in obj) {
				if (_.isFunction(obj[key])) names.push(key);
			}
			return names.sort();
		};

		// Extend a given object with all the properties in passed-in object(s).
		_.extend = function(obj) {
			each(slice.call(arguments, 1), function(source) {
				for (var prop in source) {
					obj[prop] = source[prop];
				}
			});
			return obj;
		};

		// Return a copy of the object only containing the whitelisted properties.
		_.pick = function(obj) {
			var result = {};
			each(_.flatten(slice.call(arguments, 1)), function(key) {
				if (key in obj) result[key] = obj[key];
			});
			return result;
		};

		// Fill in a given object with default properties.
		_.defaults = function(obj) {
			each(slice.call(arguments, 1), function(source) {
				for (var prop in source) {
					if (obj[prop] == null) obj[prop] = source[prop];
				}
			});
			return obj;
		};

		// Create a (shallow-cloned) duplicate of an object.
		_.clone = function(obj) {
			if (!_.isObject(obj)) return obj;
			return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
		};

		// Invokes interceptor with the obj, and then returns obj.
		// The primary purpose of this method is to "tap into" a method chain, in
		// order to perform operations on intermediate results within the chain.
		_.tap = function(obj, interceptor) {
			interceptor(obj);
			return obj;
		};

		// Internal recursive comparison function.
		function eq(a, b, stack) {
			// Identical objects are equal. `0 === -0`, but they aren't identical.
			// See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.
			if (a === b) return a !== 0 || 1 / a == 1 / b;
			// A strict comparison is necessary because `null == undefined`.
			if (a == null || b == null) return a === b;
			// Unwrap any wrapped objects.
			if (a._chain) a = a._wrapped;
			if (b._chain) b = b._wrapped;
			// Invoke a custom `isEqual` method if one is provided.
			if (a.isEqual && _.isFunction(a.isEqual)) return a.isEqual(b);
			if (b.isEqual && _.isFunction(b.isEqual)) return b.isEqual(a);
			// Compare `[[Class]]` names.
			var className = toString.call(a);
			if (className != toString.call(b)) return false;
			switch (className) {
				// Strings, numbers, dates, and booleans are compared by value.
				case '[object String]':
					// Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
					// equivalent to `new String("5")`.
					return a == String(b);
				case '[object Number]':
					// `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
					// other numeric values.
					return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
				case '[object Date]':
				case '[object Boolean]':
					// Coerce dates and booleans to numeric primitive values. Dates are compared by their
					// millisecond representations. Note that invalid dates with millisecond representations
					// of `NaN` are not equivalent.
					return +a == +b;
				// RegExps are compared by their source patterns and flags.
				case '[object RegExp]':
					return a.source == b.source &&
							a.global == b.global &&
							a.multiline == b.multiline &&
							a.ignoreCase == b.ignoreCase;
			}
			if (typeof a != 'object' || typeof b != 'object') return false;
			// Assume equality for cyclic structures. The algorithm for detecting cyclic
			// structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
			var length = stack.length;
			while (length--) {
				// Linear search. Performance is inversely proportional to the number of
				// unique nested structures.
				if (stack[length] == a) return true;
			}
			// Add the first object to the stack of traversed objects.
			stack.push(a);
			var size = 0, result = true;
			// Recursively compare objects and arrays.
			if (className == '[object Array]') {
				// Compare array lengths to determine if a deep comparison is necessary.
				size = a.length;
				result = size == b.length;
				if (result) {
					// Deep compare the contents, ignoring non-numeric properties.
					while (size--) {
						// Ensure commutative equality for sparse arrays.
						if (!(result = size in a == size in b && eq(a[size], b[size], stack))) break;
					}
				}
			} else {
				// Objects with different constructors are not equivalent.
				if ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) return false;
				// Deep compare objects.
				for (var key in a) {
					if (_.has(a, key)) {
						// Count the expected number of properties.
						size++;
						// Deep compare each member.
						if (!(result = _.has(b, key) && eq(a[key], b[key], stack))) break;
					}
				}
				// Ensure that both objects contain the same number of properties.
				if (result) {
					for (key in b) {
						if (_.has(b, key) && !(size--)) break;
					}
					result = !size;
				}
			}
			// Remove the first object from the stack of traversed objects.
			stack.pop();
			return result;
		}

		// Perform a deep comparison to check if two objects are equal.
		_.isEqual = function(a, b) {
			return eq(a, b, []);
		};

		// Is a given array, string, or object empty?
		// An "empty" object has no enumerable own-properties.
		_.isEmpty = function(obj) {
			if (obj == null) return true;
			if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
			for (var key in obj) if (_.has(obj, key)) return false;
			return true;
		};

		// Is a given value a DOM element?
		_.isElement = function(obj) {
			return !!(obj && obj.nodeType == 1);
		};

		// Is a given value an array?
		// Delegates to ECMA5's native Array.isArray
		_.isArray = nativeIsArray || function(obj) {
			return toString.call(obj) == '[object Array]';
		};

		// Is a given variable an object?
		_.isObject = function(obj) {
			return obj === Object(obj);
		};

		// Is a given variable an arguments object?
		_.isArguments = function(obj) {
			return toString.call(obj) == '[object Arguments]';
		};
		if (!_.isArguments(arguments)) {
			_.isArguments = function(obj) {
				return !!(obj && _.has(obj, 'callee'));
			};
		}

		// Is a given value a function?
		_.isFunction = function(obj) {
			return toString.call(obj) == '[object Function]';
		};

		// Is a given value a string?
		_.isString = function(obj) {
			return toString.call(obj) == '[object String]';
		};

		// Is a given value a number?
		_.isNumber = function(obj) {
			return toString.call(obj) == '[object Number]';
		};

		// Is a given object a finite number?
		_.isFinite = function(obj) {
			return _.isNumber(obj) && isFinite(obj);
		};

		// Is the given value `NaN`?
		_.isNaN = function(obj) {
			// `NaN` is the only value for which `===` is not reflexive.
			return obj !== obj;
		};

		// Is a given value a boolean?
		_.isBoolean = function(obj) {
			return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
		};

		// Is a given value a date?
		_.isDate = function(obj) {
			return toString.call(obj) == '[object Date]';
		};

		// Is the given value a regular expression?
		_.isRegExp = function(obj) {
			return toString.call(obj) == '[object RegExp]';
		};

		// Is a given value equal to null?
		_.isNull = function(obj) {
			return obj === null;
		};

		// Is a given variable undefined?
		_.isUndefined = function(obj) {
			return obj === void 0;
		};

		// Has own property?
		_.has = function(obj, key) {
			return hasOwnProperty.call(obj, key);
		};

		// Utility Functions
		// -----------------

		// Run Underscore.js in *noConflict* mode, returning the `_` variable to its
		// previous owner. Returns a reference to the Underscore object.
		_.noConflict = function() {
			root._ = previousUnderscore;
			return this;
		};

		// Keep the identity function around for default iterators.
		_.identity = function(value) {
			return value;
		};

		// Run a function **n** times.
		_.times = function (n, iterator, context) {
			for (var i = 0; i < n; i++) iterator.call(context, i);
		};

		// Escape a string for HTML interpolation.
		_.escape = function(string) {
			return (''+string).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#x27;').replace(/\//g,'&#x2F;');
		};

		// If the value of the named property is a function then invoke it;
		// otherwise, return it.
		_.result = function(object, property) {
			if (object == null) return null;
			var value = object[property];
			return _.isFunction(value) ? value.call(object) : value;
		};

		// Add your own custom functions to the Underscore object, ensuring that
		// they're correctly added to the OOP wrapper as well.
		_.mixin = function(obj) {
			each(_.functions(obj), function(name){
				addToWrapper(name, _[name] = obj[name]);
			});
		};

		// Generate a unique integer id (unique within the entire client session).
		// Useful for temporary DOM ids.
		var idCounter = 0;
		_.uniqueId = function(prefix) {
			var id = idCounter++;
			return prefix ? prefix + id : id;
		};

		// By default, Underscore uses ERB-style template delimiters, change the
		// following template settings to use alternative delimiters.
		_.templateSettings = {
			evaluate    : /<%([\s\S]+?)%>/g,
			interpolate : /<%=([\s\S]+?)%>/g,
			escape      : /<%-([\s\S]+?)%>/g
		};

		// When customizing `templateSettings`, if you don't want to define an
		// interpolation, evaluation or escaping regex, we need one that is
		// guaranteed not to match.
		var noMatch = /.^/;

		// Certain characters need to be escaped so that they can be put into a
		// string literal.
		var escapes = {
			'\\': '\\',
			"'": "'",
			'r': '\r',
			'n': '\n',
			't': '\t',
			'u2028': '\u2028',
			'u2029': '\u2029'
		};

		for (var p in escapes) escapes[escapes[p]] = p;
		var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;
		var unescaper = /\\(\\|'|r|n|t|u2028|u2029)/g;

		// Within an interpolation, evaluation, or escaping, remove HTML escaping
		// that had been previously added.
		var unescape = function(code) {
			return code.replace(unescaper, function(match, escape) {
				return escapes[escape];
			});
		};

		// JavaScript micro-templating, similar to John Resig's implementation.
		// Underscore templating handles arbitrary delimiters, preserves whitespace,
		// and correctly escapes quotes within interpolated code.
		_.template = function(text, data, settings) {
			settings = _.defaults(settings || {}, _.templateSettings);

			// Compile the template source, taking care to escape characters that
			// cannot be included in a string literal and then unescape them in code
			// blocks.
			var source = "__p+='" + text
					.replace(escaper, function(match) {
				return '\\' + escapes[match];
			})
					.replace(settings.escape || noMatch, function(match, code) {
						return "'+\n_.escape(" + unescape(code) + ")+\n'";
					})
					.replace(settings.interpolate || noMatch, function(match, code) {
						return "'+\n(" + unescape(code) + ")+\n'";
					})
					.replace(settings.evaluate || noMatch, function(match, code) {
						return "';\n" + unescape(code) + "\n;__p+='";
					}) + "';\n";

			// If a variable is not specified, place data values in local scope.
			if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

			source = "var __p='';" +
					"var print=function(){__p+=Array.prototype.join.call(arguments, '')};\n" +
					source + "return __p;\n";

			var render = new Function(settings.variable || 'obj', '_', source);
			if (data) return render(data, _);
			var template = function(data) {
				return render.call(this, data, _);
			};

			// Provide the compiled function source as a convenience for build time
			// precompilation.
			template.source = 'function(' + (settings.variable || 'obj') + '){\n' +
					source + '}';

			return template;
		};

		// Add a "chain" function, which will delegate to the wrapper.
		_.chain = function(obj) {
			return _(obj).chain();
		};

		// The OOP Wrapper
		// ---------------

		// If Underscore is called as a function, it returns a wrapped object that
		// can be used OO-style. This wrapper holds altered versions of all the
		// underscore functions. Wrapped objects may be chained.
		var wrapper = function(obj) { this._wrapped = obj; };

		// Expose `wrapper.prototype` as `_.prototype`
		_.prototype = wrapper.prototype;

		// Helper function to continue chaining intermediate results.
		var result = function(obj, chain) {
			return chain ? _(obj).chain() : obj;
		};

		// A method to easily add functions to the OOP wrapper.
		var addToWrapper = function(name, func) {
			wrapper.prototype[name] = function() {
				var args = slice.call(arguments);
				unshift.call(args, this._wrapped);
				return result(func.apply(_, args), this._chain);
			};
		};

		// Add all of the Underscore functions to the wrapper object.
		_.mixin(_);

		// Add all mutator Array functions to the wrapper.
		each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
			var method = ArrayProto[name];
			wrapper.prototype[name] = function() {
				var wrapped = this._wrapped;
				method.apply(wrapped, arguments);
				var length = wrapped.length;
				if ((name == 'shift' || name == 'splice') && length === 0) delete wrapped[0];
				return result(wrapped, this._chain);
			};
		});

		// Add all accessor Array functions to the wrapper.
		each(['concat', 'join', 'slice'], function(name) {
			var method = ArrayProto[name];
			wrapper.prototype[name] = function() {
				return result(method.apply(this._wrapped, arguments), this._chain);
			};
		});

		// Start chaining a wrapped Underscore object.
		wrapper.prototype.chain = function() {
			this._chain = true;
			return this;
		};

		// Extracts the result from a wrapped and chained object.
		wrapper.prototype.value = function() {
			return this._wrapped;
		};

		return _.noConflict()
	}
)

define(
	'spell/shared/util/platform/private/registerTimer',
	function() {
		'use strict'


		/*
		 * callback - the callback to call
		 * timeInMs - the number of milliseconds that the callback is delayed by
		 */
		return function( callback, timeInMs ) {
			setTimeout( callback, timeInMs )
		}
	}
)

define(
	'spell/shared/util/platform/private/environment/isHtml5GameClosure',
	function() {
		'use strict'


		return typeof( NATIVE ) !== 'undefined'
	}
)

define(
	'spell/shared/util/platform/private/environment/isHtml5Ejecta',
	function() {
		'use strict'


		return typeof( ejecta ) !== 'undefined'
	}
)

define(
	'spell/shared/util/platform/private/advertisement',
	[
		'spell/shared/util/platform/private/environment/isHtml5Ejecta',
		'spell/shared/util/platform/private/environment/isHtml5GameClosure',
		'spell/shared/util/platform/private/registerTimer',
		'spell/functions'
	],
	function(
		isHtml5Ejecta,
		isHtml5GameClosure,
		registerTimer,
		_
	) {
		'use strict'


		var mutedState = false,
			isPaused   = false

		var processInterstitial = function( spell, event ) {
			if( event.isShown ) {
				if( isPaused ) return

				isPaused = true

				// delay pausing because the chartboost interstitial takes its time
				registerTimer(
					function() {
						spell.audioContext.pauseContext()
						spell.mainLoop.pause()
					},
					100
				)

			} else {
				if( !isPaused ) return

				isPaused = false

				spell.audioContext.resumeContext()
				spell.mainLoop.resume()
			}
		}

		return {
			init : function( spell, next ) {
				var processInterstitialPartial = _.bind( processInterstitial, null, spell )

				if( isHtml5Ejecta ) {
					document.addEventListener( 'interstitial', processInterstitialPartial )

				} else if( isHtml5GameClosure ) {
					NATIVE.events.registerHandler( 'interstitial', processInterstitialPartial )
				}

				next()
			},
			loadInterstitial : function() {
				if( isHtml5Ejecta ) {
					ejecta.loadInterstitial()

				} else if( isHtml5GameClosure ) {
					NATIVE.plugins.sendEvent( 'AdMobPlugin', 'loadInterstitial', JSON.stringify( {} ) )
				}
			},
			showInterstitial : function() {
				if( isHtml5Ejecta ) {
					ejecta.showInterstitial()

				} else if( isHtml5GameClosure ) {
					NATIVE.plugins.sendEvent( 'AdMobPlugin', 'showInterstitial', JSON.stringify( {} ) )
				}
			}
		}
	}
)

define( 'spell/client/isDebug', function() { return true } )
